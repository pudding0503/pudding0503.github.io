<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/regular-expression/"/>
    <url>/regular-expression/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基础正则表达式速查表"><a href="#1-基础正则表达式速查表" class="headerlink" title="1.基础正则表达式速查表"></a>1.基础正则表达式速查表</h1><h2 id="1-1-字符"><a href="#1-1-字符" class="headerlink" title="1.1 字符"></a>1.1 字符</h2><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>[abc]</td><td>字符集。匹配集合中所含的任一字符。</td></tr><tr><td>[^abc]</td><td>否定字符集。匹配任何不在集合中的字符。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。</td></tr><tr><td>.</td><td>匹配除换行符以外的任何单个字符。</td></tr><tr><td>\</td><td>转义字符。</td></tr><tr><td>\w</td><td>匹配任何字母数字，包括下划线（等价于[A-Za-z0-9_]）。</td></tr><tr><td>\W</td><td>匹配任何非字母数字（等价于[^A-Za-z0-9_]）。</td></tr><tr><td>\d</td><td>数字。匹配任何数字。</td></tr><tr><td>\D</td><td>非数字。匹配任何非数字字符。</td></tr><tr><td>\s</td><td>空白。匹配任何空白字符，包括空格、制表符等。</td></tr><tr><td>\S</td><td>非空白。匹配任何非空白字符。</td></tr></tbody></table><h2 id="1-2-分组和引用"><a href="#1-2-分组和引用" class="headerlink" title="1.2 分组和引用"></a>1.2 分组和引用</h2><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>(expression)</td><td>分组。匹配括号里的整个表达式。</td></tr><tr><td>(?:expression)</td><td>非捕获分组。匹配括号里的整个字符串但不获取匹配结果，拿不到分组引用。</td></tr><tr><td>\num</td><td>对前面所匹配分组的引用。比如(\d)\1可以匹配两个相同的数字，(Code)(Sheep)\1\2则可以匹配CodeSheepCodeSheep。</td></tr></tbody></table><h2 id="1-3-锚点-x2F-边界"><a href="#1-3-锚点-x2F-边界" class="headerlink" title="1.3 锚点&#x2F;边界"></a>1.3 锚点&#x2F;边界</h2><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串或行开头。</td></tr><tr><td>$</td><td>匹配字符串或行结尾。</td></tr><tr><td>\b</td><td>匹配单词边界。比如Sheep\b可以匹配CodeSheep末尾的Sheep，不能匹配CodeSheepCode中的Sheep。</td></tr><tr><td>\B</td><td>匹配非单词边界。比如Code\B可以匹配HelloCodeSheep中的Code，不能匹配HelloCode中的Code。</td></tr></tbody></table><h2 id="1-4-数量表示"><a href="#1-4-数量表示" class="headerlink" title="1.4 数量表示"></a>1.4 数量表示</h2><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>?</td><td>匹配前面的表达式0个或1个。即表示可选项。</td></tr><tr><td>+</td><td>匹配前面的表达式至少1个。</td></tr><tr><td>*</td><td>匹配前面的表达式0个或多个。</td></tr><tr><td></td><td></td></tr><tr><td>{m}</td><td>匹配前面的表达式m个。</td></tr><tr><td>{m,}</td><td>匹配前面的表达式最少m个。</td></tr><tr><td>{m,n}</td><td>匹配前面的表达式最少m个，最多n个。</td></tr></tbody></table><h2 id="1-5-预查断言"><a href="#1-5-预查断言" class="headerlink" title="1.5 预查断言"></a>1.5 预查断言</h2><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>(?&#x3D;)</td><td>正向预查。比如Code(?&#x3D;Sheep)能匹配CodeSheep中的Code，但不能匹配CodePig中的Code。</td></tr><tr><td>(?!)</td><td>正向否定预查。比如Code(?!Sheep)不能匹配CodeSheep中的Code，但能匹配CodePig中的Code。</td></tr><tr><td>(?&lt;&#x3D;)</td><td>反向预查。比如(?&lt;&#x3D;Code)Sheep能匹配CodeSheep中的Sheep，但不能匹配ReadSheep中的Sheep。</td></tr><tr><td>(?&lt;!)</td><td>反向否定预查。比如(?&lt;!Code)Sheep不能匹配CodeSheep中的Sheep，但能匹配ReadSheep中的Sheep。</td></tr></tbody></table><h2 id="1-6-特殊标志"><a href="#1-6-特殊标志" class="headerlink" title="1.6 特殊标志"></a>1.6 特殊标志</h2><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>&#x2F;…&#x2F;i</td><td>忽略大小写。</td></tr><tr><td>&#x2F;…&#x2F;g</td><td>全局匹配。</td></tr><tr><td>&#x2F;…&#x2F;m</td><td>多行修饰符。用于多行匹配。</td></tr></tbody></table><h1 id="2-常用正则表达式示例"><a href="#2-常用正则表达式示例" class="headerlink" title="2.常用正则表达式示例"></a>2.常用正则表达式示例</h1><h2 id="2-1-数字校验"><a href="#2-1-数字校验" class="headerlink" title="2.1 数字校验"></a>2.1 数字校验</h2><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>数字</td><td>^[0-9]*$</td><td></td></tr><tr><td>n位数字</td><td>^\d{n}$</td><td></td></tr><tr><td>至少n位数字</td><td>^\d{n,}$</td><td></td></tr><tr><td>m~n位数字</td><td>^\d{m,n}$</td><td></td></tr><tr><td>整数</td><td>^(-?[1-9]\d*)$</td><td>非0开头，包括正整数和负整数</td></tr><tr><td>正整数</td><td>^[1-9]\d*$</td><td></td></tr><tr><td>负整数</td><td>^-[1-9]\d*$</td><td></td></tr><tr><td>非负整数</td><td>^(([1-9]\d*)</td><td>0)$</td></tr><tr><td>非正整数</td><td>^((-[1-9]\d*)</td><td>0)$</td></tr><tr><td>浮点数</td><td>^-?(?:[1-9]\d<em>.\d</em></td><td>0.\d*[1-9]\d*</td></tr><tr><td>正浮点数</td><td>^(?:[1-9]\d<em>.\d</em></td><td>0.\d*[1-9]\d*)$</td></tr><tr><td>负浮点数</td><td>^-(?:[1-9]\d<em>.\d</em></td><td>0.\d*[1-9]\d*)$</td></tr><tr><td>非正浮点数</td><td>^(?:-(?:[1-9]\d*.\d+</td><td>0.\d*[1-9]\d*)</td></tr><tr><td>非负浮点数</td><td>^(?:[1-9]\d*.\d+</td><td>0.\d+</td></tr><tr><td>仅一位小数</td><td>^-?(?:0</td><td>[1-9][0-9]*).[0-9]{1}$</td></tr><tr><td>最少一位小数</td><td>^-?(?:0</td><td>[1-9][0-9]*).[0-9]{1,}$</td></tr><tr><td>最多两位小数</td><td>^-?(?:0</td><td>[1-9][0-9]*).[0-9]{1,2}$</td></tr><tr><td>连续重复的数字</td><td>^(\d)\1+$</td><td>例如：111，222</td></tr></tbody></table><h2 id="2-2-字符校验"><a href="#2-2-字符校验" class="headerlink" title="2.2 字符校验"></a>2.2 字符校验</h2><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>中文</td><td>^[\u4E00-\u9FA5]+$</td><td></td></tr><tr><td>全角字符</td><td>^[\uFF00-\uFFFF]+$</td><td></td></tr><tr><td>半角字符</td><td>^[\u0000-\u00FF]+$</td><td></td></tr><tr><td>英文字符串（大写）</td><td>^[A-Z]+$</td><td></td></tr><tr><td>英文字符串（小写）</td><td>^[a-z]+$</td><td></td></tr><tr><td>英文字符串（不区分大小写）</td><td>^[A-Za-z]+$</td><td></td></tr><tr><td>中文和数字</td><td>^(?:[\u4E00-\u9FA5]{0,}</td><td>\d)+$</td></tr><tr><td>英文和数字</td><td>^[A-Za-z0-9]+$</td><td></td></tr><tr><td>数字、英文字母或者下划线组成的字符串</td><td>^\w+$</td><td></td></tr><tr><td>中文、英文、数字包括下划线</td><td>^[\u4E00-\u9FA5\w]+$</td><td></td></tr><tr><td>不含字母的字符串</td><td>^[^A-Za-z]*$</td><td></td></tr><tr><td>连续重复的字符串</td><td>^(.)\1+$</td><td>例如：aaa，bbb</td></tr><tr><td>长度为n的字符串</td><td>^.{n}$</td><td></td></tr><tr><td>ASCII</td><td>^[ -~]$</td><td></td></tr></tbody></table><h2 id="2-3-日期和时间校验"><a href="#2-3-日期和时间校验" class="headerlink" title="2.3 日期和时间校验"></a>2.3 日期和时间校验</h2><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>日期</td><td>^\d{1,4}-(?:1[0-2]</td><td>0?[1-9])-(?:0?[1-9]</td></tr><tr><td>日期</td><td>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]</td><td>1[0-2])-(?:0[1-9]</td></tr><tr><td>时间</td><td>^(?:1[0-2]</td><td>0?[1-9]):[0-5]\d:[0-5]\d$</td></tr><tr><td>时间</td><td>^(?:[01]\d</td><td>2[0-3]):[0-5]\d:[0-5]\d$</td></tr><tr><td>日期+时间</td><td>^(\d{1,4}-(?:1[0-2]</td><td>0?[1-9])-(?:0?[1-9]</td></tr></tbody></table><h2 id="2-4-日常生活相关"><a href="#2-4-日常生活相关" class="headerlink" title="2.4 日常生活相关"></a>2.4 日常生活相关</h2><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>中文名</td><td>^[\u4E00-\u9FA5·]{2,16}$</td><td></td></tr><tr><td>英文名</td><td>^[a-zA-Z][a-zA-Z\s]{0,20}[a-zA-Z]$</td><td></td></tr><tr><td>车牌号</td><td>^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z][A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳]$</td><td>不含新能源</td></tr><tr><td>车牌号</td><td>^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领]<a href="?:(?:%5BA-HJ-NP-Z0-9%5D%7B4%7D%5BA-HJ-NP-Z0-9%E6%8C%82%E5%AD%A6%E8%AD%A6%E6%B8%AF%E6%BE%B3%5D">A-HJ-NP-Z</a></td><td>(?:(?:\d{5}[A-HJK])</td></tr><tr><td>火车车次</td><td>^[GCDZTSPKXLY1-9]\d{1,4}$</td><td>例如：G1234</td></tr><tr><td>手机号</td><td>^(?:(?:+</td><td>00)86)?1[3-9]\d{9}$</td></tr><tr><td>手机号</td><td>^(?:(?:+</td><td>00)86)?1(?:(?:3[\d])</td></tr><tr><td>固话号码</td><td>^(?:(?:\d{3}-)?\d{8}</td><td>^(?:\d{4}-)?\d{7,8})(?:-\d+)?$</td></tr><tr><td>手机IMEI码</td><td>^\d{15,17}$</td><td>一般是15位</td></tr><tr><td>邮编</td><td>^(?:0[1-7]</td><td>1[0-356]</td></tr><tr><td>统一社会信用代码</td><td>^[0-9A-HJ-NPQRTUWXY]{2}\d{6}[0-9A-HJ-NPQRTUWXY]{10}$</td><td></td></tr><tr><td>身份证号码(1代)</td><td>^[1-9]\d{7}(?:0\d</td><td>10</td></tr><tr><td>身份证号码(2代)</td><td>^[1-9]\d{5}(?:18</td><td>19</td></tr><tr><td>QQ号</td><td>^[1-9][0-9]{4,}$</td><td>一般是5到10位</td></tr><tr><td>微信号</td><td>^[a-zA-Z][-_a-zA-Z0-9]{5,19}$</td><td>一般6~20位，字母开头，可包含字母、数字、-、_，不含特殊字符</td></tr><tr><td>股票代码</td><td>^(s[hz]</td><td>S[HZ])(000[\d]{3}</td></tr><tr><td>银行卡卡号</td><td>^[1-9]{1}(?:\d{15}</td><td>\d{18})$</td></tr></tbody></table><h2 id="2-5-互联网相关"><a href="#2-5-互联网相关" class="headerlink" title="2.5 互联网相关"></a>2.5 互联网相关</h2><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>域名</td><td>^[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$</td><td>例如：r2coding.com</td></tr><tr><td>网址</td><td>^(?:https?://)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$</td><td>例如：<a href="https://www.r2coding.com/">https://www.r2coding.com/</a></td></tr><tr><td>带端口号的网址(或IP)</td><td>^(?:https?://)?[\w-]+(?:.[\w-]+)+:\d{1,5}/?$</td><td>例如：<a href="http://127.0.0.1:8888/">http://127.0.0.1:8888/</a></td></tr><tr><td>URL</td><td>^https?://(?:www.)?[-a-zA-Z0-9@:%._+<del>#&#x3D;]{1,256}.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()!@:%_+.</del>#?&amp;//&#x3D;]*)$</td><td>例如：<a href="https://www.r2coding.com/#/README?id=1">https://www.r2coding.com/#/README?id=1</a></td></tr><tr><td>邮箱email</td><td>^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$</td><td>支持中文，例如：<a href="mailto:&#99;&#x6f;&#100;&#x65;&#x73;&#x68;&#x65;&#x65;&#112;&#64;&#x63;&#115;&#x2e;&#99;&#x6f;&#109;">&#99;&#x6f;&#100;&#x65;&#x73;&#x68;&#x65;&#x65;&#112;&#64;&#x63;&#115;&#x2e;&#99;&#x6f;&#109;</a></td></tr><tr><td>用户名</td><td>^[a-zA-Z0-9_-]{4,20}$</td><td>4到20位</td></tr><tr><td>弱密码</td><td>^[\w]{6,16}$</td><td>6~16位，包含大小写字母和数字的组合</td></tr><tr><td>强密码</td><td>^.<em>(?&#x3D;.{6,})(?&#x3D;.<em>\d)(?&#x3D;.</em>[A-Z])(?&#x3D;.</em>[a-z])(?&#x3D;.<em>[!@.#$%^&amp;</em>? ]).*$</td><td>至少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符</td></tr><tr><td>端口号</td><td>^(?:[0-9]</td><td>[1-9][0-9]{1,3}</td></tr><tr><td>IPv4地址</td><td>^(?:(?:\d</td><td>[1-9]\d</td></tr><tr><td>IPv4地址+端口</td><td>^(?:(?:\d</td><td>[1-9]\d</td></tr><tr><td>IPv6地址</td><td>^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}</td><td>([0-9a-fA-F]{1,4}:){1,7}:</td></tr><tr><td>IPv6地址+端口</td><td>^[(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}</td><td>([0-9a-fA-F]{1,4}:){1,7}:</td></tr><tr><td>子网掩码</td><td>^(?:254</td><td>252</td></tr><tr><td>MAC地址</td><td>^(?:(?:[a-f0-9A-F]{2}:){5}</td><td>(?:[a-f0-9A-F]{2}-){5})[a-f0-9A-F]{2}$</td></tr><tr><td>Version版本号</td><td>^\d+(?:.\d+){2}$</td><td>例如：12.1.1</td></tr><tr><td>图片后缀</td><td>.(gif</td><td>png</td></tr><tr><td>视频后缀</td><td>.(swf</td><td>avi</td></tr><tr><td>图片链接</td><td>(?:https?://)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.+.(gif</td><td>png</td></tr><tr><td>视频链接</td><td>(?:https?://)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.+.(swf</td><td>avi</td></tr><tr><td>迅雷链接</td><td>thunderx?://[a-zA-Z\d]+&#x3D;</td><td></td></tr><tr><td>ed2k链接</td><td>ed2k://|file|.+|/</td><td></td></tr><tr><td>磁力链接</td><td>magnet:?xt&#x3D;urn:btih:[0-9a-fA-F]{40,}.*</td><td></td></tr></tbody></table><h2 id="2-6-其他"><a href="#2-6-其他" class="headerlink" title="2.6 其他"></a>2.6 其他</h2><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>Windows文件路径</td><td>^[a-zA-Z]:(?:\[\w\u4E00-\u9FA5\s]+)+[.\w\u4E00-\u9FA5\s]+$</td><td>例如：C:\Users\Administrator\Desktop\a.txt</td></tr><tr><td>Windows文件夹路径</td><td>^[a-zA-Z]:(?:\[\w\u4E00-\u9FA5\s]+)+$</td><td>例如：C:\Users\Administrator\Desktop</td></tr><tr><td>Linux文件路径</td><td>^/(?:[^&#x2F;]+/)*[^&#x2F;]+$</td><td>例如：&#x2F;root&#x2F;library&#x2F;a.txt</td></tr><tr><td>Linux文件夹路径</td><td>^/(?:[^&#x2F;]+/)*$</td><td>例如：&#x2F;root&#x2F;library&#x2F;</td></tr><tr><td>MD5格式</td><td>^(?:[a-f\d]{32}</td><td>[A-F\d]{32})$</td></tr><tr><td>BASE64格式</td><td>^\s<em>data:(?:[a-z]+/[a-z0-9-+.]+(?:;[a-z-]+&#x3D;[a-z0-9-]+)?)?(?:;base64)?,([a-z0-9!$&amp;’,()</em>+;&#x3D;-._~:@&#x2F;?%\s]<em>?)\s</em>$</td><td>例如：data:image&#x2F;jpeg;base64,xxxx&#x3D;&#x3D;</td></tr><tr><td>UUID</td><td>^[a-f\d]{4}(?:[a-f\d]{4}-){4}[a-f\d]{12}$</td><td>例如：94f9d45a-71b0-4b3c-b69d-20c4bc9c8fdd</td></tr><tr><td>16进制</td><td>^[A-Fa-f0-9]+$</td><td>例如：FFFFFF</td></tr><tr><td>16进制颜色</td><td>^#?([0-9a-fA-F]{3}</td><td>[0-9a-fA-F]{6})$</td></tr><tr><td>SQL语句</td><td>^(?:select</td><td>drop</td></tr><tr><td>Java包名</td><td>^(?:[a-zA-Z_]\w*)+(?:[.][a-zA-Z_]\w*)+$</td><td>例如：com.r2coding.controller</td></tr><tr><td>文件扩展名</td><td>.(?:doc</td><td>pdf</td></tr><tr><td>HTML标签</td><td>&lt;(\w+)[^&gt;]<em>&gt;(.</em>?&lt;/\1&gt;)?</td><td>例如：<div class="navigator"></div></td></tr><tr><td>HTML注释</td><td><!--(.*?)--></td><td>例如：<!--注释--></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>常用知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 命令</title>
    <link href="/git/"/>
    <url>/git/</url>
    
    <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1.创建版本库"></a>1.创建版本库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 克隆远程版本库</span><br>git <span class="hljs-built_in">clone</span> &lt;url&gt;<br><br><span class="hljs-comment"># 初始化本地版本库</span><br>git init<br></code></pre></td></tr></table></figure><h2 id="2-修改和提交"><a href="#2-修改和提交" class="headerlink" title="2.修改和提交"></a>2.修改和提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看状态</span><br>git status<br><br><span class="hljs-comment"># 查看变更内容</span><br>git diff<br><br><span class="hljs-comment"># 跟踪所有改动过的文件</span><br>git add .<br><br><span class="hljs-comment">#以列表方式查看指定文件的提交历史</span><br>git add &lt;file&gt;<br><br><span class="hljs-comment">#文件改名</span><br>git <span class="hljs-built_in">mv</span> &lt;old&gt; &lt;new&gt;<br><br><span class="hljs-comment">#删除文件</span><br>git <span class="hljs-built_in">rm</span> &lt;file&gt;<br><br><span class="hljs-comment">#停止跟踪文件但不删除</span><br>git <span class="hljs-built_in">rm</span> --cached &lt;file&gt;<br><br><span class="hljs-comment">#提交所有更新过的文件</span><br>git commit -m <span class="hljs-string">&quot;commit message&quot;</span><br><br><span class="hljs-comment">#修改最后一次提交</span><br>git commit --amend<br></code></pre></td></tr></table></figure><h2 id="3-查看提交历史"><a href="#3-查看提交历史" class="headerlink" title="3.查看提交历史"></a>3.查看提交历史</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看提交历史</span><br>git <span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># 查看指定文件的提交历史</span><br>git <span class="hljs-built_in">log</span> -p &lt;file&gt;<br><br><span class="hljs-comment"># 以列表方式查看指定文件的提交历史</span><br>git blame &lt;file&gt;<br></code></pre></td></tr></table></figure><h2 id="4-撤销"><a href="#4-撤销" class="headerlink" title="4.撤销"></a>4.撤销</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 撤消工作目录中所有未提交文件的修改内容</span><br>git reset --hard HEAD<br><br><span class="hljs-comment"># 撤消指定的未提交文件的改内容</span><br>git checkout HEAD &lt;file&gt;<br><br><span class="hljs-comment"># 撤消指定的提交</span><br>git revert &lt;commit&gt;<br></code></pre></td></tr></table></figure><h2 id="5-分支与标签"><a href="#5-分支与标签" class="headerlink" title="5.分支与标签"></a>5.分支与标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示所有本地分支</span><br>git branch<br><br><span class="hljs-comment"># 切换到指定分支或标签</span><br>git checkout &lt;branch/tag&gt;<br><br><span class="hljs-comment"># 创建新分支</span><br>git branch &lt;new-branch&gt;<br><br><span class="hljs-comment"># 删除本地分支</span><br>git branch -d &lt;branch&gt;<br><br><span class="hljs-comment"># 列出所有本地标签</span><br>git tag<br><br><span class="hljs-comment"># 基于最新提交创建标签</span><br>git tag &lt;tagname&gt;<br><br><span class="hljs-comment"># 删除标签</span><br>git tag -d &lt;tagname&gt;<br></code></pre></td></tr></table></figure><h2 id="6-合并与衍合"><a href="#6-合并与衍合" class="headerlink" title="6.合并与衍合"></a>6.合并与衍合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#合并指定分支到当前分支</span><br>git merge &lt;branch&gt;<br><br><span class="hljs-comment">#行合指定分支到当前分支</span><br>git rebase &lt;branch&gt;<br></code></pre></td></tr></table></figure><h2 id="7-远程操作"><a href="#7-远程操作" class="headerlink" title="7.远程操作"></a>7.远程操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看远程版本库信息</span><br>git remote -v<br><br><span class="hljs-comment"># 查看指定远程版本库信息</span><br>git remote show &lt;remote&gt;<br><br><span class="hljs-comment"># 添加远程版本库</span><br>git remote add &lt;remote&gt; &lt;url&gt;<br><br><span class="hljs-comment"># 从远程库获取代码</span><br>git fetch &lt;remote&gt;<br><br><span class="hljs-comment"># 下载代码及快速合并</span><br>git pull &lt;remote&gt; &lt;branch&gt;<br><br><span class="hljs-comment"># 上传代码及快速合并</span><br>git push &lt;remote&gt; &lt;branch&gt;<br><br><span class="hljs-comment"># 删除远程分支或标签</span><br>git push &lt;remote&gt;:&lt;branch/tag-name&gt;<br><br><span class="hljs-comment"># 上传所有标签</span><br>git push --tags<br></code></pre></td></tr></table></figure><h1 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h1><h2 id="1-修改历史全部的-commit"><a href="#1-修改历史全部的-commit" class="headerlink" title="1.修改历史全部的 commit"></a>1.修改历史全部的 commit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改最后一次提交</span><br>git commit --amend<br><br><span class="hljs-comment"># 修改最近几次的 commit（序号是倒序，但不包含第一条 commit）</span><br>git rebase -i HEAD~10<br><br><span class="hljs-comment"># 修改第一条 commit</span><br>git rebase -i --root<br></code></pre></td></tr></table></figure><h2 id="2-冲突合并"><a href="#2-冲突合并" class="headerlink" title="2.冲突合并"></a>2.冲突合并</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在解决合并冲突之前，我们应该设置 Git 使用的 diff 工具</span><br>git config merge.tool meld<br>git config merge.conflictstyle diff3<br>git config mergetool.prompt <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># 这将启动 meld</span><br>git mergetool<br></code></pre></td></tr></table></figure><hr><p><img src="/../img/post/git/git-1.jpg" alt="Git 常用命令速查表"></p>]]></content>
    
    
    <categories>
      
      <category>常用知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络 第九章：无线网络和移动网络</title>
    <link href="/computer-network-9/"/>
    <url>/computer-network-9/</url>
    
    <content type="html"><![CDATA[<h1 id="1-无线局域网-WLAN"><a href="#1-无线局域网-WLAN" class="headerlink" title="1.无线局域网 WLAN"></a>1.无线局域网 WLAN</h1><h2 id="1-1-无线局域网的组成"><a href="#1-1-无线局域网的组成" class="headerlink" title="1.1 无线局域网的组成"></a>1.1 无线局域网的组成</h2><p>无线局域网可分为两大类。第一类是有固定基础设施的，第二类是无固定基础设施的。所谓“固定基础设施”是指预先建立起来的、能够覆盖一定地理范围的一批固定基站。</p><h3 id="1-1-1-IEEE-802-11"><a href="#1-1-1-IEEE-802-11" class="headerlink" title="1.1.1 IEEE 802.11"></a>1.1.1 IEEE 802.11</h3><p>对于有固定基础设施的无线局域网，1997 年 IEEE 制定出无线局域网的协议标准 802.11 [W-IEEE802.11] 系列标准。</p><p>802.11 是个相当复杂的标准,但简单地说，802.11 就是无线以太网的标准，它使用星形拓扑，其中心叫做接入点 AP（Access Point），<strong>在 MAC 层使用 CSMA&#x2F;CA 协议</strong>。<strong>凡使用 802.11 系列协议的局域网又称为 Wi-Fi</strong>（Wireless-Fidelity，意思是“无线保真度”）。</p><blockquote><p>💡 请注意，现在 Wi-Fi 实际上已经成为了无线局域网 WLAN 的代名词，但无线局域网和“保真度”实在没有什么关系。</p></blockquote><p>802.11 标准规定无线局域网的最小构件是基本服务集 BSS（Basic Service Set）。一个基本服务集 BSS 包括<strong>一个基站</strong>和<strong>若干个移动站</strong>，<strong>所有的站在本 BSS 以内都可以直接通信</strong>，<strong>但在和本 BSS 以外的站通信时都必须通过本 BSS的基站</strong>。在 802.11 的术语中，上面提到的接入点 AP 就是基本服务集内的基站（base station）。当网络管理员安装 AP 时，必须为该 AP 分配一个<strong>不超过 32 字节的服务集标识符 SSID</strong>（Service Set IDentifier）和<strong>一个通信信道</strong>。SSID 其实就是指使用该 AP 的无线局域网的名字。</p><p>一个基本服务集 BSS 所覆盖的地理范围叫做一个基本服务区 BSA（Basic Service Area）。基本服务区 BSA 和无线移动通信的蜂窝小区相似。无线局域网的基本服务区  BSA 的范围直径一般不超过100米。</p><p>一个基本服务集可以是孤立的，也可通过接入点 AP 连接到一个分配系统 DS（Distribution System），然后再连接到另一个基本服务集，这样就构成了一个扩展的服务集 ESS（Extended Service Set）。</p><p><img src="/../img/post/computer-network/9-1.jpg"></p><h3 id="1-1-2-移动自组网络"><a href="#1-1-2-移动自组网络" class="headerlink" title="1.1.2 移动自组网络"></a>1.1.2 移动自组网络</h3><p>另一类无线局域网是无固定基础设施的无线局域网，它又叫做自组网络（ad hocnetwork）。这种自组网络没有上述基本服务集中的接入点 AP，而是由一些处于平等状态的移动站相互通信组成的临时网络。</p><p><img src="/../img/post/computer-network/9-2.jpg"></p><p>近年来，移动自组网络中的一个子集——<strong>无线传感器网络 WSN</strong>（Wireless Sensor Network）引起了人们广泛的关注。无线传感器网络是由大量传感器结点通过无线通信技术构成的自组网络。无线传感器网络的应用就是进行各种数据的采集、处理和传输，一般并不需要很高的带宽，但是在大部分时间必须保持低功耗，以节省电池的消耗。由于无线传感结点的存储容量受限，因此对协议栈的大小有严格的限制。此外，无线传感器网络还对网络安全性、结点自动配置、网络动态重组等方面有一定的要求。</p><p>无线传感器网络主要的应用领域就是组成各种物联网 IoT（Internet of Things）。<strong>下面是物联网的一些举例：</strong></p><ol><li>环境监测与保护（如洪水预报、动物栖息的监控）</li><li>战争中对敌情的侦查和对兵力、装备、物资等的监控</li><li>医疗中对病房的监测和对患者的护理;</li><li>在危险的工业环境（如矿井、核电站等）中的安全监测</li><li>城市交通管理、建筑内的温度&#x2F;照明&#x2F;安全控制等</li></ol><p>顺便指出，<strong>移动自组网络</strong>和<strong>移动 IP</strong> 并不相同。移动 IP 技术使漫游的主机可以用多种方式连接到互联网。漫游的主机可以直接连接到或通过无线链路连接到固定网络上的另一个子网。</p><p>最后需要弄清在文献中经常要遇到的、与接入有关的几个名词：</p><ul><li><strong>固定接入（fixed access）：</strong>在作为网络用户期间，用户设置的地理位置保持不变。</li><li><strong>移动接入（mobility access）：</strong>用户设备能够以车辆速度（一般取为每小时120公里）移动时进行网络通信。当发生切换（即用户移动到不同蜂窝小区）时，通信仍然是连续的。</li><li><strong>便携接入（portable access）：</strong>在受限的网络覆盖面积中，用户设备能够在以步行速度移动时进行网络通信，提供有限的切换能力。</li><li><strong>游牧接入（nomadic access）：</strong>用户设备的地理位置至少在进行网络通信时保持不变。如果用户设备移动了位置（改变了蜂窝小区），那么再次进行通信时可能还要寻找最佳的基站。</li></ul><h2 id="1-2-802-11-局域网的物理层"><a href="#1-2-802-11-局域网的物理层" class="headerlink" title="1.2 802.11 局域网的物理层"></a>1.2 802.11 局域网的物理层</h2><p>802.11 标准中物理层相当复杂，不展开讨论。根据物理层的不同（如工作频段、数据率、调制方法等），对应的标准也不同。最早流行的无线局域网是 802.11b，802.11a 和 802.11g。2009 年颁布了标准 802.11n。</p><p><img src="/../img/post/computer-network/9-3.jpg"></p><p>对于最常用的 802.11b 无线局域网，所工作的 2.4~2.485 GHz 频率范围中有 85 MHz 的带宽可用。802.11b 定义了 11 个部分重叠的信道集，但仅当两个信道由四个或更多信道隔开时它们才无重叠。<strong>其中，信道 1, 6 和 11 的集合是唯一的三个非重叠信道的集合。</strong>因此在同一个位置上可以设置三个 AP，并分别给它们分配信道 1, 6 和 11，然后用一个交换机把这三个 AP 连接起来，这样就可以构成一个最大传输速率为 33 Mbit&#x2F;s 的无线局域网。</p><h2 id="1-3-802-11-局域网的-MAC-层协议"><a href="#1-3-802-11-局域网的-MAC-层协议" class="headerlink" title="1.3 802.11 局域网的 MAC 层协议"></a>1.3 802.11 局域网的 MAC 层协议</h2><h3 id="1-3-1-CSMA-x2F-CA-协议"><a href="#1-3-1-CSMA-x2F-CA-协议" class="headerlink" title="1.3.1 CSMA&#x2F;CA 协议"></a>1.3.1 CSMA&#x2F;CA 协议</h3><p>虽然 CSMA&#x2F;CD 协议已<strong>成功地应用于使用有线连接的局域网，但无线局域网只能使用前一部分 CSMA 协议，“碰撞检测” CD 协议在无线环境下却不能使用。</strong>因为：</p><ol><li>“碰撞检测”要求一个站点在发送本站数据的同时，还必须不间断地检测信道。如要在无线局域网的适配器上实现碰撞检测，在硬件上的花费就会过大。</li><li>更重要的是，即使我们能够在硬件上实现无线局域网的碰撞检测功能，也<strong>仍然无法避免碰撞的发生</strong>。这就表明，无线局域网不需要进行碰撞检测。<ol><li><strong>隐蔽站问题：</strong>A 和 C 同时发送给 B 发生碰撞。</li><li><strong>暴露站问题：</strong>B 给 A 发，C 给 D 发，会相互干扰接收数据。</li></ol></li></ol><p><img src="/../img/post/computer-network/9-4.jpg"></p><p>为此，<strong>802.11 局域网使用 CSMA&#x2F;CA 协议</strong>（不是 CSMA&#x2F;CD）。CA 表示 Collision Avoidance，是碰撞避免的意思，或者说，协议的设计是要尽量减少碰撞发生的概率。</p><h3 id="1-3-2-802-11-的-MAC-层"><a href="#1-3-2-802-11-的-MAC-层" class="headerlink" title="1.3.2 802.11 的 MAC 层"></a>1.3.2 802.11 的 MAC 层</h3><p>802.11 标准设计了独特的 MAC 层。它通过协调功能（Coordination Function）来确定在基本服务集 BSS 中的移动站，在什么时间能发送数据或接收数据。<strong>202.11 的 MAC 层在物理层的上面，它包括两个子层：</strong></p><ol><li><strong>分布协调功能 DCF（Distributed Coordination Function）：</strong>DCF 不采用任何中心控制，而是在每一个结点使用 CSMA 机制的分布式接入算法，让各个站通过争用信道来获取发送权。因此 DCF 向上提供争用服务。802.11 协议规定，所有的实现都必须有 DCF 功能。</li><li>点协调功能 PCF（Point Coordination Function）：PCF 是选项，是用接入点 AP 集中控制整个 BSS 内的活动，因此自组网络就没有 PCF 子层。PCF 使用集中控制的接入算法，用类似于探询的方法把发送数据权轮流交给各个站，从而避免了碰撞的产生。</li></ol><p><img src="/../img/post/computer-network/9-5.jpg"></p><p>为了尽量避免碰撞，<strong>802.11 规定，所有的站在完成发送后，必须等待一段很短的时间继续监听）才能发送下一帧。</strong>这段时间通称为<strong>帧间间隔 IFS（InterFrame Space）。</strong>帧间间隔的长短取决于该站要发送的帧的类型。高优先级帧需要等待的时间较短，因此可优先获得发送权，但低优先级帧就必须等待较长的时间。若低优先级帧还没来得及发送而其他站的高优先级帧已发送到媒体，则媒体变为忙态，低优先级帧只能再推迟发送，这样就减少了发生碰撞的机会。至于各种帧间间隔的具体长度，则取决于所使用的物理层特性。</p><p><strong>下面解释最常用的两种帧间间隔的作用：</strong></p><p><img src="/../img/post/computer-network/9-6.jpg"></p><ol><li><strong>SIFS，即短（Short）帧间间隔，长度为 28 μs。</strong>SIFS 是最短的帧间间隔，用来分隔开属于一次对话的各帧。在这段时间内，一个站应当能够从发送方式切换到接收方式。使用 SIFS 的帧类型有：ACK 帧、CTS 帧、由过长的 MAC 帧分片后的数据帧，以及所有回答 AP 探询的帧和在 PCF  方式中接入点 AP 发送出的任何帧。</li><li><strong>DIFS，即分布协调功能帧间间隔，它比 SIFS 的帧间间隔要长得多，长度为 128 μs。</strong>在 DCF 方式中，DIFS 用来发送数据帧和管理帧。</li></ol><p>要发送数据的站先检测信道。在 802.11 标准中规定了在物理层的空中接口进行物理层的载波监听。通过收到的相对信号强度是否超过一定的门限数值就可判断是否有其他的移动站在信道上发送数据。当源站发送它的第一个 MAC 帧时，若检测到信道空闲，则在等待一段时间 DIFS 后就可发送。<strong>由此可见，802.11无线局域网采用的停止等待协议，是一种可靠传输协议。</strong></p><p>802.11 标准还采用了一种叫做<strong>虚拟载波监听（Virtual Carrier Sense）</strong>的机制，这就是让源站把它要占用信道的时间（包括目的站发回确认帧所需的时间）及时通知给所有其他站，以便使其他所有站在这一段时间都停止发送数据，这样就大大减少了碰撞的机会。</p><p>但在无线局域网 802.11 标准的 CSMA&#x2F;CA 协议中，因为没有像以太网那样的碰撞检测机制，所以，在信道从忙态转为空闲时，为了避免几个站同时发送数据（一旦发送就要把一帧发送完，不能中途停止），所有想发送数据的站就都要执行退避算法。这样做不仅大大减小了发生碰撞的概率，而且也避免了一个站连续发送长帧，垄断了整个的无线信道。</p><h3 id="1-3-3-退避算法"><a href="#1-3-3-退避算法" class="headerlink" title="1.3.3 退避算法"></a>1.3.3 退避算法</h3><p>当某个要发送数据的站，使用退避算法选择了争用窗口中的某个时隙后，就根据该时隙的位置设置一个<strong>退避计时器（backoff timer）</strong>。<strong>当退避计时器的时间减小到零时，就开始发送数据。</strong>也可能当退避计时器的时间还未减小到零时而信道又转变为忙态，这时就<strong>冻结退避计时器的数值，重新等待信道变为空闲</strong>，再经过时间 DIFS 后，继续启动退避计时器（从剩下的时间开始）。这种规定有利于继续启动退避计时器的站更早地接入到信道中。</p><p><img src="/../img/post/computer-network/9-7.jpg"></p><p>冻结退避计时器剩余时间的做法是为了使协议对所有站点更加公平。根据以上讨论的情况，可把 <strong>CSMA&#x2F;CA 算法归纳如下：</strong></p><ol><li><strong>若站点最初有数据要发送</strong>（而不是发送不成功再进行重传），<strong>且检测到信道空闲</strong>，<strong>在等待时间 DIFS 后，就发送整个数据帧</strong>。</li><li><strong>否则</strong>，站点执行 <strong>CSMA&#x2F;CA 协议的退避算法</strong>。一旦检测到信道忙，就冻结退避计时器。只要信道空闲，退避计时器就进行倒计时。</li><li>当<strong>退避计时器时间减少到零时</strong>（这时信道只可能是空闲的），站点就发送整个的帧并等待确认。</li></ol><p>若源站在规定时间内没有收到确认帧 ACK（由重传计时器控制这段时间），就必须重传此帧（再次使用 CSMA&#x2F;CA 协议争用接入信道），直到收到确认为止，或者经过若干次的重传失败后放弃发送。</p><p>应当指出，当一个站要发送数据帧时，仅在下面的情况下才<strong>“不使用”退避算法：检测到信道是空闲的，并且这个数据帧是它想发送的第一个数据帧。</strong></p><p>除此以外的所有情况，都<strong>必须使用退避算法</strong>：</p><ol><li>在发送第一个帧之前检测到信道处于忙态。</li><li>每一次的重传。</li><li>每一次的成功发送后再要发送下一帧。</li></ol><h3 id="1-3-4-对信道进行预约"><a href="#1-3-4-对信道进行预约" class="headerlink" title="1.3.4 对信道进行预约"></a>1.3.4 对信道进行预约</h3><p>为了更好地解决隐蔽站带来的碰撞问题，802.11 允许要发送数据的站对信道进行预约。</p><p>A 发送 B 之前，先发送一个短的控制帧，叫请求发送 RTS，包括源地址、目的地址和本帧的持续时间。虽然协议经过了精心设计，但碰撞仍然会发生。有两个站同时向同一个目的站发送 RTS 帧。这<strong>两个 RTS 帧发生碰撞后，使得目的站收不到正确的 RTS 帧</strong>，因而目的站就不会发送后续的 CTS 帧。这时，原先发送 RTS 帧的两个站就各自随机地推迟一段时间后再重新发送其 RTS 帧。<strong>推迟时间的算法也是使用二进制指数退避。</strong></p><p><img src="/../img/post/computer-network/9-8.jpg"></p><h2 id="1-4-802-11-局域网的-MAC-帧"><a href="#1-4-802-11-局域网的-MAC-帧" class="headerlink" title="1.4 802.11 局域网的 MAC 帧"></a>1.4 802.11 局域网的 MAC 帧</h2><p>802.11 帧共有三种类型，即<strong>控制帧</strong>、<strong>数据帧</strong>和<strong>管理帧</strong>。802.11 <strong>数据帧</strong>由以下三大部分组成：</p><p><img src="/../img/post/computer-network/9-9.jpg"></p><ol><li><strong>MAC首部：</strong>共 30 字节。帧的复杂性都在帧的 MAC 首部。</li><li><strong>帧主体：</strong>也就是帧的数据部分，不超过 2312 字节。这个数值比以太网的最大长度长很多。不过 802.11 帧的长度通常都小于 1500 字节。</li><li><strong>帧检验序列 FCS：</strong>MAC 尾部，共 4 字节。</li></ol><h3 id="1-4-1-关于-802-11-数据帧的地址"><a href="#1-4-1-关于-802-11-数据帧的地址" class="headerlink" title="1.4.1 关于 802.11 数据帧的地址"></a>1.4.1 关于 802.11 数据帧的地址</h3><p>802.11 数据帧最特殊的地方就是有四个地址字段。地址 4 用于自组网络。前三种地址的内容取决于帧控制字段中的“去往 AP”（发送到接入点）和“来自 AP”（从接入点发出）这两个子字段的数值。</p><p><img src="/../img/post/computer-network/9-10.jpg"></p><h3 id="1-4-2-序号控制字段、持续期字段和帧控制字段"><a href="#1-4-2-序号控制字段、持续期字段和帧控制字段" class="headerlink" title="1.4.2 序号控制字段、持续期字段和帧控制字段"></a>1.4.2 序号控制字段、持续期字段和帧控制字段</h3><p>下面有选择地介绍 <strong>802.11 数据帧中的其他一些字段：</strong></p><ol><li><strong>序号控制字段：</strong>占 16 位，其中序号子字段占 12 位（从 0 开始，每发送一个新帧就加1 ，到 4095 后再回到 0），分片子字段占 4 位（不分片则保持为0。如分片，则帧的序号子字段保持不变，而分片子字段从 0 开始，每个分片加 1，最多到 15）。重传的帧的序号和分片子字段的值都不变。序号控制的作用是使接收方能够区分开是新传送的帧还是因出现差错而重传的帧。</li><li><strong>持续期字段：</strong>占 16 位。CSMA&#x2F;CA 协议允许发送数据的站点预约信道一段时间并把这个时间写入到持续期字段中。</li><li><strong>帧控制字段：</strong>共分为 11 个子字段。下面介绍其中较为重要的几个。<ol><li><strong>更多分片字段：</strong>置为 1 时表明这个帧属于一个帧的多个分片之一。</li><li><strong>有线等效保密字段 WEP（Wired Equivalent Privacy）：</strong>占 1 位。若 WEP &#x3D;1，就表明采用了 WEP 加密算法。</li></ol></li></ol><h1 id="2-无线个人区域网-WPAN"><a href="#2-无线个人区域网-WPAN" class="headerlink" title="2.无线个人区域网 WPAN"></a>2.无线个人区域网 WPAN</h1><p>无线个人区域网 WPAN（Wireless Personal Area Network）就是在个人工作地方把属于个人使用的电子设备（如便携式电脑、平板电脑、便携式打印机以及蜂窝电话等）<strong>用无线技术连接起来自组网络，不需要使用接入点 AP</strong>，整个网络的范围约为10 m。</p><p>WPAN 和无线局域网 WLAN 并不一样。<strong>WPAN 是以个人为中心来使用的无线个人区域网</strong>，它实际上就是一个<strong>低功率</strong>、<strong>小范围</strong>、<strong>低速率</strong>和<strong>低价格</strong>的电缆替代技术。但 <strong>WLAN 却是同时为许多用户服务的无线局域网</strong>，它是一个<strong>大功率</strong>、<strong>中等范围</strong>、<strong>高速率</strong>的局域网。</p><h2 id="2-1-蓝牙系统"><a href="#2-1-蓝牙系统" class="headerlink" title="2.1 蓝牙系统"></a>2.1 蓝牙系统</h2><p>最早使用的 WPAN 是 1994 年爱立信公司推出的蓝牙（Bluetooth）系统，其标准是IEEE802.15.1 [W-BLUE]。蓝牙的数据率为 720 kbit&#x2F;s，通信范围在 10 米左右。</p><p>蓝牙使用 TDM 方式和跳频扩频 FHSS 技术组成不用基站的皮可网（piconet）。Piconet直译就是“微微网”，因为前缀  <code>pico-</code> 本来是微微的意思，表示这种无线网络的覆盖面积非常小。<strong>每一个皮可网有一个主设备（Master）和最多 7 个工作的从设备（Slave）</strong>。通过共享主设备或从设备，可以把多个皮可网链接起来，形成一个范围更大的扩散网（scatternet）。</p><h2 id="2-2-低速-WPAN"><a href="#2-2-低速-WPAN" class="headerlink" title="2.2 低速 WPAN"></a>2.2 低速 WPAN</h2><p>低速 WPAN 主要用于工业监控组网、办公自动化与控制等领域，其速率是 2~250kbit&#x2F;s。低速 WPAN 的标准是 IEEE 802.15.4。在低速 WPAN 中最重要的就是 ZigBee。ZigBee 名字来源于蜂群使用的赖以生存和发展的通信方式。</p><p><strong>ZigBee 的特点是：</strong></p><ol><li>功耗非常低。</li><li>网络容量大：一个 ZigBee 的网络最多包括有255个结点。</li><li>通信距离短：10~80 米。</li><li>传输数据率低。</li><li>成本低廉。</li></ol><p>ZigBee 标准是在 IEEE 802.15.4 标准基础上发展而来的。因此，所有 ZigBee 产品也是 802.15.4 产品。</p><p><img src="/../img/post/computer-network/9-11.jpg"></p><p>在 MAC 层，主要沿用 802.11 无线局域网标准的 <strong>CSMA&#x2F;CA 协议</strong>。在网络层，ZigBee 可采用<strong>星形</strong>和<strong>网状拓扑</strong>，或两者的组合。</p><h2 id="2-2-高速-WPAN"><a href="#2-2-高速-WPAN" class="headerlink" title="2.2 高速 WPAN"></a>2.2 高速 WPAN</h2><p>高速 WPAN 的标准是 IEEE 802.15.3，是专为在便携式多媒体装置之间传送数据而制定的。这个标准支持 11 ~55 Mbit&#x2F;s 的数据率。这在个人使用的数码设备日益增多的情况下特别方便，可以不用连接线就能把计算机和在同一间屋子里的打印机、扫描仪、外接硬盘，以及各种消费电子设备连接起来。</p><h1 id="3-无线城域网-WMAN"><a href="#3-无线城域网-WMAN" class="headerlink" title="3.无线城域网 WMAN"></a>3.无线城域网 WMAN</h1><p>WiMAX 论坛则是 802.16 技术的推动者。<strong>两个标准：</strong></p><ul><li><strong>802.16d</strong>（2004 年 6 月）</li><li><strong>802.16e</strong>（2005 年 12 月）</li></ul><p><img src="/../img/post/computer-network/9-12.jpg"></p><h1 id="4-蜂窝移动通信网"><a href="#4-蜂窝移动通信网" class="headerlink" title="4.蜂窝移动通信网"></a>4.蜂窝移动通信网</h1><h2 id="4-1-蜂窝无线通信技术简介"><a href="#4-1-蜂窝无线通信技术简介" class="headerlink" title="4.1 蜂窝无线通信技术简介"></a>4.1 蜂窝无线通信技术简介</h2><p>移动通信的种类很多，如蜂窝移动通信、卫星移动通信、集群移动通信、无绳电话通信等，但目前使用最多的是蜂窝移动通信，它又称为小区制移动通信。这种通信的特点是把整个的网络服务区划分成许多小区（cell，也就是“蜂窝”），每个小区设置一个基站，负责本小区各个移动站的联络与控制。移动站的发送或接收都必须经过基站完成。</p><ol><li><strong>第一代蜂窝移动通信</strong>（1G，这里的 G 是 Generation 的缩写）是为话音通信设计的模拟 FDM 系统。1G 的蜂窝无线网络早己淘汰了。</li><li><strong>第二代蜂窝移动通信</strong>（2G）的代表性体制就是最流行的 GSM 系统。这个系统使用的带宽只有 200 kHz，因此除了基本的话音通信，它只能提供低速数字通信（短信服务）。为了能够提供接入到互联网的服务，2G 蜂窝移动通信系统增加了如 GPRS和 EDGER 等技术。也有人称 GPRS 为 2.5G，而 EDGE 为2.75G，表明它们还属于2G，但比 2G 要强些，并且是从 2G 向第三代（3G）过渡的衔接性技术。</li><li><strong>第三代蜂窝移动通信</strong>（3G）使用的带宽增大到 5 MHz，并且使用 IP 的体系结构和混合的交换机制（电路交换和分组交换），能够提供移动宽带多媒体业务（话音、数据、视频等，可收发电子邮件，浏览网页，进行视频会议等）。3G 现有三个无线接口国际标准，即美国提出的 CDMA2000 （中国电信使用），欧洲提出的  WCDMA（中国联通使用）和中国提出的 TD-SCDMA（中国移动使用）。</li><li><strong>第四代蜂窝移动通信</strong>（4G）的目标峰值数据率是:固定的和低速移动通信时应达到 1Gbit&#x2F;s，在高速移动通信时（如在火车。汽车上）应达到100 Mbit&#x2F;s。由此可见，目前全世界所有声称是 4G 的蜂窝无线网络，其实都远未达到真正的 4G 标准。</li><li><strong>第五代蜂窝移动通信</strong>（5G）</li></ol><h2 id="4-2-移动-IP"><a href="#4-2-移动-IP" class="headerlink" title="4.2 移动 IP"></a>4.2 移动 IP</h2><p>移动 IP（Mobile IP）又称为移动 IP 协议 [RFC 5944，建议标准]，是由 IETF 开发的一种技术，<strong>这种技术允许计算机移动到外地时，仍然保留其原来的IP地址。</strong>移动IP对现在流行的在移动中上网有着重要的意义。</p><p>移动 IP 要解决的问题，就是要使用户的移动性对上层的网络应用是透明的。或者更加具体些说，就是若一个移动站在漫游时仍保持其 IP 地址不变，就要想办法使已建立的 TCP 连接与移动用户的漫游无关。此外，还要想办法让互联网中的其他主机能够找到这个移动站。</p><p>显然这必须使用一些特殊的方法。<strong>下面就简单介绍一下移动 IP 的要点：</strong></p><p>移动 IP 使用了一种方法。首先，一个移动站 A 必须有一个<strong>原始地址</strong>（相当于家庭地址），即<strong>永久地址</strong>，或<strong>归属地址</strong>（home address）。移动站原始连接到的网络叫做归属网络（home network）。<strong>永久地址和归属网络的关联是不会改变的。</strong></p><p><img src="/../img/post/computer-network/9-13.jpg"></p><p>为了让地址的改变对互联网的其余部分是透明的，移动 IP 使用了代理。归属代理（homeagent）通常就是连接在归属网络上的路由器，然而它作为代理的特定功能则是在应用层完成的。因此，<strong>归属代理既是路由器，也是主机。</strong></p><p>当移动站 A 移动到另一个地点，它所接入的网络称为<strong>被访网络</strong>（visited network）或<strong>外地网络</strong>（foreign network）。被访网络中使用的代理叫做<strong>外地代理</strong>（foreign agent），它通常就是连接在被访网络上的路由器（当然也充当主机）。</p><p>请注意两点：<strong>第一，转交地址是供移动站、归属代理以及外地代理使用的，各种应用程序都不使用这种转交地址</strong>；第二，转交地址在互联网中并不具有唯一性。这就是说，外地代理可以给好几个移动站指派同样的转交地址，甚至把自己的 IP 地址指派为移动站的转交地址。这样做并不会引起混乱。这是因为当外地代理要向连接在被访网络上的移动站发送数据报时，并不会像通常那样使用地址解析协议 ARP，而是<strong>直接使用这个移动站的 MAC 地址</strong>。</p><p><strong>为了支持移动性，在网络层应当增加以下的一些新功能：</strong></p><ol><li><strong>移动站到外地代理的协议：</strong>当移动站接入到被访网络时，必须向外地代理进行登记，以获得一个临时的转交地址。同样地，当移动站离开该被访网络时，它要向这个被访网络注销其原来的登记。</li><li><strong>外地代理到归属代理的登记协议：</strong>外地代理要向移动站的归属代理登记移动站的转交地址。当移动站离开被访网络时，外地代理并不需要注销其在归属代理登记的转交地址。这是因为当移动站接入到另一个网络时，这个新的被访网络的外地代理就会到移动站的归属代理登记该移动站现在的转交地址，这样就取代了原来旧的转交地址。</li><li><strong>归属代理数据报封装协议：</strong>归属代理收到发送给移动站的数据报后，将其再封装为一个新的数据报，其目的地址为移动站的转交地址，然后转发。</li><li><strong>外地代理拆封协议：</strong>外地代理收到归属代理封装好的数据报后，取出原始数据报，并将此数据报发送给移动站。</li></ol><p>如图 9-18 所示的这种间接路由选择，可能会引起数据报转发的低效，文献中称之为<strong>三角形路由选择问题（triangle routing problem），</strong>意思是，本来在 B 和 A 之间可能有一条更有效的路由，但现在要走另外两条路：先要把数据报从 B 发送到 A 的归属代理，然后再转发给漫游到被访网络的 A，既浪费了时间，也增加了网上不必要的通信量。<strong>解决这个问题的一种方法是使用直接路由选择，但这是以增加复杂性为代价的。</strong></p><p>方法就是让通信者 B 创建一个通信者代理（correspondent agent），让这个通信者代理向归属代理询问到移动站在被访网络的转交地址，然后由通信者代理（而不是由归属代理）把数据报用隧道技术发送到被访网络的外地代理，最后再由这个外地代理拆封，把数据报转发给移动站。<strong>使用这种方法时必须解决以下两个问题：</strong></p><ol><li>增加一个协议，即<strong>移动用户定位协议（mobile-user location protocol）</strong>，用来使通信者代理向移动站的归属代理查询移动站的转交地址。</li><li>当移动站再移动到其他网络时，怎样得到移动站的位置信息？</li></ol><p><img src="/../img/post/computer-network/9-14.jpg"></p><ol><li>B 的通信者代理从移动站 A 的归属代理得到 A 所漫游到的被访网络 N1 的外地代理。我们把移动站<strong>首次漫游到的被访网络的外地代理称为锚外地代理（anchorforeign agent）。</strong></li><li>通信者代理把 B 发给 A 的数据报再封装后，发送到 A 的锚外地代理。</li><li>锚外地代理把拆封后的数据报发送给 A。</li><li>A移动到另一个被访网络 N2。</li><li>A 向被访网络 N2 的新外地代理登记。</li><li>新外地代理把 A 的新转交地址告诉锚外地代理。</li><li>当锚外地代理收到发给 A 的封装数据报后，就用A的新转交地址对数据报进行再封装，然后发送给被访网络 N2 上的新外地代理。在拆封后转发给移动站 A。</li></ol><p>同理，如果移动站再漫游到另一个网络，则这个网络的外地代理将仍然要和锚外地代理联系，以便让锚外地代理以后把发给 A 的数据报转发过来。</p><h2 id="4-3-蜂窝移动通信网中对移动用户的路由选择"><a href="#4-3-蜂窝移动通信网中对移动用户的路由选择" class="headerlink" title="4.3 蜂窝移动通信网中对移动用户的路由选择"></a>4.3 蜂窝移动通信网中对移动用户的路由选择</h2><p>移动交换中心 MSC 是蜂窝移动通信网中的核心构件。其实 MSC 还要维护两个非常重要的数据库，即归属位置寄存器 HLR（Home Location Register）和来访用户位置寄存器VLR（Visitor Location Register）。</p><ul><li><strong>HLR：</strong>存档签约用户的所有数据信息。</li><li><strong>VLR：</strong>临时存档着当前漫游到这个 MSC 控制区的用户位置信息。</li></ul><p><img src="/../img/post/computer-network/9-15.jpg"></p><p><strong>呼叫过程中的三个重要步骤：</strong></p><ol><li>找到移动用户的归属网络。通信者（固定电话用户）首先拨移动用户的电话号码。从这个电话号码很容易找到了移动用户电话的归属网络。</li><li>归属 MSC 向其 HLR 查询现在被叫移动用户的位置。</li><li>归属 MSC 按照所得到的漫游号码 MSRN 进行呼叫的第二段，把通信者发起的呼叫从归属 MSC 传送到被访网络的 MSC，再传送到该移动用户所漫游到的小区的基站。于是，整个的呼叫就完成了。</li></ol><p>可以看出，数据库 HLR 和 VLR 都必须具有很高的可靠性和可用性，并且查询响应时间必须非常短，否则就不能使电话的接通时间让用户满意。</p><h2 id="4-4-GSM-中的切换"><a href="#4-4-GSM-中的切换" class="headerlink" title="4.4 GSM 中的切换"></a>4.4 GSM 中的切换</h2><p>移动用户在进行通信时总是处在某一个基站的服务小区内。当移动用户进入到地理上相邻的另一个小区时，他就与该小区的基站相关联。所谓切换（handover）就是移动用户与相关联的基站发生了改变。</p><p><strong>切换使得呼叫的传输路由发生变化。切换发生的原因是：</strong></p><ol><li>当前的基站和移动用户之间的信号减弱，有使呼叫中断的可能；</li><li>一个蜂窝小区内的呼叫太多，基站不堪重负。</li></ol><p>移动站的切换可能仍处在同一个 MSC 的控制下，只是相关联的基站发生了变化。但在许多情况下，移动站的切换是相关联的 MSC 都改变了。在这种情况下，向移动站的呼叫路由会有很大的变化。</p><p>GSM 使用了锚 MSC 的概念。锚 MSC 是在呼叫移动用户首次访问过的 MSC，它在整个呼叫持续过程中保持不变。在整个呼叫持续期间，不管到移动用户相关联的基站怎样变化，整个呼叫路由的前面一段，即从归属 MSC 到锚 MSC 这一段，是始终不改变的。</p><p><img src="/../img/post/computer-network/9-16.jpg"></p><h2 id="4-5-无线网络对高层协议的影响"><a href="#4-5-无线网络对高层协议的影响" class="headerlink" title="4.5 无线网络对高层协议的影响"></a>4.5 无线网络对高层协议的影响</h2><ol><li>在移动用户的情况下，TCP 报文段的丢失，即可能是由于移动用户切换引起的，也可能是网络发生了拥塞</li><li>由于移动用户更新相关关联的基站需要一定的时间，这就可能造成 TCP 报文段的丢失，但 TCP 并不知道出现在出现的分组丢失的确切原因。只要出现 TCP 频繁丢失，TCP 的拥塞控制就会采取措施，减小其拥塞窗口，从而使 TCP 发送方的报文段发送速率大大降低。</li></ol><p><strong>可以使用三种方法来处理这个问题：</strong></p><ol><li><strong>本地恢复：</strong>这是指差错在什么地方出现，就在什么地方改正。例如，在无线局域网中使用的自动请求重传 ARQ 协议就属于本地恢复措施。</li><li><strong>让 TCP 发送方知道什么地方使用了无线链路：</strong>只有当 TCP 能够确知，是<strong>有线网络部分发生了拥塞时，TCP 才采用拥塞控制的策略。</strong>然而要能够区分是在有线网段还是无线网段出现报文段丢失，则还需要一些特殊的技术。</li><li>把含有移动用户的端到端 TCP 连接拆成两个互相串接的 TCP 连接。从移动用户到无线接入点是一个 TCP 连接（这部分使用无线信道），而剩下的使用有线网段连接的部分则是另一个 TCP 连接（我们假定 TCP 连接的另一端是有线主机）。</li></ol><h1 id="5-两种不同的无线上网"><a href="#5-两种不同的无线上网" class="headerlink" title="5.两种不同的无线上网"></a>5.两种不同的无线上网</h1><p><strong>有两种不同的无线上网：</strong></p><ol><li>蜂窝移动网路（运营商 ISP 收费）</li><li>宽带加入一个无线路由器</li></ol><p>公共场所热点免费 Wi-Fi 的安全性并不好。有不少酒店提供的 Wi-Fi 是收费的，且价格不菲。</p><p>回顾已经介绍过的各种无线网络，可以看出，这些网络各有优缺点，也都有各自最适宜的使用环境。</p><p><img src="/../img/post/computer-network/9-17.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络 第八章：互联网上音视频服务</title>
    <link href="/computer-network-8/"/>
    <url>/computer-network-8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p><strong>多媒体信息最主要的两个特点：</strong></p><ol><li>多媒体信息的信息量往往很大。</li><li>在传输多媒体数据时，对时延和时延抖动均有较高的要求。</li></ol><p><strong>互联网提供的音频&#x2F;视频服务大体上可分为三种类型：</strong></p><ol><li>流式（streaming）存储音频&#x2F;视频</li><li>流式实况音频&#x2F;视频</li><li>交互式音频&#x2F;视频</li></ol><h1 id="2-流式存储音频-x2F-视频"><a href="#2-流式存储音频-x2F-视频" class="headerlink" title="2.流式存储音频&#x2F;视频"></a>2.流式存储音频&#x2F;视频</h1><p>“流式存储音频&#x2F;视频”中的<strong>“存储”</strong>二字，表明这里所讨论的流式音频&#x2F;视频文件不是实时产生的，而是已经录制好的，通常存储在光盘或硬盘中。</p><p><img src="/../img/post/computer-network/8-1.jpg"></p><ol><li>用户从客户机（client machine）的浏览器上用 HTTP 协议向服务器请求下载某个音频&#x2F;视频文件，GET 表示请求下载的 HTTP 报文。请注意，HTTP 使用 TCP 连接。</li><li>服务器如有此文件就发送给浏览器，RESPONSE 表示服务器的 HTTP 响应报文。在响应报文中装有用户所要的音频&#x2F;视频文件。整个下载过程可能会<strong>花费很长的时间</strong>。</li><li>当浏览器<strong>完全收下</strong>这个文件后（所需的时间取决于音频&#x2F;视频文件的大小），就可以传送给自己机器上的媒体播放器进行解压缩，然后播放。</li></ol><p>为什么不能直接在浏览器中播放音频&#x2F;视频文件呢？这是因为播放器并没有集成在万维网浏览器中。因此，必须使用一个单独的应用程序来播放这种音频&#x2F;视频节目。</p><h2 id="2-1-具有元文件的万维网服务器"><a href="#2-1-具有元文件的万维网服务器" class="headerlink" title="2.1 具有元文件的万维网服务器"></a>2.1 具有元文件的万维网服务器</h2><p>第一种改进的措施就是在万维网服务器中，除了真正的音频&#x2F;视频文件外，还增加了一个元文件（metafile）。所谓元文件（请注意，不是源文件）就是一种非常小的文件，它描述或指明其他文件的一些重要信息。这里的元文件保存了有关这个音频&#x2F;视频文件的信息使用元文件下载音频&#x2F;视频文件的几个步骤：</p><p><img src="/../img/post/computer-network/8-2.jpg"></p><ol><li>浏览器用户点击所要看的音频&#x2F;视频文件的超链，使用 HTTP 的 GET 报文接入到万维网服务器。<strong>实际上，这个超链并没有直接指向所请求的音频&#x2F;视频文件，而是指向一个元文件。</strong>这个元文件有实际的音频&#x2F;视频文件的统一资源定位符URL。</li><li>万维网服务器把该元文件装入 HTTP 响应报文的主体，发回给浏览器。在响应报文中还有指明该音频&#x2F;视频文件类型的首部。</li><li>客户机浏览器收到万维网服务器的响应，分析其内容类型首部行，调用相关的媒体播放器（客户机中可能装有多个媒体播放器），把提取出的元文件传送给媒体播放器。</li><li>媒体播放器使用元文件中的 URL 直接和万维网服务器<strong>建立 TCP 连接</strong>，并向万维网服务器发送 HTTP 请求报文，要求下载浏览器想要的音频&#x2F;视频文件。</li><li>万维网服务器发送 HTTP 响应报文，把该音频&#x2F;视频文件发送给媒体播放器。媒体播放器在存储了若干秒的音频&#x2F;视频文件后（这是为了消除抖动），就以音频&#x2F;视频流的形式边下载、边解压缩、边播放。</li></ol><h2 id="2-2-媒体服务器"><a href="#2-2-媒体服务器" class="headerlink" title="2.2 媒体服务器"></a>2.2 媒体服务器</h2><p>为了更好地提供播放流式音频&#x2F;视频文件的服务，现在最为流行的做法就是<strong>使用两个分开的服务器</strong>，一个普通的万维网服务器，和另一个媒体播放器（media server）。</p><p>媒体服务器和万维网服务器可以运行在一个端系统内，也可以运行在两个不同的端系统中。媒体服务器与普通的万维网服务器的最大区别就是，媒体服务器是专门为播放流式音频&#x2F;视频文件而设计的，因此能够更加有效地为用户提供播放流式多媒体文件的服务。因此媒体服务器也常被称为流式服务器（streaming server）。</p><p><img src="/../img/post/computer-network/8-3.jpg"></p><p>采用媒体服务器后，下载音频&#x2F;视频文件的前三个步骤仍然和上一节所述的一样，<strong>区别就是后面两个步骤：</strong></p><ul><li>媒体播放器使用元文件中的 URL 接入到媒体服务器，请求下载浏览器所请求的音频&#x2F;视频文件。下载文件可以使用 HTTP&#x2F;TCP，也可以借助 UDP 等任何协议，例如使用实时运输协议 RTP。</li><li>媒体服务器给出响应，把该音频&#x2F;视频文件发送给媒体播放器。媒体播放器在迟延了若干秒后（例如，2~5秒），以流的形式边下载、边解压缩、边播放。</li></ul><p>上面提到，传送音频&#x2F;视频文件可以使用 TCP，也可以使用UDP。<strong>起初人们选用 UDP 来传送。不采用 TCP 的主要原因是担心当网络出现分组丢失时，TCP 的重传机制会使重传的分组不能按时到达接收端</strong>，使得媒体播放器的播放不流畅。<strong>但后来的实践经验发现，采用 UDP 会有以下几个缺点：</strong></p><ol><li>发送端按正常播放的速率发送流媒体数据帧，但由于网络的情况多变，在接收端的播放器很难做到始终按规定的速率播放。</li><li>很多单位的<strong>防火墙往往阻拦外部 UDP 分组的进入</strong>。</li><li>使用 UDP 传送流式多媒体文件时，如果在用户端希望能够控制媒体的播放，如进行暂停、快进等操作，那么还需要使用另外的协议 RTP  和 RTSP 。这样就增加了成本和复杂性。</li></ol><p>于是，现在对流式存储音频&#x2F;视频的播放，如Y ouTube 和 Netflix，都采用 TCP 来传送。<strong>使用 TCP 传送流式视频的几个主要步骤：</strong></p><p><img src="/../img/post/computer-network/8-4.jpg"></p><ol><li>用户使用 HTTP 获取存储在万维网服务器中的视频文件，然后把视频数据传送到 TCP 发送缓存中。若发送缓存已填满，就暂时停止传送。</li><li>从 TCP 发送缓存通过互联网向客户机中的 TCP 接收缓存传送视频数据，直到接收缓存被填满。</li><li>从 TCP 接收缓存把视频数据再传送到应用程序缓存（即媒体播放器的缓存)。当这个缓存中的视频数据存储到一定程度时，就开始播放。</li><li>在播放时，媒体播放器等时地（即周期性地）把视频数据按帧读出，经解压缩后，把视频节目显示在用户的屏幕上。</li></ol><p>这里要指出，如果是观看实况转播，那么最好应当首先考虑使用 UDP 来传送。如果使用 TCP 传送，则当出现网络严重拥塞而产生播放的暂停时，就会使人难于接受。使用UDP传送时，即使因网络拥塞丢失了一些分组，对观看的感觉也会比突然出现暂停要好些。</p><h2 id="2-3-实时流式协议-RTSP"><a href="#2-3-实时流式协议-RTSP" class="headerlink" title="2.3 实时流式协议 RTSP"></a>2.3 实时流式协议 RTSP</h2><p>RTSP 是为了给流式过程增加更多的功能而设计的协议。<strong>RTSP 本身并不传送数据，而仅仅是使媒体播放器能够控制多媒体流的传送</strong>（有点像文件传送协议 FTP 有一个控制信道），因此 RTSP 又称为带外协议。</p><p><img src="/../img/post/computer-network/8-5.jpg"></p><ol><li>浏览器使用 HTTP 的 GET 报文向万维网服务器请求音频&#x2F;视频文件。</li><li>万维网服务器从浏览器发送携带有元文件的响应。</li><li>浏览器把收到的元文件传送给媒体播放器。</li><li>媒体播放器的 RTSP 客户发送 SETUP 报文与媒体服务器的 RTSP 服务器建立连接</li><li>媒体服务器的 RTSP 服务器发送响应 RESPONSE 报文。</li><li>媒体播放器的 RTSP 客户发送 PLAY 报文开始下载音频&#x2F;视频文件（即开始播放）</li><li>媒体服务器的 RTSP 服务器发送响应 RESPONSE 报文。</li></ol><p>此后，音频&#x2F;视频文件被下载，<strong>所用的协议是运行在 UDP 上的</strong>。可以是后面要介绍的 RTP，也可以是其他专用的协议。在音频&#x2F;视频流播放的过程中，媒体播放器可以随时暂停（利用PAUSE 报文）和继续播放（利用PLAY报文)，也可以快进或快退。</p><ol><li>用户在不想继续观看时，可以由RTSP客户发送TEARDOWN报文断开连接。</li><li>媒体服务器的RTSP服务器发送响应RESPONSE报文。</li></ol><p>请注意，<strong>以上编号的步骤 1~7 至都使用实时流协议 RTSP</strong>。<strong>步骤 8~9 “音频&#x2F;视频流”则使用另外的传送音频&#x2F;视频数据的协议，如 RTP</strong>。</p><h1 id="3-交互式音频-x2F-视频"><a href="#3-交互式音频-x2F-视频" class="headerlink" title="3.交互式音频&#x2F;视频"></a>3.交互式音频&#x2F;视频</h1><h2 id="3-1-IP-电话概述"><a href="#3-1-IP-电话概述" class="headerlink" title="3.1 IP 电话概述"></a>3.1 IP 电话概述</h2><h3 id="3-1-1-狭义的和广义的-IP-电话"><a href="#3-1-1-狭义的和广义的-IP-电话" class="headerlink" title="3.1.1 狭义的和广义的 IP 电话"></a>3.1.1 狭义的和广义的 IP 电话</h3><p><strong>狭义的 IP 电话</strong>就是指在 IP 网络上打电话。所谓“IP网络”就是“使用 IP 协议的分组交换网”的简称。这里的网络可以是互联网，也可以是包含有传统的电路交换网的互联网，不过在互联网中至少要有一个 IP 网络。</p><p><strong>广义的 IP 电话</strong>则不仅仅是电话通信，而且还可以是在IP网络上进行交互式多媒体实时通信（包括话音、视像等），甚至还包括即时传信 IM（Instant Messaging）。</p><h3 id="3-1-2-IP-电话网关"><a href="#3-1-2-IP-电话网关" class="headerlink" title="3.1.2 IP 电话网关"></a>3.1.2 IP 电话网关</h3><p>IP 电话网关（IP Telephony Gateway），它是<strong>公用电话网与 IP 网络的接口设备</strong>。IP 电话网关的作用就是：</p><ol><li>在电话呼叫阶段和呼叫释放阶段进行电话信令的转换。</li><li>在通话期间进行话音编码的转换。</li></ol><p><img src="/../img/post/computer-network/8-6.jpg"></p><h3 id="3-1-3-IP-电话的通话质量"><a href="#3-1-3-IP-电话的通话质量" class="headerlink" title="3.1.3 IP 电话的通话质量"></a>3.1.3 IP 电话的通话质量</h3><p><strong>IP 电话的通话质量的两个因素：</strong></p><ol><li><strong>通话双方端到端的时延和时延抖动</strong><ol><li>话音信号进行<strong>模数转换要产生时延</strong>。</li><li>已经数字化的话音<strong>比特流</strong>要积累到一定的数量才能够<strong>装配成一个话音分组</strong>，这也会产生时延。</li><li><strong>话音分组的发送需要时间</strong>，此时间等于话音分组长度与通信线路的数据率之比。</li><li>话音分组在互联网中经过许多<strong>路由器的存储转发时延</strong>。</li><li>话音分组到达<strong>接收端在缓存</strong>中暂存所引起的时延。</li><li>将<strong>话音分组还原成模拟话音信号</strong>的数模转换也要产生一定的时延。</li><li>话音信号在通信线路上的<strong>传播时延</strong>。</li><li><strong>由终端设备的硬件和操作系统产生的接入时延</strong>。</li></ol></li><li><strong>话音分组的丢失率</strong></li></ol><h2 id="3-2-IP-电话所需要的几种应用协议"><a href="#3-2-IP-电话所需要的几种应用协议" class="headerlink" title="3.2 IP 电话所需要的几种应用协议"></a>3.2 IP 电话所需要的几种应用协议</h2><p>在 IP 电话的通信中，我们至少需要两种应用协议。一种是<strong>信令协议，</strong>它使我们能够在互联网上找到被叫用户。另一种是话音分组的<strong>传送协议</strong>，它使我们用来进行电话通信的话音数据能够以时延敏感属性在互联网中传送。</p><p><img src="/../img/post/computer-network/8-7.jpg"></p><h2 id="3-3-实时运输协议-RTP"><a href="#3-3-实时运输协议-RTP" class="headerlink" title="3.3 实时运输协议 RTP"></a>3.3 实时运输协议 RTP</h2><p>RTP 为实时应用提供端到端的运输，<strong>但不提供任何服务质量的保证</strong>。需要发送的多媒体数据块（音频&#x2F;视频）经过压缩编码处理后，先送给 RTP 封装成为 RTP 分组（也可称为 RTP 报文)。RTP 分组装入运输层的 UDP 用户数据报后，再向下递交给 IP 层。</p><p>RTP 还有两点值得注意。首先，<strong>RTP 分组只包含 RTP 数据</strong>，而<strong>控制是由另一个配套使用的 RTCP 协议提供</strong>。其次，RTP 在端口号 1025 到 65535 之间选择一个未使用的<strong>偶数</strong> UDP 端口号，而在<strong>同一次会话中的 RTCP 则使用下一个奇数 UDP 端口号</strong>。但端口号 5004 和 5005 则分别用作 RTP 和 RTCP 的默认端口号。</p><p><img src="/../img/post/computer-network/8-8.jpg"></p><p>在 RTP 分组的首部中，前 12 个字节是必需的，而 12 字节以后的部分则是可选的。下面按照各字段重要性的顺序来进行介绍：</p><ol><li><strong>有效载荷类型（payload type）：</strong>占 7 位。这个字段指出后面的 RTP 数据属于何种格式的应用。收到 RTP 分组的应用层就根据此字段指出的类型进行处理。</li><li><strong>序号：</strong>占 16 位，对每一个发送出的 RTP 分组，其序号加 1。在一次 RTP 会话开始时的初始序号是随机选择的。序号使接收端能够发现丢失的分组，同时也能将失序的 RTP 分组重新按序排列好。</li><li><strong>时间戳：</strong>占 32 位，时间戳反映了 RTP 分组中数据的第一个字节的采样时刻。</li><li><strong>同步源标识符：</strong>占32位，用来标志 RTP 流的来源。</li><li><strong>参与源标识符：</strong>可选，最多 15 个。用来标志来源于不同地点的 RTP 流。</li><li><strong>参与源数：</strong>占 4 位，这个字段给出后面的参与源标识符的数目。</li><li><strong>版本：</strong>占 2 位。当前使用的是版本 2。</li><li><strong>填充 P：</strong>占 1 位，在某些特殊情况下需要对应用数据块加密，这往往要求每一个数据块有确定的长度。如不满足这种长度要求，就需要进行填充。这时就把 Р 位置 1，表示这个 RTP 分组的数据有若干填充字节。在数据部分的最后一个字节用来表示所填充的字节数。</li><li><strong>扩展 X：</strong>占1位，X 置 1 表示在此 RTP 首部后面还有扩展首部。</li><li><strong>标记 M</strong>：占 1 位，M 置 1 表示这个 RTP 分组具有特殊意义。</li></ol><h2 id="3-4-实时运输控制协议-RTCP"><a href="#3-4-实时运输控制协议-RTCP" class="headerlink" title="3.4 实时运输控制协议 RTCP"></a>3.4 实时运输控制协议 RTCP</h2><p>实时运输控制协议 RTCP（RTP Control Protocol）是与 RTP 配合使用的协议，RTCP 协议也是 RTP 协议不可分割的部分。</p><p><strong>RTCP 协议的主要功能是：</strong></p><ol><li>服务质量的监视与反馈</li><li>媒体间的同步（如某一个 RTP 发送的声音和图像的配合）</li><li>多播组中成员的标志</li></ol><p>RTCP 使用的五种分组类型，它们都使用同样的格式：</p><p><img src="/../img/post/computer-network/8-9.jpg"></p><ul><li><strong>结束分组 BYE：</strong>表示关闭一个数据流。</li><li><strong>特定应用分组 APP：</strong>使应用程序能够定义新的分组类型。</li><li><strong>接收端报告分组 RR：</strong>用来使接收端周期性地向所有的点用多播方式进行报告。</li></ul><h2 id="3-5-H-323（IP电话的一套信令标准）"><a href="#3-5-H-323（IP电话的一套信令标准）" class="headerlink" title="3.5 H.323（IP电话的一套信令标准）"></a>3.5 H.323（IP电话的一套信令标准）</h2><p>H.323 不是一个单独的协议而是一组协议。H.323 包括系统和构件的描述、呼叫模型的描述、呼叫信令过程、控制报文、复用、话音编解码器、视像编解码器，以及数据协议等。</p><p>H.323 标准指明了四种构件，使用这些构件连网就可以进行点对点或一点对多点的多媒体通信：</p><ol><li><strong>H.323终端：</strong>这可以是一个PC，也可以是运行H.323程序的单个设备。</li><li><strong>网关：网关连接到两种不同的网络</strong>，使得 H.323 网络可以和非 H.323 网络（如公用电话网）进行通信。仅在一个 H.323 网络上通信的两个终端不需使用网关。</li><li><strong>网闸（gatekeeper）：</strong>网闸相当于整个H.323网络的大脑。</li><li><strong>多点控制单元 MCU（Multipoint Control Unit）：</strong>MCU 支持三个或更多的 H.323 终端的音频或视频会议。</li></ol><p><img src="/../img/post/computer-network/8-10.jpg"></p><p>H.323 是一个协议族，它可以使用不同的运输协议，组成部分：</p><p><img src="/../img/post/computer-network/8-11.jpg"></p><ol><li><strong>音频编解码器：</strong>H.323要求至少要支持 G.711，建议支持 G.722, G.723.1, G.728 和 G.729。</li><li><strong>视频编解码器：</strong>H.323 要求必须支持H.261标准。</li><li><strong>H.255.0 登记信令：</strong>即登记&#x2F;接纳&#x2F;状态 RAS。</li><li><strong>H.225.0 呼叫信令：</strong>用来在两个 H.323 端点之间建立连接。</li><li><strong>H.245 控制信令：</strong>用来交换端到端的控制报文，以便管理 H.323 端点的运行。</li><li><strong>T.120 数据传送协议：</strong>这是与呼叫相关联的数据交换协议。</li><li><strong>实时运输协议 RTP 和实时运输控制协议 RTCP</strong></li></ol><h2 id="3-6-会话发起协议-SIP（IP电话的另一套信令标准）"><a href="#3-6-会话发起协议-SIP（IP电话的另一套信令标准）" class="headerlink" title="3.6 会话发起协议 SIP（IP电话的另一套信令标准）"></a>3.6 会话发起协议 SIP（IP电话的另一套信令标准）</h2><p>SIP 协议的出发点是以互联网为基础，而把 IP 电话视为互联网上的新应用。因此 SIP 协议只涉及到 IP 电话所需的信令和有关服务质量的问题，而没有提供像 H.323 那样多的功能。SIP 没有强制使用特定的编解码器，也不强制使用 RTP 协议。然而，实际上大家还是选用 RTP 和 RTCP 作为配合使用的协议。</p><p>SIP 使用<strong>文本方式</strong>的客户服务器协议。<strong>SIP 系统只有两种构件：</strong></p><ol><li><strong>用户代理（user agent）：</strong>包括两个程序：<ol><li><strong>用户代理客户 UAC (User AgentClient)：</strong>用来发起呼叫</li><li><strong>用户代理服务器 UAS (User Agent Server)：</strong>用来接受呼叫。</li></ol></li><li><strong>网络服务器（network server）：</strong>包括两个程序：<ol><li><strong>代理服务器（proxy server）：</strong>接受来自主叫用户的呼叫请求</li><li><strong>重定向服务器（redirect server）：</strong>通过响应告诉客户下一跳代理服务器的地址。</li></ol></li></ol><p>SIP 的地址十分灵活。它可以是电话号码，也可以是电子邮件地址、IP 地址或其他类型的地址。但一定要使用SIP的地址格式，例如：</p><ul><li><strong>电话号码：</strong>sip:zhangsan@8625-87654321</li><li><strong>IPv4地址：</strong>sip:<a href="mailto:&#122;&#104;&#97;&#110;&#x67;&#115;&#x61;&#110;&#64;&#x32;&#x30;&#49;&#x2e;&#49;&#50;&#46;&#x33;&#52;&#46;&#53;&#54;">&#122;&#104;&#97;&#110;&#x67;&#115;&#x61;&#110;&#64;&#x32;&#x30;&#49;&#x2e;&#49;&#50;&#46;&#x33;&#52;&#46;&#53;&#54;</a></li><li><strong>电子邮件地址：</strong>sip:<a href="mailto:&#122;&#x68;&#97;&#x6e;&#x67;&#x73;&#97;&#110;&#x40;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;">&#122;&#x68;&#97;&#x6e;&#x67;&#x73;&#97;&#110;&#x40;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;</a></li></ul><p><img src="/../img/post/computer-network/8-12.jpg"></p><p>和 HTTP相似，SIP 是基于报文的协议。SIP 使用了 HTTP 的许多首部、编码规则、差错码以及一些鉴别机制。它比 H.323 具有更好的可扩缩性。SIP 的会话共有三个阶段：<strong>建立会话</strong>、<strong>通信</strong>和<strong>终止会话</strong>。</p><p><img src="/../img/post/computer-network/8-13.jpg"></p><p>SIP 有一种跟踪用户的机制，可以找出被叫方使用的 PC 的 IP 地址。为了实现跟踪，SIP 使用登记的概念。SIP 定义一些服务器作为 SIP 登记器。每一个 SIP 用户都有一个相关联的 SIP 登记器。</p><h1 id="4-改进“尽最大努力交付”的服务"><a href="#4-改进“尽最大努力交付”的服务" class="headerlink" title="4.改进“尽最大努力交付”的服务"></a>4.改进“尽最大努力交付”的服务</h1><h2 id="4-1-使互联网提供服务质量"><a href="#4-1-使互联网提供服务质量" class="headerlink" title="4.1 使互联网提供服务质量"></a>4.1 使互联网提供服务质量</h2><p>服务质量 QoS 是服务性能的总效果，此效果决定了一个用户对服务的满意程度。</p><h2 id="4-2-调度和管制机制"><a href="#4-2-调度和管制机制" class="headerlink" title="4.2 调度和管制机制"></a>4.2 调度和管制机制</h2><h3 id="4-2-1-调度机制"><a href="#4-2-1-调度机制" class="headerlink" title="4.2.1 调度机制"></a>4.2.1 调度机制</h3><p>“调度”就是指排队的规则。先进先出的最大缺点就是<strong>不能区分时间敏感分组和一般数据分组。在先进先出的基础上增加按优先级排队，就能使优先级高的分组优先得到服务。</strong></p><p><img src="/../img/post/computer-network/8-14.jpg"></p><p>但是，简单地按优先级排队会带来一个缺点，<strong>这就是在高优先级队列中总是有分组时，低优先级队列中的分组就长期得不到服务，这就不太公平。公平排队 FQ（Fair Queuing）可解决这问题。</strong></p><p>为了使高优先级队列中的分组有更多的机会得到服务，可增加队列“权重”的概念，这就是<strong>加权公平排队WFQ（Weighted Fair Queuing）</strong>，其工作原理如图：</p><p><img src="/../img/post/computer-network/8-15.jpg"></p><p>加权公平排队 WFQ 是这样工作的。分组到达后就进行分类，然后送交与其类别对应的队列（图中假定分为三类）。三个队列按顺序依次把队首的分组发送到链路。<strong>遇到队列空就跳过去。但根据各类别的优先级不同，每种队列分配到的服务时间也不同。</strong>可以给队列 $i$ 指派一个权重 $w_i$。于是队列 $i$ 得到的平均服务时间为 $w_i&#x2F;(\Sigma{w_j})$，这里 $\Sigma{w_j}$是对所有的非空队列的权重求和。这样，若路由器输出链路的数据率（即带宽）为  $R$，那么队列 $i$ 将得到的有保证的数据率 $R_i$ 应为：</p><p>$$<br>R_i&#x3D;\frac{R×w_i}{\Sigma{w_j}}<br>$$</p><p>加权公平排队 WFQ 在服务质量体系结构中占有重要的地位。当前的许多路由器产品都加入了 WFQ 调度的功能</p><h3 id="4-2-2-管制机制"><a href="#4-2-2-管制机制" class="headerlink" title="4.2.2 管制机制"></a>4.2.2 管制机制</h3><p>前面提到了使用管制机制可以提供服务质量。<strong>对一个数据流，我们可根据以下三个方面进行管制：</strong></p><ol><li><strong>平均速率</strong></li><li><strong>峰值速率</strong></li><li><strong>突发长度：</strong>在非常短的时间间隔内连续注入到网络中的分组数。</li></ol><p>要在网络中对进入网络的分组流按以上三个指标进行管制，可使用非常著名的漏桶管制器（leaky bucket policer）（可简称为漏桶），其工作原理如图：</p><p><img src="/../img/post/computer-network/8-16.jpg"></p><h3 id="4-2-3-漏桶机制与加权公平排队相结合"><a href="#4-2-3-漏桶机制与加权公平排队相结合" class="headerlink" title="4.2.3 漏桶机制与加权公平排队相结合"></a>4.2.3 漏桶机制与加权公平排队相结合</h3><p>把漏桶机制与加权公平排队结合起来，可以控制队列中的最大时延。</p><p><img src="/../img/post/computer-network/8-17.jpg"></p><h2 id="4-3-综合服务-IntServ-与资源预留协议-RSVp"><a href="#4-3-综合服务-IntServ-与资源预留协议-RSVp" class="headerlink" title="4.3 综合服务 IntServ 与资源预留协议 RSVp"></a>4.3 综合服务 IntServ 与资源预留协议 RSVp</h2><p><strong>IntServ 可对单个的应用会话提供服务质量的保证，其主要特点有二：</strong></p><ol><li><strong>资源预留：</strong>一个路由器需要知道给不断出现的会话已经预留了多少资源（即链路带宽和缓存空间）。</li><li><strong>呼叫建立：</strong>一个需要服务质量保证的会话，必须首先在源点到终点路径上的每一个路由器预留足够的资源，以保证其端到端的服务质量的要求。</li></ol><p><strong>IntServ 定义了两类服务：</strong></p><ol><li><strong>有保证的服务（guaranteed service）：</strong>可保证一个分组在通过路由器时的排队时延有一个严格的上限。</li><li><strong>受控负载的服务（controlled-load service）：</strong>可以使应用程序得到比通常的“尽最大努力”更加可靠的服务。</li></ol><p><strong>IntServ 共有以下四个组成部分：</strong></p><ol><li><strong>资源预留协议 RSVP：</strong>它是IntServ的信令协议。</li><li><strong>接纳控制（admission control）：</strong>用来决定是否同意对某一资源的请求。</li><li><strong>分类器（classifier）：</strong>用来把进入路由器的分组进行分类，并根据分类的结果把不同类别的分组放入特定的队列。</li><li><strong>调度器（scheduler）：</strong>根据服务质量要求决定分组发送的前后顺序。</li></ol><p><strong>综合服务 IntServ 体系结构存在的主要问题是：</strong></p><ol><li>状态信息的数量与流的数目成正比。</li><li>IntServ 体系结构复杂。<strong>若要得到有保证的服务，所有的路由器都必须装有接纳控制、分类器和调度器。这种路由器称为RSVP路由器。</strong></li></ol><h2 id="4-4-区分服务-DiffServ"><a href="#4-4-区分服务-DiffServ" class="headerlink" title="4.4 区分服务 DiffServ"></a>4.4 区分服务 DiffServ</h2><h3 id="4-4-1-区分服务的基本概念"><a href="#4-4-1-区分服务的基本概念" class="headerlink" title="4.4.1 区分服务的基本概念"></a>4.4.1 区分服务的基本概念</h3><p>由于综合服务 IntServ 和资源预留协议 RSVP 都较复杂，很难在大规模的网络中实现，因此 IETF 提出了一种新的策略，即区分服务 DiffServ（Differentiated Services） [RFC 2475][W-DiffServ]。区分服务有时也简写为 DS。因此，具有区分服务功能的结点就称为 DS 结点。</p><p><strong>区分服务 DiffServ 的要点如下：</strong></p><ol><li><p>DiffServ 力图<strong>不改变网络的基础结构</strong>，但在路由器中<strong>增加区分服务的功能</strong>。因此，DiffServ 将 IP 协议中原有 8 位的 IPv4 的服务类型字段和 IPv6 的通信量类字段重新定义为区分服务 DS。路由器根据 DS 字段的值来处理分组的转发。</p></li><li><p><strong>网络被划分为许多个 DS 域（DS Domain）</strong>。一个 DS 域在一个管理实体的控制下实现同样的区分服务策略。<strong>DiffServ 将所有的复杂性放在 DS 域的边界结点（boundary node）中，而使 DS域内部路由器工作得尽可能简单。</strong>边界结点可以是主机、路由器或防火墙等。</p><p><img src="/../img/post/computer-network/8-18.jpg"></p></li><li><p><strong>边界路由器中的功能较多</strong>，可分为分类器（classifier）和通信量调节器（conditioner）两大部分。调节器又由标记器（marker）、整形器（shaper）和测定器（meter）三个部分组成。</p><p><img src="/../img/post/computer-network/8-19.jpg"></p></li><li><p><strong>DiffServ 提供了一种聚合（aggregation）功能</strong>。DiffServ 不是为网络中的每一个流维持供转发时使用的状态信息，而是把若干个流根据其 DS 值聚合成少量的流。</p></li></ol><h3 id="4-4-2-每跳行为-PHB"><a href="#4-4-2-每跳行为-PHB" class="headerlink" title="4.4.2 每跳行为 PHB"></a>4.4.2 每跳行为 PHB</h3><p>DiffServ 定义了在转发分组时体现服务水平的每跳行为 PHB（Per-Hop Behavior）。所谓“行为”就是指在转发分组时路由器对分组是怎样处理的。</p><p><strong>IETF 的 DiffServ 工作组已经定义了两种 PHB：</strong></p><ol><li><strong>迅速转发 PHB：</strong>可记为 EF PHB，或 EF。EF PHB 用来构造通过 DS 域的一个低丢失率、低时延、低时延抖动、确保带宽的端到端服务（即不排队或很少排队）。</li><li><strong>确保转发 PHB：</strong>可记为 AF PHB 或 AF。AF 用 DSCP 的第 0<del>2 位把通信量划分为四个等级（分别为001, 010, 011 和 100），并给每一种等级提供最低数量的带宽和缓存空间。对于其中的每一个等级再用 DSCP 的第 3</del>5 位划分出三个“丢弃优先级”（分别为 010, 100 和 110，从最低丢弃优先级到最高丢弃优先级）。当发生网络拥塞时，对于每一个等级的 AF，路由器就首先把“丢弃优先级”较高的分组丢弃。</li></ol><p>可以看出，区分服务 DiffServ 比较灵活，因为它并没有定义特定的服务或服务类别。当新的服务类别出现而旧的服务类别不再使用时，DiffServ 仍然可以工作。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络 第七章：网络安全</title>
    <link href="/computer-network-7/"/>
    <url>/computer-network-7/</url>
    
    <content type="html"><![CDATA[<h1 id="1-网络安全问题概述"><a href="#1-网络安全问题概述" class="headerlink" title="1.网络安全问题概述"></a>1.网络安全问题概述</h1><h2 id="1-1-计算机网络面临的安全性威胁"><a href="#1-1-计算机网络面临的安全性威胁" class="headerlink" title="1.1 计算机网络面临的安全性威胁"></a>1.1 计算机网络面临的安全性威胁</h2><p><strong>计算机网络的通信面临两大类威胁：</strong></p><ol><li><strong>被动攻击：</strong>指攻击者从网络上窃听他人的通信内容。通常把这类攻击称为截获。</li><li><strong>主动攻击：</strong><ol><li><strong>篡改：</strong>攻击者故意篡改、中断网络上传送的报文。</li><li><strong>恶意程序：</strong>计算机病毒、蠕虫、特洛伊木马、逻辑炸弹、后门入侵、流氓软件等。</li></ol></li><li><strong>拒绝服务 DoS（Denial of Service）：</strong>若从互联网上的成百上千个网站集中攻击一个网站，则称为分布式拒绝服务 DDOS。</li></ol><p><img src="/../img/post/computer-network/7-1.jpg"></p><h2 id="1-2-安全的计算机网络"><a href="#1-2-安全的计算机网络" class="headerlink" title="1.2 安全的计算机网络"></a>1.2 安全的计算机网络</h2><p><strong>一个安全的计算机网络应设法达到以下四个目标：</strong></p><ol><li><strong>保密性：</strong>只有信息的发送方和接收方才能懂得所发送信息的内容。</li><li><strong>端点鉴别：</strong>必须能够鉴别信息的发送方和接收方的真实身份。</li><li><strong>信息的完整性：</strong>必须确认所收到的信息都是完整的。</li><li><strong>运行的安全性：</strong>计算机网络运行的安全性。</li></ol><h2 id="1-3-数据加密模型"><a href="#1-3-数据加密模型" class="headerlink" title="1.3 数据加密模型"></a>1.3 数据加密模型</h2><p>一般的数据加密模型，用户 A 向 B 发送明文 X，但通过加密算法 E 运算后，就得出密文 Y。</p><p><img src="/../img/post/computer-network/7-2.jpg"></p><h1 id="2-两类密码体制"><a href="#2-两类密码体制" class="headerlink" title="2.两类密码体制"></a>2.两类密码体制</h1><h2 id="2-1-对称密钥密码体制"><a href="#2-1-对称密钥密码体制" class="headerlink" title="2.1 对称密钥密码体制"></a>2.1 对称密钥密码体制</h2><p><strong>加密密钥与解密密钥是使用相同的密码体制</strong>。数据加密标准 DES 属于对称密钥密码体制。它由 IBM 公司研制出，于 1977 年被美国定为联邦信息标准后，在国际上引起了极大的重视。ISO 曾将 DES 作为数据加密标准。</p><p><strong>DES 的保密性仅取决于对密钥的保密，而算法是公开的</strong>。DES 的问题是它的密钥长度。56 位长的密钥意味着共有 $2^{56}$ 种可能的密钥。（1999 年被破解）</p><h2 id="2-2-公钥密码体制（非对称密钥）"><a href="#2-2-公钥密码体制（非对称密钥）" class="headerlink" title="2.2 公钥密码体制（非对称密钥）"></a>2.2 公钥密码体制（非对称密钥）</h2><p>公钥密码体制（又称为公开密钥密码体制）的概念是由斯坦福大学的研究人员 Diffie 与 Hellman 于 1976 年提出的。<strong>公钥密码体制使用不同的加密密钥与解密密钥</strong>。</p><p>公钥密码体制的产生主要有两个方面的原因，一是由于对称密钥密码体制的<strong>密钥分配</strong>问题，二是由于对<strong>数字签名</strong>的需求。</p><p>公钥密码体制提出不久，人们就找到了三种公钥密码体制。目前最著名的是由美国三位科学家 Rivest, Shamir 和 Adleman 于 1976 年提出并在 1978 年正式发表的 RSA 体制，它是一种基于数论中的大数分解问题的体制。</p><p>在公钥密码体制中，<strong>加密密钥 PK（public key，即公钥）</strong>是向公众公开的，而<strong>解密密钥SK（secret key，即私钥或秘钥）</strong>则是需要<strong>保密</strong>的。<strong>加密算法 E</strong> 和<strong>解密算法 D</strong> 也都是公开的。</p><p><strong>公钥密码体制的加密和解密过程有如下特点：</strong></p><p>（1）密钥对产生器产生出接收者 B 的一对密钥：加密密钥 $PK_B$ 和解密密钥 $SK_B$ 。发送者 A 所用的加密密钥 $PK_B$ 就是接收者 B 的公钥，它向公众公开。而 B 所用的解密密钥  $SK_B$  就是接收者 B 的私钥，对其他人都保密。</p><p>（2）发送者 A 用 B 的公钥 $PK_B$ 通过 E 运算对明文 X 加密，得出密文 Y，发送给 B。</p><p>$$<br>Y&#x3D;E_{PK_B}(X)<br>$$</p><p>B 用自己的私钥  $SK_B$  通过 D 运算进行解密，恢复出明文，即</p><p>$$<br>D_{SK_B}(Y)&#x3D;D_{SK_B}(E_{PK_B}(X))&#x3D;X<br>$$</p><p>（3）虽然在计算机上可以容易地产生成对的$PK_B$ 和 $SK_B$ ，但从已知的 $PK_B$ 实际上不可能。</p><p>（4）虽然公钥可用来加密，但却不能用来解密，即</p><p>$$<br>D_{PK_B}(E_{PK_B}(X)) \ne X<br>$$</p><p>（5）先后对 X 进行 D 运算和 E 运算或进行 E 运算和 D 运算，结果都是一样的：</p><p>$$<br>E_{PK_B}(D_{SK_B}(X))&#x3D;D_{SK_B}(E_{PK_B}(X))&#x3D;X<br>$$</p><p><img src="/../img/post/computer-network/7-3.jpg"></p><p>请注意，<strong>任何加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量</strong>，而不是简单地取决于加密的体制（公钥密码体制或传统加密体制）。</p><h1 id="3-数字签名"><a href="#3-数字签名" class="headerlink" title="3.数字签名"></a>3.数字签名</h1><p>书信或文件是根据亲笔签名或印章来证明其真实性的。但在计算机网络中传送的文电又如何盖章呢？这就要使用<strong>数字签名</strong>。数字签名必须保证能够实现以下三点功能：</p><ol><li>接收者能够核实发送者对报文的签名。这叫做<strong>报文鉴别</strong>。</li><li>接收者确信所收到的数据和发送者发送的完全一样而没有被篡改过。这叫做<strong>报文的完整性</strong>。</li><li>发送者事后不能抵赖对报文的签名。这叫做<strong>不可否认</strong>。</li></ol><p><img src="/../img/post/computer-network/7-4.jpg"></p><h1 id="4-鉴别"><a href="#4-鉴别" class="headerlink" title="4.鉴别"></a>4.<strong>鉴别</strong></h1><h2 id="4-1-报文鉴别"><a href="#4-1-报文鉴别" class="headerlink" title="4.1 报文鉴别"></a>4.1 报文鉴别</h2><h3 id="4-1-1-密码散列函数"><a href="#4-1-1-密码散列函数" class="headerlink" title="4.1.1 密码散列函数"></a>4.1.1 密码散列函数</h3><p>D 运算和 E 运算都需要花费非常多的计算机的 CPU 时间。因此，我们需要找出一种相对简单的方法对报文进行鉴别。这种方法就是使用<strong>密码散列函数（cryptographic hash function）</strong>。</p><p><strong>散列函数具有以下两个特点：</strong></p><ol><li>散列函数的输入长度可以很长，但其输出长度则是固定的，并且较短。散列函数的输出叫做散列值。</li><li>不同的散列值肯定对应于不同的输入，但不同的输入却可能得出相同的散列值。这就是说，散列函数的输入和输出并非一一对应的，而是多对一的。</li></ol><p><img src="/../img/post/computer-network/7-5.jpg"></p><p>在密码学中使用的散列函数称为密码散列函数，其最重要的特点就是：<strong>要找到两个不同的报文，它们具有同样的密码散列函数输出，在计算上是不可行的。</strong></p><h3 id="4-1-1-实用的密码散列函数-MD5-和-SHA-1"><a href="#4-1-1-实用的密码散列函数-MD5-和-SHA-1" class="headerlink" title="4.1.1 实用的密码散列函数 MD5 和 SHA-1"></a>4.1.1 实用的密码散列函数 MD5 和 SHA-1</h3><p>通过许多学者的不断努力，已经设计出一些实用的密码散列函数（或称为散列算法），其中最出名的就是 MD5 和 SHA-1。MD 就是 Message Digest 的缩写，意思是报文摘要。</p><p><strong>MD5算法的大致过程如下：</strong></p><ol><li>先把任意长的报文按模 $2^{64}$ 计算其余数（64位），追加在报文的后面。</li><li>在报文和余数之间填充 1~512 位，使得填充后的总长度是 512 的整数倍。填充的首位是 1，后面都是 0。</li><li>把追加和填充后的报文分割为一个个 512 位的数据块，每个 512 位的报文数据再分成 4 个 128 位的数据块依次送到不同的散列函数进行 4 轮计算。每一轮又都按 32 位的小数据块进行复杂的运算。一直到最后计算出 MD5 报文摘要代码（128位）。</li></ol><h3 id="4-1-3-报文鉴别码"><a href="#4-1-3-报文鉴别码" class="headerlink" title="4.1.3 报文鉴别码"></a>4.1.3 报文鉴别码</h3><p>下面进一步讨论在报文鉴别中怎样使用散列函数。下面给出的三个简单步骤：</p><ol><li>用户 A 首先根据自己的明文 X 计算出散列 H(X)（例如，使用 MD5）。为方便起见，我们把得出的散列 H(X) 记为 H。</li><li>用户 A 把散列 H 拼接在明文 X 的后面，生成了扩展的报文 (X, H)，然后发送给 B。</li><li>用户 B 收到了这个扩展的报文 (X, H)。因为散列的长度 H 是早已知道的固定值，因此可以把收到的散列 H 和明文 X 分离开。B 通过散列函数的运算，计算出收到的明文 X 的散列 H(X)。若 H(X)&#x3D;H，则 B 似乎可以相信所收到的明文是 A 发送过来的。</li></ol><p><img src="/../img/post/computer-network/7-6.jpg"></p><h2 id="4-2-实体鉴别"><a href="#4-2-实体鉴别" class="headerlink" title="4.2 实体鉴别"></a>4.2 实体鉴别</h2><p>实体鉴别和报文鉴别不同。<strong>报文鉴别是对每一个收到的报文都要鉴别报文的发送者</strong>，而<strong>实体鉴别是在系统接入的全部持续时间内对和自己通信的对方实体只需验证一次</strong>。</p><p>但是，实体鉴别有漏洞叫“重放攻击”。C 截断 A 的信息，伪装成 C 发送给 B，让 B 误认为 C 就是 A。</p><h1 id="5-密钥分配"><a href="#5-密钥分配" class="headerlink" title="5.密钥分配"></a>5.密钥分配</h1><h2 id="5-1-对称密钥的分配"><a href="#5-1-对称密钥的分配" class="headerlink" title="5.1 对称密钥的分配"></a>5.1 对称密钥的分配</h2><p>目前常用的密钥分配方式是设立<strong>密钥分配中心 KDC（Key Distribution Center）</strong>。KDC 是大家都信任的机构，其任务就是给需要进行秘密通信的用户临时分配一个会话密钥（仅使用一次）。</p><h2 id="5-2-公钥的分配（非对称密钥）"><a href="#5-2-公钥的分配（非对称密钥）" class="headerlink" title="5.2 公钥的分配（非对称密钥）"></a>5.2 公钥的分配（非对称密钥）</h2><p>公钥的分配通过认证中心 <strong>CA（Certification Authority）</strong>，它一般由政府出资建立。每个实体都有 CA 发来的证书，里面有公钥及其拥有者的标识信息（人名或 IP 地址）。此证书被 CA 进行了数字签名。</p><h1 id="6-互联网使用的安全协议"><a href="#6-互联网使用的安全协议" class="headerlink" title="6.互联网使用的安全协议"></a>6.互联网使用的安全协议</h1><h2 id="6-1-网络层安全协议"><a href="#6-1-网络层安全协议" class="headerlink" title="6.1 网络层安全协议"></a>6.1 网络层安全协议</h2><h3 id="6-1-1-IPsec-协议族概述"><a href="#6-1-1-IPsec-协议族概述" class="headerlink" title="6.1.1 IPsec 协议族概述"></a>6.1.1 IPsec 协议族概述</h3><p>IPsec 并不是一个单一协议，而是能够在 IP 层提供互联网通信安全的协议族（不太严格的名词“IPsec协议”也常见到）。IPsec 并没有限定用户必须使用何种特定的加密和鉴别算法。实际上，IPsec 是个框架，它允许通信双方选择合适的算法和参数（例如，密钥长度）。为保证互操作性，IPsec 还包含了一套加密算法，所有 IPsec 的实现都必须使用。</p><p><strong>IPsec 协议族中的协议可划分为以下三个部分：</strong></p><ol><li><strong>IP 安全数据报格式的两个协议：</strong>鉴别首部 AH（Authentication Header）协议和封装安全有效载荷 ESP（Encapsulation Security Payload）协议。</li><li>有关加密算法的<strong>三个协议</strong>。</li><li><strong>互联网密钥交换 IKE（Internet Key Exchange）协议</strong>。</li></ol><p><strong>IP 安全数据报有以下两种不同的工作方式：</strong></p><ol><li><strong>运输方式（transport mode）：</strong>运输方式是在整个运输层报文段的前后分别添加若干控制信息，再加上 IP 首部，构成 IP 安全数据报。</li><li><strong>隧道方式（tunnel mode）：</strong>隧道方式是在原始的IP数据报的前后分别添加若干控制信息，再加上新的 IP 首部，构成一个 IP 安全数据报。</li></ol><p>无论使用哪种方式，最后得出的 IP 安全数据报的 IP 首部都是<strong>不加密的</strong>。只有使用不加密的 IP 首部，互联网中的各个路由器才能识别 IP 首部中的有关信息，把 IP 安全数据报在不安全的互联网中进行转发，从源点安全地转发到终点。</p><h3 id="6-1-2-安全关联-SA"><a href="#6-1-2-安全关联-SA" class="headerlink" title="6.1.2 安全关联 SA"></a>6.1.2 安全关联 SA</h3><p>在发送 IP 安全数据报之前，在源实体和目的实体之间必须创建一条网络层的<strong>逻辑连接</strong>，即<strong>安全关联 SA（Security Association）</strong>。这样，传统的互联网中无连接的网络层就变为了具有逻辑连接的一个层。安全关联是从源点到终点的单向连接，它能够提供安全服务。</p><p><img src="/../img/post/computer-network/7-7.jpg"></p><h3 id="6-1-3-IP-安全数据报的格式"><a href="#6-1-3-IP-安全数据报的格式" class="headerlink" title="6.1.3 IP 安全数据报的格式"></a>6.1.3 IP 安全数据报的格式</h3><p><img src="/../img/post/computer-network/7-8.jpg"></p><h3 id="6-1-4-IPsec-的其他构件"><a href="#6-1-4-IPsec-的其他构件" class="headerlink" title="6.1.4 IPsec 的其他构件"></a>6.1.4 IPsec 的其他构件</h3><ul><li><strong>安全关联数据库 SAD：</strong>SA 存放的地方。</li><li><strong>安全策略数据库 SPD：</strong>指明什么样的数据报需要进行 IPsec 处理科。</li></ul><h2 id="6-2-运输层安全协议"><a href="#6-2-运输层安全协议" class="headerlink" title="6.2 运输层安全协议"></a>6.2 运输层安全协议</h2><p><strong>广泛使用的有两个协议：</strong></p><ul><li><strong>安全套接字层 SSL（Secure Socket Layer）</strong></li><li><strong>运输层安全 TLS（Transport Layer Security）</strong></li></ul><p>SSL 在 TLS 协议的基础上，SSL 增强了 TCP，更安全了。</p><p><strong>SSL 提供的安全服务可归纳为以下三种：</strong></p><ol><li>SSL 服务器鉴别，允许用户证实服务器的身份。</li><li>SSL 客户鉴别，SSL的可选安全服务，允许服务器证实客户的身份。</li><li>加密的 SSL 会话，对客户和服务器间发送的所有报文进行加密，并检测报文是否被篡改。</li></ol><p><strong>SSL 的工作过程：</strong></p><ol><li><strong>协商加密算法。</strong>浏览器 A 向服务器 B 发送浏览器的 SSL 版本号和一些可选的加密算法。B 从中选定自己所支持的算法（如RSA），并告知 A。</li><li><strong>服务器鉴别。</strong>服务器 B 向浏览器 A 发送包含其 RSA 公钥的数字证书。A 使用该证书的认证机构 CA 公开发布的 RSA 公钥对该证书进行验证。</li><li><strong>会话密钥计算。</strong>由浏览器 A 随机产生一个秘密数。用服务器 B 的 RSA 公钥进行加密后发送给 B。双方根据协商的算法产生共享的对称会话密钥。</li><li><strong>安全数据传输。</strong>双方用会话密钥加密和解密它们之间传送的数据并验证其完整性。</li></ol><p><img src="/../img/post/computer-network/7-9.jpg"></p><h2 id="6-3-应用层安全协议（电子邮件的安全协议）"><a href="#6-3-应用层安全协议（电子邮件的安全协议）" class="headerlink" title="6.3 应用层安全协议（电子邮件的安全协议）"></a>6.3 应用层安全协议（电子邮件的安全协议）</h2><p>PGP（Pretty Good Privacy）是 Zimmermann 于 1995 年开发的。它是一个完整的电子邮件安全软件包，包括加密、鉴别、电子签名和压缩等技术。</p><p><img src="/../img/post/computer-network/7-10.jpg"></p><p><img src="/../img/post/computer-network/7-11.jpg"></p><h1 id="7-防火墙与入侵检测"><a href="#7-防火墙与入侵检测" class="headerlink" title="7.防火墙与入侵检测"></a>7.防火墙与入侵检测</h1><h2 id="7-1-防火墙"><a href="#7-1-防火墙" class="headerlink" title="7.1 防火墙"></a>7.1 防火墙</h2><ul><li><p>一种访问控制技术，严格控制进出网络边界的分组，禁止任何不必要的通信，从而减少潜在的入侵风险。<strong>（第一道防线）</strong></p><p><img src="/../img/post/computer-network/7-12.jpg"></p></li><li><p>入侵检测系统 IDS，对进入网络分组的深度分析与检测，发现可疑入侵行为。<strong>（第二道防线）</strong></p></li></ul><p><strong>防火墙技术一般分为以下两类：</strong></p><ol><li><strong>分组过滤路由器：</strong>是一种具有分组过滤功能的路由器，它根据过滤规则对进出内部网络的分组执行转发或者丢弃（即过滤）。过滤规则是基于分组的网络层或运输层首部的信息。</li><li><strong>应用网关（代理服务器）：</strong>所有讲出网络的应用程序报文都必须通过应用网关。</li></ol><h2 id="7-2-入侵检测系统"><a href="#7-2-入侵检测系统" class="headerlink" title="7.2 入侵检测系统"></a>7.2 入侵检测系统</h2><p>入侵检测方法一般可以分为<strong>基于特征的入侵检测</strong>和<strong>基于异常的入侵检测</strong>两种。</p><ul><li><strong>基于特征的 IDS：</strong>维护一个所有已知攻击标志性特征的数据库。每个特征是一个与某种入侵活动相关联的规则集。当发现有与某种攻击特征匹配的分组或分组序列时，则认为可能检测到某种入侵行为。</li><li><strong>基于异常的 IDS：</strong>通过观察正常运行的网络流量，学习正常流量的统计特性和规律，当检测到网络中流量的某种统计规律不符合正常情况时，则认为可能发生了入侵行为。</li></ul><h1 id="8-一些未来的发展方向"><a href="#8-一些未来的发展方向" class="headerlink" title="8.一些未来的发展方向"></a>8.一些未来的发展方向</h1><ol><li>椭圆曲线密码（Elliptic Curve Cryptography，简写为ECC）与 AES 这一系统现在已广泛用于电子护照中，也是下一代金融系统使用的加密系统。</li><li>移动安全（Mobile Security）移动通信带来的广泛应用（如移动支付，Mobile Payment）向网络安全提出了更高的要求。</li><li>量子密码（Quantum Cryptography）量子计算机的到来将使得目前许多使用中的密码技术无效，后量子密码学（Post-Quantum Cryptography）的研究方兴未艾。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络 第六章：应用层</title>
    <link href="/computer-network-6/"/>
    <url>/computer-network-6/</url>
    
    <content type="html"><![CDATA[<p>不同的网络应用的应用进程之间，需要有不同的通信规则。因此在运输层协议之上，还需要有应用层协议（application layer protocol）。这是因为，每个应用层协议都是为了解决某一类应用问题，而问题的解决又必须通过位于不同主机中的多个应用进程之间的通信和协同工作来完成。应用进程之间的这种通信必须遵循严格的规则。应用层的具体内容就是精确定义这些通信规则。</p><h1 id="1-域名系统-DNS"><a href="#1-域名系统-DNS" class="headerlink" title="1.域名系统 DNS"></a>1.域名系统 DNS</h1><h2 id="1-1-域名系统概述"><a href="#1-1-域名系统概述" class="headerlink" title="1.1 域名系统概述"></a>1.1 域名系统概述</h2><p>域名系统 DNS（Domain Name System）是互联网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。</p><p>为了稳定，DNS 使用分布式的域名系统，并采用客户服务器方式。DNS 使大多数名字都在本地进行解析（resolve），仅少量解析需要在互联网上通信，因此 DNS 系统的效率很高。由于 DNS 是分布式系统，即使单个计算机出了故障，也不会妨碍整个 DNS 系统的正常运行。</p><p><strong>域名到 IP 地址的解析过程的要点如下：</strong></p><ul><li>当某一个应用进程需要把主机名解析为 IP 地址时，该应用进程就调用解析程序，并成为 DNS 的一个客户，把待解析的域名放在DNS 请求报文中，以 UDP 用户数据报方式发给本地域名服务器（使用 UDP 是为了减少开销)。</li><li>本地域名服务器在查找域名后，把对应的 IP 地址放在回答报文中返回。</li></ul><h2 id="1-2-互联网的域名结构"><a href="#1-2-互联网的域名结构" class="headerlink" title="1.2 互联网的域名结构"></a>1.2 互联网的域名结构</h2><p><img src="/../img/post/computer-network/6-1.jpg"></p><ol><li>每一个标号不超过 63 个字符；</li><li>不区分大小写字母；</li><li>由多个标号组成的完整域名总共不超过 255 个字符。</li></ol><h3 id="1-2-1-顶级域名分类"><a href="#1-2-1-顶级域名分类" class="headerlink" title="1.2.1 顶级域名分类"></a>1.2.1 顶级域名分类</h3><ol><li><strong>国家顶级域名 nTLD：</strong>cn、us、uk</li><li><strong>通用顶级域名 gTLD：</strong>com、net、org</li><li><strong>基础结构域名（infrastructure domain）：</strong>这种顶级域名只有一个，即 arpa，用于反向域名解析，因此又称为反向域名。</li></ol><p>我国把二级域名划分为<strong>“类别域名”</strong>和<strong>“行政区域名”</strong>两大类。</p><ul><li><strong>“类别域名”</strong>共 7 个，分别为：<ul><li>ac（科研机构）</li><li>com (工、商、金融等企业）</li><li>edu（中国的教育机构）</li><li>gov（中国的政府机构）</li><li>mil（中国的国防机构）</li><li>net（提供旦联网络服务的机构）</li><li>org（非营利性的组织）</li></ul></li><li><strong>“行政区域名”</strong>共 34 个，适用于我国的各省、自治区、直辖市。</li></ul><p><img src="/../img/post/computer-network/6-2.jpg"></p><h2 id="1-3-域名服务器"><a href="#1-3-域名服务器" class="headerlink" title="1.3 域名服务器"></a>1.3 域名服务器</h2><p>一个服务器所负责管辖的（或有权限的）范围叫做区（zone）。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器（authoritative name server），用来保存该区中的所有主机的域名到 IP 地址的映射。总之，DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。区是 DNS 服务器实际管辖的范围。<strong>区可能等于或小于域，但一定不能大于域。</strong></p><p><img src="/../img/post/computer-network/6-3.jpg"></p><p>这种 DNS 域名服务器树状结构图可以更准确地反映出 DNS 的分布式结构。</p><p><img src="/../img/post/computer-network/6-4.jpg"></p><h3 id="1-3-1-根域名服务器"><a href="#1-3-1-根域名服务器" class="headerlink" title="1.3.1 根域名服务器"></a>1.3.1 根域名服务器</h3><p>根域名服务器（root name server）：根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都<strong>知道所有的顶级域名服务器的域名和 IP 地址</strong>。根域名服务器是最重要的域名服务器，因为不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析（即转换为 IP 地址)，只要自己无法解析，就首先要求助于根域名服务器。</p><p>虽然互联网的根域名服务器总共只有 13 个域名，但这不表明根域名服务器是由 13 台机器所组成（如果仅仅依靠这 13 台机器，根本不可能为全世界的互联网用户提供令人满意的服务）。实际上，在互联网中是由 13 套装置构成这 13 组根域名服务器 [W-ROOT]。每一套装置在很多地点安装根域名服务器（也可称为镜像根服务器），<strong>但都使用同一个域名</strong>。</p><h3 id="1-3-2-顶级域名服务器"><a href="#1-3-2-顶级域名服务器" class="headerlink" title="1.3.2 顶级域名服务器"></a>1.3.2 顶级域名服务器</h3><p>这些域名服务器负责管理在<strong>该顶级域名服务器注册的所有二级域名</strong>。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的IP地址）。</p><h3 id="1-3-3-权限域名服务器"><a href="#1-3-3-权限域名服务器" class="headerlink" title="1.3.3 权限域名服务器"></a>1.3.3 权限域名服务器</h3><p><strong>负责一个区的域名服务器。</strong>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。</p><h3 id="1-3-4-本地域名服务器"><a href="#1-3-4-本地域名服务器" class="headerlink" title="1.3.4 本地域名服务器"></a>1.3.4 本地域名服务器</h3><p><strong>本地域名服务器并不属于域名服务器层次结构，但它对域名系统非常重要。</strong>当一台主机发出 DNS 查询请求时，<strong>这个查询请求报文就发送给本地域名服务器</strong>。</p><p>每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个<strong>本地域名服务器</strong>，这种域名服务器有时也称为<strong>默认域名服务器</strong>。</p><p>域名的解析过程，这里要注意两点：</p><ol><li><strong>主机</strong>向本地域名服务器的查询一般都是采用<strong>递归查询</strong>（recursive query）。所谓递归查询就是：<strong>如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文（即替该主机继续查询），而不是让该主机自己进行下一步的查询</strong>。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</li><li><strong>本地域名服务器</strong>向根域名服务器的查询通常是采用<strong>迭代查询</strong>（iterative query）。迭代查询的特点是这样的：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。</li></ol><p><img src="/../img/post/computer-network/6-5.jpg"></p><p>假定域名为 m.xyz.com 的主机想知道另一台主机（域名为 y.abc.com）的 IP 地址。例如，主机 m.xyz.com 打算发送邮件给主机 y.abc.com。这时就必须知道主机 y.abc.com 的 IP 地址。下面是几个查询步骤:</p><ol><li>主机 m.xyz.com 先向其本地域名服务器 dns.xyz.com 进行递归查询。</li><li>本地域名服务器采用迭代查询。它先向一个根域名服务器查询。</li><li>根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器 dns.com 的 IP 地址。</li><li>本地域名服务器向顶级域名服务器 dns.com 进行查询。</li><li>顶级域名服务器 dns.com 告诉本地域名服务器，下一次应查询的权限域名服务器 dns.abc.com 的 IP 地址。</li><li>本地域名服务器向权限域名服务器 dns.abc.com 进行查询。</li><li>权限域名服务器 dns.abc.com 告诉本地域名服务器，所查询的主机的IP地址本地域名服务器最后把查询结果告诉主机 m.xyz.com。</li></ol><p>这 8 个步骤总共要使用 8 个 UDP 用户数据报的报文。本地域名服务器经过三次迭代查询后，从权限域名服务器 dns.abc.com 得到了主机 y.abc.com 的 IP 地址，最后把结果返回给发起查询的主机 m.xyz.com。</p><p>为了提高 DNS 查询效率，并减轻根域名服务器的负荷和减少互联网上的 DNS 查询报文数量，在域名服务器中广泛地使用了<strong>高速缓存</strong>（有时也称为<strong>高速缓存域名服务器</strong>）。<strong>高速缓存</strong>用来存放<strong>最近查询过的域名以及从何处获得域名映射</strong>信息的记录。</p><h1 id="2-文件传送协议"><a href="#2-文件传送协议" class="headerlink" title="2.文件传送协议"></a>2.文件传送协议</h1><h2 id="2-1-FTP-概述"><a href="#2-1-FTP-概述" class="headerlink" title="2.1 FTP 概述"></a>2.1 FTP 概述</h2><p>文件传送协议 FTP（File Transfer Protocol）[RFC 959] 是互联网上使用得最广泛的文件传送协议。有基于 TCP 的 FTP 和基于 UDP 的简单文件传送协议 TFTP，它们都是文件共享协议中的一大类，即<strong>复制整个文件</strong>，其特点是：</p><ol><li>若要存取一个文件，就必须先获得一个本地的文件副本。</li><li>如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件副本传回到原节点。</li></ol><h2 id="2-2-FTP-的基本工作原理"><a href="#2-2-FTP-的基本工作原理" class="headerlink" title="2.2 FTP 的基本工作原理"></a>2.2 FTP 的基本工作原理</h2><p>文件传送协议 FTP <strong>只提供文件传送的一些基本的服务</strong>，它使用 <strong>TCP 可靠的运输服务</strong>。</p><p>FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。<strong>FTP 的服务器进程由两大部分组成：</strong></p><ol><li>一个主进程，负责接受新的请求；</li><li>另外有若干个从属进程，负责处理单个请求。</li></ol><p><strong>主进程的工作步骤如下：</strong></p><ol><li>打开熟知端口<strong>（端口号为21）</strong>，使客户进程能够连接上。</li><li>等待客户进程发出连接请求。</li><li>启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。</li><li>回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发进行的。</li></ol><p><img src="/../img/post/computer-network/6-6.jpg"></p><p>网络文件系统 NFS 则采用另一种思路。NFS 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。这样，NFS 可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</p><h2 id="2-3-简单文件传送协议-TFTP"><a href="#2-3-简单文件传送协议-TFTP" class="headerlink" title="2.3 简单文件传送协议 TFTP"></a>2.3 简单文件传送协议 TFTP</h2><p>TCP&#x2F;IP 协议族中还有一个简单文件传送协议 TFTP（Trivial File Transfer Protocol），它是一个很小且易于实现的文件传送协议。它使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。TFTP 只支持文件传输而不支持交互，没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</p><p><strong>TFTP 的主要优点有两个：</strong></p><ol><li>TFTP 可用于 UDP 环境；</li><li>TFTP 代码所占的内存较小。</li></ol><p><strong>TFTP 的主要特点是：</strong></p><ol><li>每次传送的数据报文中有 512 字节的数据，但最后一次可不足 512 字节。</li><li>数据报文按序编号，从 1 开始。</li><li>支持 ASCII 码或二进制传送。</li><li>可对文件进行读或写。</li><li>使用很简单的首部。</li></ol><p><strong>注意：</strong></p><ol><li><strong>端口号码为 69</strong>。</li><li>若文件长度恰好为 512 字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据报文。</li><li>若文件长度不是 512 字节的整数倍，则最后传送数据报文中的数据字段一定不满 512 字节，这正好可作为文件结束的标志。</li></ol><h1 id="3-远程终端协议-TELNET"><a href="#3-远程终端协议-TELNET" class="headerlink" title="3.远程终端协议 TELNET"></a>3.远程终端协议 TELNET</h1><p>TELNET 是一个简单的远程终端协议，它也是互联网的正式标准。通过 TCP 连接，NVT 格式转换。与现在的“远程桌面连接”相似，现在很少使用了。</p><h1 id="4-万维网-www"><a href="#4-万维网-www" class="headerlink" title="4.万维网 www"></a>4.万维网 www</h1><h2 id="4-1-万维网概述"><a href="#4-1-万维网概述" class="headerlink" title="4.1 万维网概述"></a>4.1 万维网概述</h2><p>万维网 www（World Wide Web）并非某种特殊的计算机网络。</p><ol><li><p>万维网是一个大规模的、联机式的信息储藏所。</p></li><li><p>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点（也就是所谓的“链接到另一个站点”），从而主动地按需获取丰富的信息。</p></li><li><p>万维网提供分布式服务。</p><p><img src="/../img/post/computer-network/6-7.jpg"></p></li><li><p>万维网使用统一资源定位符URL（Uniform Resource Locator）来标志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符 URL。</p></li><li><p>超文本传送协议 HTTP（HyperText Transfer Protocol），是一个应用层协议，它使用 TCP 连接进行可靠的传送。</p></li><li><p>万维网使用超文本标记语言 HTML（HyperText Markup Language）。</p></li></ol><h2 id="4-2-统一资源定位符-URL"><a href="#4-2-统一资源定位符-URL" class="headerlink" title="4.2 统一资源定位符 URL"></a>4.2 统一资源定位符 URL</h2><h3 id="4-2-1-URL-的格式"><a href="#4-2-1-URL-的格式" class="headerlink" title="4.2.1 URL 的格式"></a>4.2.1 URL 的格式</h3><p>URL 的一般形式由以下四个部分组成：</p><p>$$<br>&lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;<br>$$</p><h3 id="4-2-2-使用-HTTP-的-URL"><a href="#4-2-2-使用-HTTP-的-URL" class="headerlink" title="4.2.2 使用 HTTP 的 URL"></a>4.2.2 使用 HTTP 的 URL</h3><p>HTTP 的 URL 的一般形式是：</p><p>$$<br>http:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;<br>$$</p><p>URL 里面的 &lt;协议&gt;、&lt;主机&gt;，字母不区分大小写，但 &lt;路径&gt; 有时要区分大小写。</p><h2 id="4-3-超文本传送协议-HTTP"><a href="#4-3-超文本传送协议-HTTP" class="headerlink" title="4.3 超文本传送协议 HTTP"></a>4.3 超文本传送协议 HTTP</h2><h3 id="4-3-1-HTTP-的操作过程"><a href="#4-3-1-HTTP-的操作过程" class="headerlink" title="4.3.1 HTTP 的操作过程"></a>4.3.1 HTTP 的操作过程</h3><p>HTTP 是面向事务的（transaction-oriented）应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。请注意，HTTP 不仅传送完成超文本跳转所必需的信息，而且也传送任何可从互联网上得到的信息，如文本、超文本、声音和图像等。</p><p><img src="/../img/post/computer-network/6-8.jpg"></p><ol><li>建立 TCP 连接</li><li>浏览器（万维网客户）发出请求“HTTP 请求报文”</li><li>服务器返回响应“HTTP 响应报文”</li><li>释放 TCP 连接</li></ol><h3 id="4-3-2-HTTP-的特点"><a href="#4-3-2-HTTP-的特点" class="headerlink" title="4.3.2 HTTP 的特点"></a>4.3.2 HTTP 的特点</h3><ol><li>HTTP 规定在 HTTP 客户与 HTTP 服务器之间的每次交互，都由一个 ASCII 码串构成的请求和一个类似的通用互联网扩充，即“类 MIME（MIME-like）”的响应组成。</li><li>HTTP 使用了面向连接的 TCP 作为运输层协议，保证了数据的可靠传输。HTTP 不必考虑数据在传输过程中被丢弃后又怎样被重传。但是，HTTP 协议本身是无连接的。这就是说，虽然 HTTP 使用了 TCP 连接，但通信的双方在交换 HTTP 报文之前不需要先建立HTTP连接。</li><li>HTTP 协议是无状态的（stateless）。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同（假定现在服务器还没有把该页面更新)。HTTP 的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的 HTTP 请求。</li></ol><p><img src="/../img/post/computer-network/6-9.jpg"></p><p>请求一个万维网文档所需的时间是该文档的传输时间（与文档大小成正比）加上<strong>两倍往返时间 RTT（一个 RTT 用于连接 TCP 连接，另一个 RTT 用于请求和接收万维网文档）</strong>。</p><ul><li><strong>HTTP&#x2F;1.0 的主要缺点，</strong>就是每请求一个文档就要有两倍RTT的开销。</li><li><strong>HTTP&#x2F;1.1 协议</strong>较好地解决了这个问题，它使用了<strong>持续连接</strong>（persistent connection）。所谓持续连接就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，有两种工作方式：<ul><li><strong>非流水线方式：</strong>是客户在收到前一个响应后才能发出下一个请求。客户每访问一次对象都要用去一个往返时间 RTT。</li><li>流水线方式：客户访问所有的对象只需花费一个 RTT 时间。</li></ul></li></ul><h3 id="4-3-3-代理服务器"><a href="#4-3-3-代理服务器" class="headerlink" title="4.3.3 代理服务器"></a>4.3.3 代理服务器</h3><p>代理服务器（proxy server）是一种网络实体，它又称为万维网高速缓存（Web cache）。把最近的一些请求和响应暂存在本地磁盘中，不需要按 URL 的地址再次去互联网访问该资源。</p><ul><li><strong>有缓存：</strong>就暂存相应返回</li><li><strong>无缓存：</strong>代理服务器就去请求</li></ul><p><img src="/../img/post/computer-network/6-10.jpg"></p><h3 id="4-3-4-HTTP-的报文结构"><a href="#4-3-4-HTTP-的报文结构" class="headerlink" title="4.3.4 HTTP 的报文结构"></a>4.3.4 HTTP 的报文结构</h3><p><strong>HTTP 有两类报文：</strong></p><ol><li><strong>请求报文：</strong>从客户向服务器发送请求报文。</li><li><strong>响应报文：</strong>从服务器到客户的回答。</li></ol><p><img src="/../img/post/computer-network/6-11.jpg"></p><p>由于 HTTP 是面向文本的（text-oriented），因此在报文中的每一个字段都是一些 ASCII 码串，因而各个字段的长度都是不确定的。HTTP 请求报文和响应报文都是由三个部分组成的。可以看出，这两种报文格式的区别就是开始行不同。</p><ol><li><strong>开始行：</strong>用于区分是请求报文还是响应报文。在请求报文中的开始行叫做请求行（Request-Line），而在响应报文中的开始行叫做状态行（Status-Line）。在开始行的三个字段之间都以空格分隔开，最后的“CR”和“LF”分别代表“回车”和“换行”。</li><li><strong>首部行：</strong>用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。在每一个首部行中都有首部字段名和它的值，每一行在结束的地方都要有“回车”和“换行”。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。</li><li><strong>实体主体（entity body）：</strong>在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段。</li></ol><p>下面先介绍 HTTP 请求报文的一些主要特点。请求报文的第一行<strong>“请求行”</strong>只有三个内容，即<strong>方法</strong>，<strong>请求资源的 URL</strong>，以及 <strong>HTTP 的版本</strong>。</p><p><img src="/../img/post/computer-network/6-12.jpg"></p><p>每一个请求报文发出后，都能收到一个响应报文。响应报文的第一行就是状态行。</p><ul><li>1xx 表示通知信息，如请求收到了或正在进行处理。</li><li>2xx 表示成功，如接受或知道了。</li><li>3xx 表示重定向，如要完成请求还必须采取进一步的行动。</li><li>4xx 表示客户的差错，如请求中有错误的语法或不能完成。</li><li>5xx 表示服务器的差错，如服务器失效无法完成请求。</li></ul><h3 id="4-3-5-在服务器上存放用户的信息"><a href="#4-3-5-在服务器上存放用户的信息" class="headerlink" title="4.3.5 在服务器上存放用户的信息"></a>4.3.5 在服务器上存放用户的信息</h3><p>HTTP 是无状态的，但可以用 cookie（小小的文本文件），给用户一个唯一的识别码，在HTTP 响应报文中添加一个 <strong>Set-cookies</strong> 的首部行。</p><h2 id="4-4-万维网的文档"><a href="#4-4-万维网的文档" class="headerlink" title="4.4 万维网的文档"></a>4.4 万维网的文档</h2><p>超文本标记语言 HTML（HyperText Markup Language）就是一种制作万维网页面的标准语言，它消除了不同计算机之间信息交流的障碍。但请注意，<strong>HTML 并不是应用层的协议，它只是万维网浏览器使用的一种语言</strong>。</p><ul><li>动态万维网文档：CGI 创建动态文档</li><li>活动万维网文档：如 Java 小应用嵌入 HTML</li></ul><h2 id="4-5-万维网的信息检索系统"><a href="#4-5-万维网的信息检索系统" class="headerlink" title="4.5 万维网的信息检索系统"></a>4.5 万维网的信息检索系统</h2><p><strong>全文检索搜索与分类目录搜索：</strong></p><ol><li><strong>全文检索搜索：</strong>利用 Spider（如 Google）</li><li><strong>分类目录搜索：</strong>不采集任何信息，人工审核编辑录入（如 SCI、图书馆）</li></ol><h1 id="5-电子邮件"><a href="#5-电子邮件" class="headerlink" title="5.电子邮件"></a>5.电子邮件</h1><h2 id="5-1-电子邮件概述"><a href="#5-1-电子邮件概述" class="headerlink" title="5.1 电子邮件概述"></a>5.1 电子邮件概述</h2><p><strong>一个电子邮件系统应具有三个主要组成构件：</strong></p><ol><li>用户代理</li><li>邮件服务器（邮件服务器必须同时充当客户和服务器）</li><li>邮件发送协议（如SMTP）和邮件读取协议（如 POP3）</li></ol><p><img src="/../img/post/computer-network/6-13.jpg"></p><p><strong>用户代理 UA（User Agent)）</strong>就是用户与电子邮件系统的接口，在大多数情况下它就是运行在用户电脑中的一个程序。用户代理至少应当具有以下 4 个功能：</p><ol><li><strong>撰写：</strong>给用户提供编辑信件的环境。</li><li><strong>显示：</strong>能方便地在计算机屏幕上显示出来信（包括来信附上的声音和图像）。</li><li><strong>处理：</strong>处理包括发送邮件和接收邮件。</li><li><strong>通信：</strong>发信人在撰写完邮件后，要利用邮件发送协议发送到用户所使用的邮件服务器。收件人在接收邮件时，要使用邮件读取协议从本地邮件服务器接收邮件。</li></ol><h2 id="5-2-简单邮件传送协议-SMTP"><a href="#5-2-简单邮件传送协议-SMTP" class="headerlink" title="5.2 简单邮件传送协议 SMTP"></a>5.2 简单邮件传送协议 SMTP</h2><p>SMTP 规定了在两个相互通信的 SMTP 进程之间应如何交换信息。由于 SMTP 使用客户服务器方式，因此负责发送邮件的 SMTP 进程就是 SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。至于邮件内部的格式，邮件如何存储，以及邮件系统应以多快的速度来发送邮件，SMTP 也都未做出规定。</p><p>下面通过发送方和接收方的邮件服务器之间的 SMTP 通信的三个阶段介绍几个最主要的命令和响应信息:</p><ol><li><strong>连接建立：</strong>SMTP 的熟知端口号码 25 与接收方邮件服务器的 SMTP 服务器建立 TCP 连接。<strong>SMTP不使用中间的邮件服务器。</strong></li><li><strong>邮件传送：</strong><ol><li>邮件的传送从 <strong>MAIL 命令</strong>开始。</li><li><strong>SMTP：</strong>250 ok，已准备好接收。</li><li><strong>RCPT 命令：</strong>弄清接收方系统是否已做好接收邮件的准备，然后才发送邮。</li><li><strong>DATA 命令：</strong>表示要开始传送邮件的内容了。</li></ol></li><li><strong>连接释放：</strong>SMTP 客户应发送OUIT 命令，SMTP服务器返回的信息是 221。</li></ol><h2 id="5-3-电子邮件的信息格式"><a href="#5-3-电子邮件的信息格式" class="headerlink" title="5.3 电子邮件的信息格式"></a>5.3 电子邮件的信息格式</h2><p>一个电子邮件分为<strong>信封</strong>和<strong>内容</strong>两大部分，而对邮件的<strong>主体</strong>部分则让用户自由撰写。</p><ul><li><strong>To：</strong>后面填入一个或多个收件人的电子邮件地址。</li><li><strong>Subject：</strong>是邮件的主题。它反映了邮件的主要内容。</li><li><strong>抄送 Cc：</strong>留下一个复写副本。</li></ul><h2 id="5-4-邮件读取协议-POP3-和-IMAP"><a href="#5-4-邮件读取协议-POP3-和-IMAP" class="headerlink" title="5.4 邮件读取协议 POP3 和 IMAP"></a>5.4 邮件读取协议 POP3 和 IMAP</h2><ol><li><strong>POP3：</strong>简单但功能有限，读取就删除。</li><li><strong>IMAP：</strong>由附存与 IMAP 服务器上。</li></ol><p><img src="/../img/post/computer-network/6-14.jpg"></p><p>最后再强调一下，不要把邮件读取协议 POP3 或 IMAP 与邮件传送协议 SMTP 弄混。<strong>发件人的用户代理向发送方邮件服务器发送邮件，以及发送方邮件服务器向接收方邮件服务器发送邮件，都是使用 SMTP 协议。</strong>而 <strong>POP3 或 IMAP 则是用户代理从接收方邮件服务器上读取邮件所使用的协议</strong>。</p><h2 id="5-5-基于万维网的电子邮件"><a href="#5-5-基于万维网的电子邮件" class="headerlink" title="5.5 基于万维网的电子邮件"></a>5.5 基于万维网的电子邮件</h2><p>用户无需安装代理软件 UA。微软 Hotmail 推出了基于万维网的电子邮件。</p><p>用户在浏览器中浏览各种信息时需要使用 HTTP 协议。因此，在浏览器和互联网上的邮件服务器之间传送邮件时，仍然使用 HTTP 协议。但是在各邮件服务器之间传送邮件时，则仍然使用 SMTP 协议。</p><h2 id="5-6-通用互联网邮件扩充-MIME"><a href="#5-6-通用互联网邮件扩充-MIME" class="headerlink" title="5.6 通用互联网邮件扩充 MIME"></a>5.6 通用互联网邮件扩充 MIME</h2><h3 id="5-6-1-MIME-概述"><a href="#5-6-1-MIME-概述" class="headerlink" title="5.6.1 MIME 概述"></a>5.6.1 MIME 概述</h3><p><strong>电子邮件协议 SMTP 有以下缺点：</strong></p><ol><li>不能传送可执行文件或其他的二进制对象。</li><li>SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字无法传送。</li><li>SMTP 服务器会拒绝超过一定长度的邮件。</li><li>某些 SMTP 的实现并没有完全按照 SMTP 的互联网标准。</li></ol><p>于是在这种情况下就提出了<strong>通用互联网邮件扩充 MIME</strong> [RFC 2045 ~2049]。</p><p>MIME 的意图是继续使用原来的邮件格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。也就是说，MIME 邮件可在现有的电子邮件程序和协议下传送。</p><p><img src="/../img/post/computer-network/6-15.jpg"></p><p><strong>MIME 主要包括以下三部分内容：</strong></p><ol><li>5 个新的邮件首部字段，它们可包含在原来的邮件首部中。这些字段提供了有关邮件主体的信息。</li><li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li><li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li></ol><p><strong>MIME 增加的 5 个新的邮件首部的名称及其意义：</strong></p><ol><li><strong>MIME-Version：</strong>标志 MIME 的版本。若无此行，则为英文文本。</li><li><strong>Content-Description：</strong>这是可读字符串，说明此邮件主体是否是图像、音频或视频。</li><li><strong>Content-Id：</strong>邮件的唯一标识符。</li><li><strong>Content-Transfer-Encoding：</strong>在传送时邮件的主体是如何编码的。</li><li><strong>Content-Type：</strong>说明邮件主体的数据类型和子类型。</li></ol><h3 id="5-6-2-内容传送编码（Content-Transfer-Encoding）"><a href="#5-6-2-内容传送编码（Content-Transfer-Encoding）" class="headerlink" title="5.6.2 内容传送编码（Content-Transfer-Encoding）"></a>5.6.2 内容传送编码（<strong>Content-Transfer-Encoding）</strong></h3><p>最简单的编码就是 7 位 ASCII 码，而每行不能超过 1000 个字符。MIME 对这种由 ASCII 码构成的邮件主体不进行任何转换。</p><p>另一种编码称为 quoted-printable，这种编码方法适用于所传送的数据中只有少量的非 ASCII 码，例如汉字、特殊字符。</p><p>对于任意的二进制文件，可用 base64 编码。这种编码方法是先把二进制代码划分为一个个 24 位长的单元，然后把每一个 24 位单元划分为 4 个 6 位组。每一个 6 位组按以下方法转换成 ASCII 码。6 位的二进制代码共有 64 种不同的值，从 0 到 63。用 A 表示 0，用 B 表示1，等等。<strong>26 个大写字母</strong>排列完毕后，接下去再排 <strong>26 个小写字母</strong>，再后面是 <strong>10 个数字</strong>，最后用 <strong><code>+</code> 表示 62</strong>，而用 <strong><code>/</code> 表示63</strong>。再用两个连在一起的等号 <code>==</code> 和一个等号 <code>=</code> 分别表示最后一组的代码只有 8 位或 16 位。回车和换行都忽略，它们可在任何地方插入。</p><p><img src="/../img/post/computer-network/6-16.jpg"></p><h3 id="5-6-3-内容类型"><a href="#5-6-3-内容类型" class="headerlink" title="5.6.3 内容类型"></a>5.6.3 内容类型</h3><p>MIME 标准规定 Content-Type 说明必须含有两个标识符，即<strong>内容类型（type）</strong>和<strong>子类型（subtype）</strong>，中间用 <code>/</code> 分开。</p><p><strong>MIME 标准原先定义了 7 个基本内容类型和 15 种子类型：</strong></p><p><img src="/../img/post/computer-network/6-17.jpg"></p><p>MIME 的内容类型中的 multipart 是很有用的，因为它使邮件增加了相当大的灵活性。<strong>MIME 标准为 multipart 定义了四种可能的子类型，每个子类型都提供重要功能：</strong></p><ol><li>mixed 子类型允许单个报文含有多个相互独立的子报文，每个子报文可有自己的类型和编码。mixed 子类型报文使用户能够在单个报文中附上文本、图形和声音，或者用额外数据段发送一个备忘录，类似商业信笺含有的附件。</li><li>alternative 子类型允许单个报文含有同一数据的多种表示。当给多个使用不同硬件和软件系统的收件人发送备忘录时，这种类型的 multipart 报文很有用。例如，用户可同时用普通的 ASCII 文本和格式化的形式发送文本，从而允许拥有图形功能的计算机用户在查看图形时选择格式化的形式。</li><li>parallel 子类型允许单个报文含有可同时显示的各个子部分（例如，图像和声音子部分必须一起播放）。</li><li>digest 子类型允许单个报文含有一组其他报文（如从讨论中收集电子邮件报文）。</li></ol><h1 id="6-动态主机配置协议-DHCP"><a href="#6-动态主机配置协议-DHCP" class="headerlink" title="6.动态主机配置协议 DHCP"></a>6.动态主机配置协议 DHCP</h1><p><strong>动态主机配置协议 DHCP</strong>（Dynamic Host Configuration Protocol），它提供了一种机制，称为即<strong>插即用连网</strong>（plug-and-play networking）。这种机制允许一台计算机加入新的网络和获取 IP 地址而不用手工参与。</p><p>DHCP 对运行客户软件和服务器软件的计算机都适用。当运行客户软件的计算机移至一个新的网络时，就可使用 DHCP 获取其配置信息而不需要手工干预。DHCP 给运行服务器软件而位置固定的计算机指派一个永久地址，而当这计算机重新启动时其地址不改变。</p><p>但是我们并不愿意在每一个网络上都设置一个 DHCP 服务器，因为这样会使 DHCP 服务器的数量太多。因此现在是使每一个网络至少有一个 <strong>DHCP 中继代理</strong>（relay agent），它配置了 DHCP 服务器的 IP 地址信息。当 DHCP 中继代理收到主机 A 以广播形式发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再把此提供报文发回给主机 A。</p><blockquote><aside></blockquote><p><img src="/../img/post/computer-network/6-18.jpg"></p><p>DHCP 服务器分配给 DHCP 客户的 IP 地址是临时的，因此 DHCP 客户只能在段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为<strong>租用期</strong>（lease period），但并没有具体规定租用期应取为多长或至少为多长，这个数值应由 DHCP 服务器自己决定。</p><p><strong>DHCP 的详细工作过程如图：</strong></p><ul><li>DHCP 客户使用的 <strong>UDP 端口是 68</strong></li><li>DHCP 服务器使用的 <strong>UDP 端口是 67</strong></li></ul><p><img src="/../img/post/computer-network/6-19.jpg"></p><ol><li>DHCP <strong>服务器被动打开 UDP 端口 67</strong>，等待客户端发来的报文。</li><li>DHCP <strong>客户从 UDP 端口 68 发送 DHCP 发现报文</strong>。</li><li>凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文，因此 DHCP 客户可能收到多个 DHCP 提供报文。</li><li>DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文。</li><li>被选择的 DHCP 服务器发送<strong>确认报文 DHCPACK</strong>。<strong>从这时起，DHCP 客户就可以使用这个 IP 地址了</strong>。这种状态叫做<strong>已绑定状态</strong>，因为在 DHCP 客户端的 IP 地址和硬件地址已经完成绑定，并且可以开始使用得到的临时 IP 地址了。DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是0.5T 和 0.875T。<strong>当超时时间到了就要请求更新租用期。</strong></li><li>租用期过了一半（T1时间到），<strong>DHCP 发送请求报文 DHCPREQUEST 要求更新租用期</strong>。</li><li>DHCP 服务器若<strong>同意</strong>，则发回<strong>确认报文 DHCPACK</strong>。 DHCP 客户得到了新的租用期，重新设置计时器。</li><li>DHCP 服务器若<strong>不同意</strong>，则发回<strong>否认报文 DHCPNACK</strong>。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤2)。若 DHCP 服务器不响应步骤 6 的请求报文 DHCPREQUEST，则在租用期过了 87.5% 时（T2时间到），DHCP 客户必须重新发送请求报文 DHCPREQUEST （重复步骤6），然后又继续后面的步骤。</li><li>DHCP 客户可以随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送<strong>释放报文 DHCPRELEASE</strong> 即可。</li></ol><h1 id="7-简单网络管理协议-SNMP"><a href="#7-简单网络管理协议-SNMP" class="headerlink" title="7.简单网络管理协议 SNMP"></a>7.简单网络管理协议 SNMP</h1><h2 id="7-1-网络管理的基本概念"><a href="#7-1-网络管理的基本概念" class="headerlink" title="7.1 网络管理的基本概念"></a>7.1 网络管理的基本概念</h2><p>网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能、服务质量等。网络管理常简称为网管。</p><p>网络是一个非常复杂的分布式系统。这是因为网络上有很多不同家生产的、运行看多种协议的结点（主要是路由器），而这些结点还在相互通信和交换信息。网络的状态总是不断地变化着。可见，我们必须使用一种机制来读取这些结点上的状态信息，有时还要把一些新的状态信息写入到这些结点上。</p><h3 id="7-1-1-网络管理模型中的主要构件"><a href="#7-1-1-网络管理模型中的主要构件" class="headerlink" title="7.1.1 网络管理模型中的主要构件"></a>7.1.1 网络管理模型中的主要构件</h3><p>管理站又称为管理器，是整个网络管理系统的核心，它通常是个有着良好图形界面的高性能的工作站，并由网络管理员直接操作和控制。所有向被管设备发送的命令都是从管理站发出的。</p><p>管理站的所在部门也常称为<strong>网络运行中心 NOC</strong>（Network Operations Center）。<strong>管理站中的关键构件是管理程序，管理程序在运行时就成为管理进程。</strong>管理站（硬件）或管理程序（软件）都可称为管理者或管理器。网络管理员（administrator）才是指人。</p><p><img src="/../img/post/computer-network/6-20.jpg"></p><p>在被管网络中有很多的被管设备（包括设备中的软件）。被管设备可以是主机、路由器、打印机、集线器、网桥或调制解调器等。在每一个被管设备中可能有许多被管对象（Managed Object）。被管对象可以是被管设备中的某个硬件（例如，一块网络接口卡），也可以是某些硬件或软件（例如，路由选择协议）的配置参数的集合。<strong>被管设备有时可称为网络元素或简称为网元。在被管设备中也会有一些不能被管的对象（所谓不能被管的对象就是不在对象命名树上的对象）。</strong></p><h3 id="7-1-2-简单网络管理协议-SNMP"><a href="#7-1-2-简单网络管理协议-SNMP" class="headerlink" title="7.1.2 简单网络管理协议 SNMP"></a>7.1.2 简单网络管理协议 SNMP</h3><p>简单网络管理协议 SNMP（Simple Network Management Protocol）中的<strong>管理程序和代理程序按客户服务器方式工作。管理程序运行 SNMP 客户程序，而代理程序运行 SNMP 服务器程序。</strong></p><blockquote><p>💡 若要管理某个对象，就必然会给该对象添加一些软件或硬件，但这种“添加”对原有对象的影响必须尽量小些。</p></blockquote><p><strong>SNMP 的网络管理由三个部分组成：</strong></p><ol><li>SNMP 本身</li><li>管理信息结构 SMI（Structure of Management Information）</li><li>管理信息库 MIB（Management Information Base）</li></ol><ul><li>SNMP 定义了管理站和代理之间所交换的分组格式。所交换的分组包含各代理中的对象（变量）名及其状态（值）。SNMP 负责读取和改变这些数值。</li><li>SMI 定义了命名对象和定义对象类型（包括范围和长度）的通用规则，以及把对象和寸象的值进行编码的规则。</li><li>MIB 在被管理的实体中创建了命名对象，并规定了其类型。</li></ul><p>总之，SMI 建立规则，MIB 对变量进行说明，而 SNMP 完成网管的动作。</p><h2 id="7-2-管理信息结构-SMI"><a href="#7-2-管理信息结构-SMI" class="headerlink" title="7.2 管理信息结构 SMI"></a>7.2 管理信息结构 SMI</h2><p>管理信息结构 SMI 是 SNMP 的重要组成部分。SMI的功能应当有三个：</p><ol><li>被管对象应怎样命名；</li><li>用来存储被管对象的数据类型有哪些；</li><li>在网络上传送的管理数据应如何编码。</li></ol><h3 id="7-2-1-被管对象的命名"><a href="#7-2-1-被管对象的命名" class="headerlink" title="7.2.1 被管对象的命名"></a>7.2.1 被管对象的命名</h3><p>SMI 规定，所有的被管对象都必须处在对象命名树（object naming tree）上。</p><p>对象命名树的根没有名字，它的下面有三个顶级对象，都是世界上著名的标准制定单位，即 ITU-T，ISO，以及这两个组织的联合体，它们的标号分别是 0 到 2。标号为 3 的节点是 ISO 认同的的组织成员 org。在其下面有一个美国国防部 dod 的子树（标号为 6），再下面就是 internet（标号为 1)。在只讨论 internet 中的对象时，可只画出 internet 以下的子树，并在 internet 节点旁边写上对象标识符 1.3.6.1 即可。</p><p><img src="/../img/post/computer-network/6-21.jpg"></p><p>在 internet 节点下面的标号为 2 的节点是 mgmt（管理）。再下面只有一个节点，即管理信息库 mib-2，其对象标识符为 1.3.6.1.2.1。在 mib-2 下面包含了所有被 SNMP 管理的对象（见下面7.2.2）。</p><h3 id="7-2-2-被管对象的数据类型"><a href="#7-2-2-被管对象的数据类型" class="headerlink" title="7.2.2 被管对象的数据类型"></a>7.2.2 被管对象的数据类型</h3><p>SMI 使用基本的抽象语法记法 1（即 ISO 制定的 ASN.1R）来定义数据类型，但又增加了一些新的定义。因此 SMI 既是 ASN.1 的子集，又是 ASN.1 的超集。ASN.1 的记法很严格，它使得数据的含义不存在任何可能的二义性。</p><p><strong>SMI 把数据类型分为两大类：</strong></p><ol><li><strong>简单类型：</strong>简单类型是最基本的、直接使用ASN.1定义的类型。</li><li><strong>结构化类型</strong></li></ol><p><img src="/../img/post/computer-network/6-22.jpg"></p><p>SMI 定义了两种结构化数据类型，即 sequence 和 sequence of。</p><h3 id="7-2-3-编码方法"><a href="#7-2-3-编码方法" class="headerlink" title="7.2.3 编码方法"></a>7.2.3 编码方法</h3><p>SMI 使用 ASN.1 制定的基本编码规则 BER（Basic Encoding Rule）进行数据的编码。BER 指明了每种数据的类型和值。在发送端用 BER 编码，可把用 ASN.1 所表述的报文转换成唯一的比特序列。在接收端用 BER 进行解码，就可得到该比特序列所表示的 ASN.1 报文。</p><p><strong>ASN.1 把所有的数据元素都表示为 T-L-V 三个字段组成的序列：</strong></p><ul><li><strong>T 字段（Tag）：</strong>定义数据的类型，又分为三个子字段：<ul><li><strong>类别（2位）：</strong>共四种：<ul><li><strong>通用类（00）：</strong>即 ASN.1 定义的类型；</li><li><strong>应用类（01）：</strong>即 SMI 定义的类型；</li><li><strong>上下文类（10）：</strong>即上下文所定义的类型；</li><li><strong>专用类（11）：</strong>保留为特定厂商定义的类型；</li></ul></li></ul></li><li><strong>L 字段（Length）：</strong>定义 V 字段的长度</li><li><strong>V 字段（Value）：</strong>用于定义数据元素的值。</li></ul><p><img src="/../img/post/computer-network/6-23.jpg"></p><h2 id="7-3-管理信息库-MIB"><a href="#7-3-管理信息库-MIB" class="headerlink" title="7.3 管理信息库 MIB"></a>7.3 管理信息库 MIB</h2><p>所谓“管理信息”就是指在互联网的网管框架中被管对象的集合。被管对象必须维持可供管理程序读写的若干控制和状态信息。这些被管对象构成了一个虚拟的信息存储器，所以才称为管理信息库 MIB。</p><h2 id="7-4-SNMP-的协议数据单元和报文"><a href="#7-4-SNMP-的协议数据单元和报文" class="headerlink" title="7.4 SNMP 的协议数据单元和报文"></a>7.4 SNMP 的协议数据单元和报文</h2><p>实际上，SNMP 的操作只有两种基本的管理功能，即：</p><ul><li><strong>“读”操作：</strong>用 Get 报文来检测各被管对象的状况</li><li><strong>“写”操作：</strong>用 Set 报文来改变各被管对象的状况</li></ul><p>SNMP 的这些功能通过<strong>探询</strong>操作来实现，即 SNMP 管理进程定时向被管理设备周期性地发送探询信息。</p><p>SNMP 使用无连接的 UDP，因此在网络上传送 SNMP 报文的开销较小。但 UDP 是不保证可靠交付的。这里还要指出，SNMP使用UDP 的方法有些特殊。在运行代理程序的<strong>服务器端用熟知端口 161 来接收 Get 或 Set 报文和发送响应报文</strong>（与熟知端口通信的客户端使用临时端口），<strong>但运行管理程序的客户端则使用熟知端口 162 来接收来自各代理的 trap 报文</strong>。</p><p>和大多数 TCP&#x2F;IP 协议不一样，SNMP 报文没有固定的字段。相反，它们使用标准ASN.1 编码。</p><p><img src="/../img/post/computer-network/6-24.jpg"></p><ol><li><strong>请求标识符（request ID）：</strong>由管理进程设置的4字节整数值。</li><li><strong>差错状态（error status）：</strong>在请求报文中，这个字段是 0。当代理进程响应时，就填入 0~18（例如 0表示 noError 一切正常，1 表示t ooBig 代理无法把回答装入一个 SNMP 报文中）</li><li><strong>差错索引（error index）：</strong>在请求报文中，这个字段是零。当代理进程响应时，代理进程就设置一个整数，指明有差错的变量在变量列表中的偏移。</li><li><strong>变量绑定（variable-bindings）：</strong>指明一个或多个变量的名和对应的值。在请求报文中，变量的值应忽略（类型是 NULL）。</li></ol><h1 id="8-应用进程跨越网络的通信"><a href="#8-应用进程跨越网络的通信" class="headerlink" title="8.应用进程跨越网络的通信"></a>8.应用进程跨越网络的通信</h1><h2 id="8-1-系统调用和应用编程接口"><a href="#8-1-系统调用和应用编程接口" class="headerlink" title="8.1 系统调用和应用编程接口"></a>8.1 系统调用和应用编程接口</h2><p>大多数操作系统使用<strong>系统调用（system call）</strong>的机制在应用程序和操作系统之间传递控制权。</p><p><img src="/../img/post/computer-network/6-25.jpg"></p><p>当某个应用进程启动系统调用时，<strong>控制权就从应用进程传递给了系统调用接口</strong>。</p><p>系统调用接口又称为应用编程接口 API。</p><ul><li>Unix 定义了一种 API，称为套接字接口（socket interface）</li><li>Windows 采用了套接字接口 API，形成一个稍有不同的 Windows Socket</li></ul><p><img src="/../img/post/computer-network/6-26.jpg"></p><h2 id="8-2-几种常用的系统调用"><a href="#8-2-几种常用的系统调用" class="headerlink" title="8.2 几种常用的系统调用"></a>8.2 几种常用的系统调用</h2><h3 id="8-2-1-连接建立阶段"><a href="#8-2-1-连接建立阶段" class="headerlink" title="8.2.1 连接建立阶段"></a>8.2.1 连接建立阶段</h3><p><img src="/../img/post/computer-network/6-27.jpg"></p><p>在任一时刻，服务器中总是有一个主服务器进程和零个或多个从属服务器进程。主服务器进程用原来的套接字接受连接请求，而从属服务器进程用新创建的套接字和相应的客户建立连接并可进行双向传送数据。</p><h3 id="8-2-2-数据传送阶段"><a href="#8-2-2-数据传送阶段" class="headerlink" title="8.2.2 数据传送阶段"></a>8.2.2 数据传送阶段</h3><p><strong>调用 send 需要三个变量：</strong></p><ol><li>数据要发往的套接字的描述符</li><li>要发送的数据的地址</li><li>数据的长度</li></ol><p><strong>调用 recv 也需要三个变量：</strong></p><ol><li>要使用的套接字的描述符</li><li>缓存的地址</li><li>缓存空间的长度</li></ol><h3 id="8-2-3-连接释放阶段"><a href="#8-2-3-连接释放阶段" class="headerlink" title="8.2.3 连接释放阶段"></a>8.2.3 连接释放阶段</h3><p>一旦客户或服务器结束使用套接字，就把套接字撤销。这时就调用 close 释放连接和撤销套接字。</p><p><img src="/../img/post/computer-network/6-28.jpg"></p><p>UDP 服务器由于只提供无连接服务，因此不使用 listen 和 accept 系统调用。</p><h1 id="9-P2P-应用"><a href="#9-P2P-应用" class="headerlink" title="9.P2P 应用"></a>9.P2P 应用</h1><p>P2P 应用就是指具有 P2P 体系结构的网络应用。所谓 P2P 体系结构就是在这样的网络应用中，没有（或只有极少数的）固定的服务器，而绝大多数的交互都是使用对等方式（P2P 方式）进行的。</p><p>P2P 应用的范围很广，例如，文件分发、实时音频或视频会议、数据库系统、网络服务支持（如 P2P 打车软件、P2P 理财等）。</p><h2 id="9-1-具有集中目录服务器的-P2P-工作方式"><a href="#9-1-具有集中目录服务器的-P2P-工作方式" class="headerlink" title="9.1 具有集中目录服务器的 P2P 工作方式"></a>9.1 具有集中目录服务器的 P2P 工作方式</h2><p>最早使用 P2P 工作方式的是 Napster，具有集中目录服务器的工作方式。</p><h2 id="9-2-具有全分布式结构的-P2P-文件共享程序"><a href="#9-2-具有全分布式结构的-P2P-文件共享程序" class="headerlink" title="9.2 具有全分布式结构的 P2P 文件共享程序"></a>9.2 具有全分布式结构的 P2P 文件共享程序</h2><p>在第一代 P2P 文件共享网站 Napster 关闭后，开始出现了以 Gnutella 为代表的第二代P2P 文件共享程序。最大的区别就是不使用集中式的目录服务器进行查询，而是使用洪泛法在大量 Gnutella 用户之间进行查询。</p><p>第三代 P2P，如 eMule, Bit Torrent 等。</p><h2 id="9-3-P2P-文件分发的分析"><a href="#9-3-P2P-文件分发的分析" class="headerlink" title="9.3 P2P 文件分发的分析"></a>9.3 P2P 文件分发的分析</h2><p>在 P2P 方式下所有主机都下载完文件 F 的最少时间的下限是：</p><p>$$<br>T_{P2P} &gt;&#x3D; max{\frac{F}{u_s},\frac{F}{d_{min}},\frac{NF}{u_T} }<br>$$</p><h2 id="9-4-在-P2P-对等方中搜索对象"><a href="#9-4-在-P2P-对等方中搜索对象" class="headerlink" title="9.4 在 P2P 对等方中搜索对象"></a>9.4 在 P2P 对等方中搜索对象</h2><p>在 P2P 文件系统中，对等方用户的数量非常多，并且处于一种无序的状态。任何一个对等方可以随时加入进来或随时退出。怎样有效地找到所需的文件？可以利用<strong>散列函数</strong>来定位对等方。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络 第五章：运输层</title>
    <link href="/computer-network-5/"/>
    <url>/computer-network-5/</url>
    
    <content type="html"><![CDATA[<h1 id="1-运输层协议概述"><a href="#1-运输层协议概述" class="headerlink" title="1.运输层协议概述"></a>1.运输层协议概述</h1><h2 id="1-1-进程之间的通信"><a href="#1-1-进程之间的通信" class="headerlink" title="1.1 进程之间的通信"></a>1.1 进程之间的通信</h2><p>通信的真正端点并不是主机而是主机中的进程。运输层为应用进程之间提供端到端的逻辑通信，运输层还要对收到的报文进行差错检测。</p><p><img src="/../img/post/computer-network/5-1.jpg"></p><p>当运输层采用面向连接的 <strong>TCP 协议</strong>时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就<strong>相当于一条全双工的可靠信道</strong>。但当运输层采用无连接的 <strong>UDP 协议</strong>时，这种逻辑通信信道<strong>仍然是一条不可靠信道</strong>。</p><p><img src="/../img/post/computer-network/5-2.jpg"></p><h2 id="1-2-运输层的两个主要协议"><a href="#1-2-运输层的两个主要协议" class="headerlink" title="1.2 运输层的两个主要协议"></a>1.2 运输层的两个主要协议</h2><p>TCP&#x2F;IP 运输层的两个主要协议都是互联网的正式标准，即：</p><ul><li><strong>用户数据报协议 UDP</strong> (User Datagram Protocol)  [RFC 768]</li><li><strong>传输控制协议 TCP</strong> (Transmission Control Protocol) [RFC 793]</li></ul><p><img src="/../img/post/computer-network/5-3.jpg"></p><p>UDP 在传送数据之前不需要先建立连接。远地主机的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。</p><p>TCP 则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。</p><p><img src="/../img/post/computer-network/5-4.jpg"></p><h2 id="1-3-运输层的端口"><a href="#1-3-运输层的端口" class="headerlink" title="1.3 运输层的端口"></a>1.3 运输层的端口</h2><p>运输层使用协议端口号（protocol port number），或通常简称为端口（port）。虽然通信的终点是应用进程，但只要把所传送的报文交到目的主机的某个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 或 UDP 来完成。</p><p>由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且要知道对方的端口号（为了找到对方计算机中的应用进程）。</p><h3 id="1-3-1-服务器端使用的端口号"><a href="#1-3-1-服务器端使用的端口号" class="headerlink" title="1.3.1 服务器端使用的端口号"></a>1.3.1 服务器端使用的端口号</h3><p><strong>熟知端口号（系统端口号）：</strong>数值为0~1023。这些数值可在网址 <a href="http://www.iana.org/">www.iana.org</a> 查到。IANA 把这些端口号指派给了 TCP&#x2F;IP 最重要的一些应用程序，让所有的用户都知道。当一种新的应用程序出现后，IANA 必须为它指派一个熟知端口，否则互联网上的其他应用进程就无法和它进行通信。</p><p><img src="/../img/post/computer-network/5-5.jpg"></p><h3 id="1-3-2-客户端使用的端口号"><a href="#1-3-2-客户端使用的端口号" class="headerlink" title="1.3.2 客户端使用的端口号"></a>1.3.2 客户端使用的端口号</h3><p><strong>客户端使用的端口号（短暂端口号）：</strong>数值为 49152~65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。通信结束后，刚才已使用过的客户端口号就不复存在，这个端口号就可以供其他客户进程使用。</p><h1 id="2-用户数据报协议-UDP"><a href="#2-用户数据报协议-UDP" class="headerlink" title="2.用户数据报协议 UDP"></a>2.用户数据报协议 UDP</h1><h2 id="2-1-UDP-概述"><a href="#2-1-UDP-概述" class="headerlink" title="2.1 UDP 概述"></a>2.1 UDP 概述</h2><p>用户数据报协议 UDP 只在 IP 的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及差错检测的功能。UDP的主要特点是：</p><ol><li><p><strong>UDP 是无连接的</strong>，即发送数据之前不需要建立连接（当然，发送数据结束时也没有连接可释放），因此减少了开销和发送数据之前的时延。</p></li><li><p><strong>UDP 使用尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表（这里面有许多参数）。</p></li><li><p><strong>UDP 是面向报文的</strong>。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。</p><p><img src="/../img/post/computer-network/5-6.jpg"></p></li><li><p>UDP <strong>没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。</p></li><li><p>UDP 支持<strong>一对一</strong>、<strong>一对多</strong>、<strong>多对一</strong>和<strong>多对多</strong>的交互通信。</p></li><li><p>UDP 的<strong>首部开销小</strong>，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</p></li></ol><h2 id="2-2-UDP-的首部格式"><a href="#2-2-UDP-的首部格式" class="headerlink" title="2.2 UDP 的首部格式"></a>2.2 UDP 的首部格式</h2><p>用户数据报 UDP 有两个字段：<strong>数据字段</strong>和<strong>首部字段</strong>。</p><p><strong>首部字段</strong>很简单，只有 8 个字节，由 4个 字段组成，每个字段的长度都是 2 个字节。各字段意义如下：</p><ol><li><strong>源端口：</strong>源端口号。在需要对方回信时选用。不需要时可用全 0。</li><li><strong>目的端口：</strong>目的端口号。这在终点交付报文时必须使用。</li><li><strong>长度：</strong>UDP 用户数据报的长度，其最小值是 8（仅有首部)。</li><li><strong>检验和：</strong>检测 UDP 用户数据报在传输中是否有错。有错就丢弃。</li></ol><p><img src="/../img/post/computer-network/5-7.jpg"></p><h1 id="3-传输控制协议-TCP-概述"><a href="#3-传输控制协议-TCP-概述" class="headerlink" title="3.传输控制协议 TCP 概述"></a>3.传输控制协议 TCP 概述</h1><h2 id="3-1-TCP-最主要的特点"><a href="#3-1-TCP-最主要的特点" class="headerlink" title="3.1 TCP 最主要的特点"></a>3.1 TCP 最主要的特点</h2><p>TCP 是 TCP&#x2F;IP 体系中非常复杂的一个协议。下面介绍 TCP 最主要的特点：</p><ol><li><p>TCP 是面向连接的运输层协议。这就是说，应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接。</p></li><li><p>每一条 TCP 连接只能有两个端点（endpoint），每一条 TCP 连接只能是点对点的（一对一）。</p></li><li><p>TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达。</p></li><li><p>TCP 提供全双工通信。</p></li><li><p>面向字节流。TCP 中的 “流”(stream) 指的是流入到进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等)，但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。TCP 并不知道所传送的字节流的含义，也不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系（例如，发送方应用程序交给发送万的 TCP 共 10个数据块，但接收方的 TCP 可能只用了 4 个数据块就把收到的字节流交付上层的应用程序）。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。</p><p><img src="/../img/post/computer-network/5-8.jpg"></p></li></ol><h2 id="3-2-TCP-的连接"><a href="#3-2-TCP-的连接" class="headerlink" title="3.2 TCP 的连接"></a>3.2 TCP 的连接</h2><p>TCP连接的端点叫做套接字（socket）或插口。根据 RFC 793 的定义：端口号拼接到 IP 地址即构成了套接字。因此，套接字的表示方法是在点分十进制的 IP 地址后面写上端口号，中间用冒号或逗号隔开。</p><p>$$<br>套接字 socket &#x3D; (IP地址:端口号)<br>$$</p><p><strong>每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定</strong>。即:</p><p>$$<br>TCP连接::&#x3D; {socket_1，socket_2}&#x3D; {(IP_1: port_1)，(IP_2: port_2)}<br>$$</p><p><strong>同一个 IP 地址可以有多个不同的 TCP 连接，而同一个端口号也可以出现在多个不同的 TCP 连接中。</strong></p><h1 id="4-可靠传输的工作原理"><a href="#4-可靠传输的工作原理" class="headerlink" title="4.可靠传输的工作原理"></a>4.可靠传输的工作原理</h1><p>TCP 发送的报文段是交给 IP 层传送的。但 IP 层只能提供尽最大努力服务。因此，TCP 必须采用适当的措施才能使得两个运输层之间的通信变得可靠。</p><p><strong>理想的传输条件有以下两个特点：</strong></p><ol><li>传输信道不产生差错。</li><li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。</li></ol><h2 id="4-1-停止等待协议"><a href="#4-1-停止等待协议" class="headerlink" title="4.1 停止等待协议"></a>4.1 停止等待协议</h2><p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p><h3 id="4-1-1-无差错情况"><a href="#4-1-1-无差错情况" class="headerlink" title="4.1.1 无差错情况"></a>4.1.1 无差错情况</h3><p><img src="/../img/post/computer-network/5-9.jpg"></p><h3 id="4-1-2-出现差错"><a href="#4-1-2-出现差错" class="headerlink" title="4.1.2 出现差错"></a>4.1.2 出现差错</h3><p>分组在传输过程中出现差错的情况。在这两种情况下，B都不会发送任何信息。</p><p><strong>注意三点：</strong></p><ol><li>A 在发送完一个分组后，<strong>必须暂时保留已发送的分组的副本</strong>（在发生超时重传时使用）。只有在收到相应的确认后才能清除暂时保留的分组副本。</li><li><strong>分组和确认分组都必须进行编号。</strong>这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。</li><li><strong>超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。</strong>如果重传时间设定得很长，那么通信的效率就会很低。但如果重传时间设定得太短，以致产生不必要的重传，就浪费了网络资源。</li></ol><h3 id="4-1-3-确认丢失和确认迟到"><a href="#4-1-3-确认丢失和确认迟到" class="headerlink" title="4.1.3 确认丢失和确认迟到"></a>4.1.3 确认丢失和确认迟到</h3><p>B 所发送的对 M1 的确认丢失了。A 在设定的超时重传时间内没有收到确认，并无法知道是自己发送的分组出错、丢失，或者是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M1。现在应注意 B 的动作。假定 B 又收到了重传的分组M1。<strong>这时应采取两个行动：</strong></p><ol><li>丢弃这个重复的分组 M1，不向上层交付。</li><li>向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。</li></ol><p><img src="/../img/post/computer-network/5-10.jpg"></p><h3 id="4-1-4-信道利用率"><a href="#4-1-4-信道利用率" class="headerlink" title="4.1.4 信道利用率"></a>4.1.4 信道利用率</h3><p>停止等待协议的优点是简单，但缺点是信道利用率太低。</p><p><img src="/../img/post/computer-network/5-11.jpg"></p><h2 id="4-2-连续-ARQ-协议"><a href="#4-2-连续-ARQ-协议" class="headerlink" title="4.2 连续 ARQ 协议"></a>4.2 连续 ARQ 协议</h2><p>滑动窗口协议比较复杂，是 TCP 协议的精髓所在。</p><p><img src="/../img/post/computer-network/5-12.jpg"></p><p>在讨论滑动窗口时，我们应当注意到，图中还有一个时间坐标（但以后往往省略这样的时间坐标）。按照习惯，<strong>“向前”是指“向着时间增大的方向”</strong>，<strong>而“向后”则是“向着时间减少的方向”</strong>。分组发送是按照分组序号从小到大发送的。</p><p><img src="/../img/post/computer-network/5-13.jpg"></p><p>连续 ARQ 协议规定，<strong>发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。接收方一般都是采用累积确认的方式。</strong>这就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示：到这个分组为止的所有分组都已正确收到了。</p><p>累积确认有优点也有缺点。优点是：<strong>容易实现，即使确认丢失也不必重传</strong>。但缺点是：<strong>不能向发送方反映出接收方已经正确收到的所有分组的信息</strong>。</p><h1 id="5-TCP-报文段的首部格式"><a href="#5-TCP-报文段的首部格式" class="headerlink" title="5.TCP 报文段的首部格式"></a>5.TCP 报文段的首部格式</h1><p>TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。一个 TCP 报文段分为<strong>首部</strong>和<strong>数据</strong>两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。</p><p><img src="/../img/post/computer-network/5-14.jpg"></p><p>首部固定部分各字段的意义如下：</p><ol><li><p><strong>源端口和目的端口：</strong>各占2个字节，分别写入源端口号和目的端口号。</p></li><li><p><strong>序号：</strong>占 4 字节。序号范围是 $[0，2^{32} - 1]$，共 $2^{32}$（即4 294 967296）个序号。用完后，下一个序号就又回到 0。</p></li><li><p><strong>确认号：</strong>占 4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。</p></li><li><p><strong>数据偏移：</strong>占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出 TCP 报文段的首部长度。</p></li><li><p><strong>保留：</strong>占 6 位，保留为今后使用，但目前应置为 0。</p></li><li><p><strong>紧急 URG (Urgent)：</strong>当 URG&#x3D;1 时，表明紧急指针字段有效。表此报文段中有紧急数据，应尽快传送。</p></li><li><p><strong>确认 ACK：</strong>仅当 ACK&#x3D;1 时确认号字段才有效。</p></li><li><p><strong>推送 PSH：</strong>PSH&#x3D;1 的报文段，就尽快地（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</p></li><li><p><strong>复位 RST：</strong>当 RST&#x3D;1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</p></li><li><p><strong>同步 SYN：</strong>在连接建立时用来同步序号。当 SYN&#x3D;1 而 ACK&#x3D;0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN&#x3D;1 和 ACK&#x3D;1。因此，SYN 置为 1 就表示这是一个连接请求或连接接受报文。</p></li><li><p><strong>终止 FIN：</strong>FIN&#x3D;1 用来释放一个连接。</p></li><li><p><strong>窗口：</strong>占 2 字节。窗口值是 $[0,2^{16} -1]$ 之间的整数。从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。</p><blockquote><p>💡 例如，发送了一个报文段，其确认号是 701，窗口字段是 1000。这就是告诉对方：“从701号算起，我（即发送此报文段的一方）的接收缓存空间还可接收 1000 个字节数据（字节序号是701~1700），你在给我发送数据时，必须考虑到这一点。”</p></blockquote></li><li><p><strong>检验和：</strong>占 2 字节。检验和字段检验的范围包括首部和数据这两部分。</p></li><li><p><strong>紧急指针：</strong>占 2 字节。紧急指针仅在 URG&#x3D;1 时才有意义</p></li><li><p><strong>选项：</strong>长度可变，最长可达 40 字节。</p></li></ol><p>TCP 最初只规定了一种选项，即最大报文段长度 MSS（Maximum Segment Size)）[RFC879]。MSS 是每一个 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以 MSS 并不是整个 TCP 报文段的最大长度，而是 <strong>“TCP报文段长度减去TCP首部长度”</strong>。</p><p>MSS 与接收窗口值没有关系。若选择较小的MSS 长度，网络的利用率就降低。因此，MSS应尽可能大些，只要在IP层传输时不需要再分片就行。</p><h1 id="6-TCP-可靠传输的实现"><a href="#6-TCP-可靠传输的实现" class="headerlink" title="6.TCP 可靠传输的实现"></a>6.TCP 可靠传输的实现</h1><h2 id="6-1-以字节为单位的滑动窗口"><a href="#6-1-以字节为单位的滑动窗口" class="headerlink" title="6.1 以字节为单位的滑动窗口"></a>6.1 以字节为单位的滑动窗口</h2><p>TCP 的滑动窗口是以字节为单位的。</p><p><img src="/../img/post/computer-network/5-15.jpg"></p><p>发送窗口前沿通常是不断向前移动，但也有可能不动。但 TCP 的标准强烈不赞成向后收缩，因为很可能发送方在收到这个通知以前已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，这样就会产生一些错误。</p><p><img src="/../img/post/computer-network/5-16.jpg"></p><ul><li>P3-P1 &#x3D; A 的发送窗口</li><li>P2-P1 &#x3D; 已发送但尚未收到确认的字节数</li><li>P3-P2 &#x3D; 允许发送但当前尚未发送的字节数（又称为可用窗口或有效窗口）</li></ul><p>未按序收到，窗口可以增大：</p><p><img src="/../img/post/computer-network/5-17.jpg"></p><p>A 的发送窗口已满，可用窗口已减小到零，因此必须停止发送：</p><p><img src="/../img/post/computer-network/5-18.jpg"></p><p>下图画出了发送方维持的发送缓存和发送窗口，以及接收方维持的接收缓存和接收窗口。这里首先要明确两点：</p><p><img src="/../img/post/computer-network/5-19.jpg"></p><ol><li>缓存空间和序号空间都是有限的，并且都是循环使用的。最好是把它们画成圆环状的。但这里为了画图的方便，我们还是把它们画成长条状的。</li><li>第二，由于实际上缓存或窗口中的字节数是非常之大的，因此上图仅仅是个示意图，没有标出具体的数值。但用这样的图来说明缓存和发送窗口以及接收窗口的关系是很清楚的。</li></ol><p><strong>再强调以下四点：</strong></p><ol><li><strong>虽然 A 的发送窗口是根据 B 的接收窗口设置的，但在同一时刻，A 的发送窗口并不总是和 B 的接收窗口一样大。</strong>这是因为通过网络传送窗口值需要经历一定的时间滞后（这个时间还是不确定的）。另外，发送方 A 还可能根据网络当时的拥塞情况适当减小自己的发送窗口数值。</li><li><strong>对于不按序到达的数据应如何处理，TCP 标准并无明确规定</strong>。如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利（因为发送方会重复传送较多的数据）。因此TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再<strong>按序交付上层的应用进程</strong>。</li><li>TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。但请注意两点：<ol><li>一是接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。TCP 标准规定，确认推迟的时间不应超过 0. 5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认 [RFC 1122]。</li><li>二是捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ol></li><li>最后再强调一下，TCP 的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清是哪一方的窗口。</li></ol><h2 id="6-2-超时重传时间的选择"><a href="#6-2-超时重传时间的选择" class="headerlink" title="6.2 超时重传时间的选择"></a>6.2 超时重传时间的选择</h2><p>TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。TCP 保留了 RTT 的一个加权平均往返时间 RTTs （这又称为平滑的往返时间，S 表示 Smoothed。因为进行的是加权平均，因此得出的结果更加平滑）。每当第一次测量到 RTT 样本时，RTTs 值就取为所测量到的 RTT 样本值。但以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTs：</p><p>$$<br>新的RTTs &#x3D; (1-a) ×(旧的RTTs)+ α ×(新的RTT样本)<br>$$</p><p>在上式中，0≤a&lt;1，若：</p><ul><li>α 接近于 0，表示新的 RTTs 值和旧的 RTTs 值相比变化不大，而对新的 RTT 样本影啊个大 (RTT 更新校慢）</li><li>α 接近于 1，则表示新的 RTTs 值受新的 RTT 样本的影响较大（RTT值更新较快）</li></ul><p>显然，超时计时器设置的超时重传时间 RTO（RetransmissionTime-Out）应略大于上面得出的加权平均往返时间 RTTs：</p><p>$$<br>RTO&#x3D;RTT_S+4× RTT_D<br>$$</p><p>而 $RTT_D$ 是 RTT 的偏差的加权平均值，它与 RTTs 和新的 RTT 样本之差有关。当第一次测量时，$RTT_D$ 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 $RTT_D$ ：</p><p>$$<br>新的RTT_D&#x3D;(1-β)×(旧的RTT_D)+βx|RTTs-新的RTT样本|<br>$$</p><p>这里 β 是个小于 1 的系数，它的推荐值是 1&#x2F;4。</p><h2 id="6-3-选择确认SACK"><a href="#6-3-选择确认SACK" class="headerlink" title="6.3 选择确认SACK"></a>6.3 选择确认SACK</h2><p>若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？用<strong>选择确认SACK。</strong></p><p>但 SACK 文档并没有指明发送方应当怎样响应 SACK。因此大多数的实现还是重传所有未被确认的数据块。</p><h1 id="7-TCP-的流量控制"><a href="#7-TCP-的流量控制" class="headerlink" title="7.TCP 的流量控制"></a>7.TCP 的流量控制</h1><h2 id="7-1-利用滑动窗口实现流量控制"><a href="#7-1-利用滑动窗口实现流量控制" class="headerlink" title="7.1 利用滑动窗口实现流量控制"></a>7.1 利用滑动窗口实现流量控制</h2><p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。TCP 窗口单位是字节，不是报文段。</p><p><img src="/../img/post/computer-network/5-20.jpg"></p><h2 id="7-2-TCP-的传输效率"><a href="#7-2-TCP-的传输效率" class="headerlink" title="7.2 TCP 的传输效率"></a>7.2 TCP 的传输效率</h2><h3 id="7-2-1-TCP-的发送时机"><a href="#7-2-1-TCP-的发送时机" class="headerlink" title="7.2.1 TCP 的发送时机"></a>7.2.1 TCP 的发送时机</h3><ol><li>TCP 维持一个变量，它等于最大报文段长度 MSS。只要达到 MSS，就封装成一个 TCP 报文段发出去。</li><li>由发送方的应用进程指明要求发送的报文段，TCP 再推送。</li><li>有发送方的一个计时器期限到了，就把当前缓存发出去。</li></ol><p>但如何控制 TCP 发送报文段的时机仍然是一个较为复杂的问题，在 TCP 的实现中 广泛使用 Nagle 算法。</p><h3 id="7-2-1-糊涂窗口综合征"><a href="#7-2-1-糊涂窗口综合征" class="headerlink" title="7.2.1 糊涂窗口综合征"></a>7.2.1 糊涂窗口综合征</h3><p>糊涂窗口综合征（silly window syndrome）[RFC 813]，有时也会使 TCP 的性能变坏。设想一种情况：TCP 接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取 1 个字节（这样就使接收缓存空间仅腾出 1 个字节)，然后向发送方发送确认，并把窗口设置为 1 个字节（但发送的数据报是40字节长）。接着，发送方又发来 1 个字节的数据（请注意，发送方发送的 IP 数据报是 41字节长）。接收方发回确认，仍然将窗口设置为 1 个字节。这样进行下去，使<strong>网络的效率很低。</strong></p><p><strong>解决方法：</strong></p><ol><li>让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段。</li><li>或等到接收缓存已有一半空闲的空间。</li></ol><h1 id="8-TCP-的拥塞控制"><a href="#8-TCP-的拥塞控制" class="headerlink" title="8.TCP 的拥塞控制"></a>8.TCP 的拥塞控制</h1><h2 id="8-1-拥塞控制的一般原理"><a href="#8-1-拥塞控制的一般原理" class="headerlink" title="8.1 拥塞控制的一般原理"></a>8.1 拥塞控制的一般原理</h2><p>拥塞控制是一个全局性过程，涉及到所有主机、所有的路由器，以及与降低网路传输性能有关的所有因素。</p><p>$$<br>\Sigma 对资源的需求 &gt; 可用资源<br>$$</p><p><img src="/../img/post/computer-network/5-21.jpg"></p><p>从控制理论的角度，可以分为<strong>开环控制</strong>和<strong>闭环控制</strong>两种方法。</p><ul><li><strong>开环控制：</strong>就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。但一旦整个系统运行起来，就不再中途进行改正了。</li><li><strong>闭环控制：</strong>是基于反馈环路的概念，主要有以下几种措施：<ul><li>监测网络系统以便检测到拥塞在何时、何处发生。</li><li>把拥塞发生的信息传送到可采取行动的地方。</li><li>调整网络系统的运行以解决出现的问题。</li></ul></li></ul><h2 id="8-2-TCP-的拥塞控制方法"><a href="#8-2-TCP-的拥塞控制方法" class="headerlink" title="8.2 TCP 的拥塞控制方法"></a>8.2 TCP 的拥塞控制方法</h2><p>TCP 进行拥塞控制的算法有四种：</p><ul><li>慢开始（slow-start）</li><li>拥塞避免（congestionavoidance）</li><li>快重传（fast retransmit）</li><li>快恢复（fast recovery）</li></ul><h3 id="8-2-1-慢开始和拥塞避免"><a href="#8-2-1-慢开始和拥塞避免" class="headerlink" title="8.2.1 慢开始和拥塞避免"></a>8.2.1 慢开始和拥塞避免</h3><p>基于窗口的拥塞控制。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p><blockquote><p>💡 <strong>判断网络拥塞的依据就是出现了超时。</strong></p></blockquote><p><strong>慢开始：</strong>当主机开始发送数据时，由于并不清楚网络的负荷情况，所以如果立即把大量数据字节注入到网络，那么就有可能引起网络发生拥塞。较好的方法是先探测一下，即由小到大逐渐增大发送窗口。</p><p><img src="/../img/post/computer-network/5-22.jpg"></p><h2 id="8-2-主动队列管理-AQM"><a href="#8-2-主动队列管理-AQM" class="headerlink" title="8.2 主动队列管理 AQM"></a>8.2 主动队列管理 AQM</h2><blockquote><p>💡 <strong>TCP 的全局同步：</strong>导致以连串分组丢失，发送又发，进入 TCP 拥塞控制满开始状态。</p></blockquote><p>为了避免发生网络中的<strong>全局同步现象</strong>，在 1998 年提出了主动队列管理 AQM  （Active Queue Management）。所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。这样就太被动了。<strong>应当在队列长度达到某个值得警惕的数值时（即当网络拥塞有了某些拥塞征兆时），就主动丢弃到达的分组。</strong>这样就提醒了发送方放慢发送的速率，因而有可能使网络拥塞的程度减轻，甚至不出现网络拥塞。</p><p>AQM 可以有不同实现方法，其中曾流行多年的就是随机早期检测 RED（Random Early Detection）：</p><ol><li>若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队。</li><li>若平均队列长度超过最大门限，则把新到达的分组丢弃。</li><li>若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率 p 把新到达的分组丢弃（这就体现了丢弃分组的随机性）。</li></ol><h1 id="9-TCP-的运输连接管理"><a href="#9-TCP-的运输连接管理" class="headerlink" title="9.TCP 的运输连接管理"></a>9.TCP 的运输连接管理</h1><p>TCP 是面向连接的协议。运输连接是用来传送 TCP 报文的。TCP 运输连接的<strong>建立和释放</strong>是每一次面向连接的通信中必不可少的过程。因此，运输连接就有三个阶段，即：<strong>连接建立</strong>、<strong>数据传送</strong>和<strong>连接释放</strong>。</p><h2 id="9-1-TCP-的连接建立（三报文握手）"><a href="#9-1-TCP-的连接建立（三报文握手）" class="headerlink" title="9.1 TCP 的连接建立（三报文握手）"></a>9.1 TCP 的连接建立（三报文握手）</h2><p>TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间<strong>交换三个 TCP 报文段</strong>。</p><p><img src="/../img/post/computer-network/5-23.jpg"></p><ol><li>一开始，B 的 TCP 服务器进程先创建传输控制块 TCB，准备接受客户进程的连接请求。然后服务器进程就处于 LISTEN（收听）状态，等待客户的连接请求。</li><li>A 的 TCP 客户进程也是首先创建传输控制模块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN &#x3D; 1，同时选择一个初始序号 seq &#x3D; x。TCP 规定，SYN 报文段（即SYN&#x3D; 1的报文段）不能携带数据，但要<strong>消耗掉一个序号</strong>。这时，TCP 客户进程进入 <strong>SYN-SENT（同步已发送）状态</strong>。</li><li>B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack &#x3D; x +1，同时也为自己选择一个初始序号 seq &#x3D;y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务器进程进入 <strong>SYN-RCVD（同步收到）状态</strong>。</li><li>TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack &#x3D;y + 1，而自己的序号 seq&#x3D;x +1。TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是 seq &#x3D; x +1。这时，TCP 连接已经建立，A 进入 <strong>ESTABLISHED（已建立连接）状态</strong>。</li><li>当 B 收到 A 的确认后，也进入 <strong>ESTABLISHED 状态</strong>。</li></ol><blockquote><p>💡 为什么 A 最后还要发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传送到了 B，因而产生错误。</p><p>现假定出现一种异常情况，即 A 发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早己失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。假定不采用报文握手，那么只要 B 发出确认，新的连接就建立了。</p></blockquote><h2 id="9-2-TCP-的连接释放（四报文握手）"><a href="#9-2-TCP-的连接释放（四报文握手）" class="headerlink" title="9.2 TCP 的连接释放（四报文握手）"></a>9.2 TCP 的连接释放（四报文握手）</h2><p>数据传输结束后，通信的双方都可释放连接。</p><p><img src="/../img/post/computer-network/5-24.jpg"></p><ol><li>A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq&#x3D; u，它等于前面己传送过的数据的最后一个字节的序号加 1。这时 A 进入 <strong>FIN-WAIT-1（终止等待1）状态</strong>，等待 B 的确认。</li><li>B 收到连接释放报文段后即发出确认，确认号是 ack &#x3D; u +1，而这个报文段自己的序号是 v，等于 B 前面已传送过的数据的最后一个字节的序号加 1。然后 B 就进入 <strong>CLOSE-WAIT（关闭等待）状态</strong>。<strong>TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的TCP连接处于半关闭（half-close）状态</strong>，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。</li><li>A 收到来自 B 的确认后，就进入 <strong>FIN-WAIT-2（终止等待2）状态</strong>，等待 B 发出的连接释放报文段。</li><li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的接释放报文段必须使 FIN &#x3D; 1，<strong>进入 LAST-ACK（最后认）状态</strong>，等待A的确认。</li><li>A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 ACK置 1，确认号 ack &#x3D; w +1，而自己的序号是 seq &#x3D;u +1（根据TCP标准，前面发送过的FIN 报文段要消耗一个序号），然后进入到 <strong>TIME-WAIT（时间等待）状态</strong>。</li><li>A 必须经过时间等待计时器（TIME-WAIT timer）设置的时间 <strong>2MSL</strong> 后，A 才进入到 <strong>CLOSED 状态</strong>。</li></ol><blockquote><p>💡 MSL 叫做最长报文段寿命（Maximum Segment Lifetime），RFC 793 建议为 2 分钟。</p></blockquote><p>为什么 A 在 <strong>TIME-WAIT 状态</strong>必须等待 <strong>2MSL</strong> 的时间呢？</p><ol><li>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。</li><li>防止“已失效的连接请求报文段”出现在本连接中。</li></ol><h3 id="9-2-1-TCP-的连接保活计时器释放"><a href="#9-2-1-TCP-的连接保活计时器释放" class="headerlink" title="9.2.1 TCP 的连接保活计时器释放"></a>9.2.1 TCP 的连接保活计时器释放</h3><p>TCP 还设有一个保活计时器（keepalive timer）：若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，就关闭这个连接。</p><h2 id="9-3-TCP-的有限状态机"><a href="#9-3-TCP-的有限状态机" class="headerlink" title="9.3 TCP 的有限状态机"></a>9.3 TCP 的有限状态机</h2><p><img src="/../img/post/computer-network/5-25.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络 第四章：网络层</title>
    <link href="/computer-network-4/"/>
    <url>/computer-network-4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-网络层提供的两种服务"><a href="#1-网络层提供的两种服务" class="headerlink" title="1.网络层提供的两种服务"></a>1.网络层提供的两种服务</h1><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。</p><p>网络在发送分组时不需要先建立连接。每一个分组（也就是IP数据报）独立发送，与其前后的分组无关（不进行编号)。网络层不提供服务质量的承诺。也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点)，当然也不保证分组交付的时限。<strong>因为计算机有很强的差错处理能力，与传统电话有本质上的差别。</strong></p><p><img src="/../img/post/computer-network/4-1.jpg"></p><p><img src="/../img/post/computer-network/4-2.jpg"></p><h1 id="2-网际协议-IP"><a href="#2-网际协议-IP" class="headerlink" title="2.网际协议 IP"></a>2.网际协议 IP</h1><p>网际协议 IP 是 TCP&#x2F;IP 体系中两个最主要的协议之一，也是最重要的互联网标准协议之一。</p><p><strong>与 IP 协议配套使用的还有三个协议：</strong></p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h2 id="2-1-虚拟互连网络"><a href="#2-1-虚拟互连网络" class="headerlink" title="2.1 虚拟互连网络"></a>2.<strong>1 虚拟互连网络</strong></h2><p>许多计算机网络通过一些路由器进行互连。由于参加互连的计算机网络都使用相同的网际协议 IP（Internet Protocol），因此可以把互连以后的计算机网络看成一个虚拟互连网络。</p><p><img src="/../img/post/computer-network/4-3.jpg"></p><p><img src="/../img/post/computer-network/4-4.jpg"></p><h2 id="2-2-分类的IP地址"><a href="#2-2-分类的IP地址" class="headerlink" title="2.2 分类的IP地址"></a><strong>2.2 分类的IP地址</strong></h2><p><strong>IP地址的编址方法共经过了三个历史阶段：</strong></p><ol><li><strong>分类的IP地址：</strong>这是最基本的编址方法，在1981年就通过了相应的标准协议。</li><li><strong>子网的划分：</strong>这是对最基本的编址方法的改进，其标准RFC 950在1985年通过。</li><li><strong>构成超网：</strong>这是比较新的无分类编址方法。1993年提出后很快就得到推广应用</li></ol><h3 id="2-2-1-IP地址及其表示方法"><a href="#2-2-1-IP地址及其表示方法" class="headerlink" title="2.2.1 IP地址及其表示方法"></a>2.2.<strong>1 IP地址及其表示方法</strong></h3><p>点分十进制法：</p><p>$$<br>IP地址 ::&#x3D; { &lt;网络号&gt;,&lt;主机号&gt; }<br>$$</p><p>一个网络号在整个互联网范围内必须是唯一的。第二个字段是主机号(host-id)，它标志该主机（或路由器)。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。<strong>由此可见，一个IP地址在整个互联网范围内是唯一的。</strong></p><p><img src="/../img/post/computer-network/4-5.jpg"></p><ul><li>A类、B类和C类地址的网络号字段（在图中这个字段是灰色的）分别为1个、2个和3个字节长，而在网络号字段的最前面有1~3位的类别位，其数值分别规定为0，10和110。</li><li>A类、B类和C类地址的主机号字段分别为3个、2个和1个字节长。</li><li>D类地址（前4位是1110）用于多播（一对多通信)。我们将在4.6节讨论P多播</li><li>E类地址（前4位是1111）保留为以后用。</li></ul><blockquote><p>💡 A、B、C 类地址的区分已经成为历史。</p></blockquote><p>对主机或路由器来说，IP地址都是32位的二进制代码。为了提高可读性，我们常常把32位的IP地址中的每8位插入一个空格（但在机器中并没有这样的空格)。</p><p><img src="/../img/post/computer-network/4-6.jpg"></p><h3 id="2-2-2-常用的三种类别的IP地址"><a href="#2-2-2-常用的三种类别的IP地址" class="headerlink" title="2.2.2 常用的三种类别的IP地址"></a>2.2.<strong>2 常用的三种类别的IP地址</strong></h3><p><img src="/../img/post/computer-network/4-7.jpg"></p><p><strong>IP 地址具有以下一些重要特点：</strong></p><ol><li>每一个IP地址都由网络号和主机号两部分组成。从这个意义上说，IP 地址是一种分等级的地址结构。好处是：第一，IP地址管理机构在分配IP地址时只分配网络号（第一级)，而剩下的主机号（第二级）则由得到该网络号的单位自行分配。这样就方便了IP地址的管理；第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号)，这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间以及查找路由表的时间。</li><li>实际上IP地址是标志一台主机（或路由器）和一条链路的接口。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的IP地址，其网络号必须是不同的。这种主机称为多归属主机（multihomed host）。</li><li>按照互联网的观点，一个网络是指具有相同网络号 net-id 的主机的集合，因此，用转发器或网桥连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络号。<strong>具有不同网络号的局域网必须使用路由器进行互连。</strong></li><li>在IP地址中，所有分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网）都是平等的。所谓平等，是指互联网同等对待每一个IP地址。</li></ol><p><strong>我们应当注意到：</strong></p><ul><li>在同一个局域网上的主机或路由器的IP地址中的网络号必须是一样的。</li><li>用网桥（它只在链路层工作）互连的网段仍然是一个局域网，只能有一个网络号。</li><li>路由器总是具有两个或两个以上的IP地址。即路由器的每一个接口都有一个不同网络号的IP地址。</li><li>当两个路由器直接相连时（例如通过一条租用线路)，在连线两端的接口处，可以分配也可以不分配IP地址。如分配了IP地址，则这一段连线就构成了一种只包含一段线路的特殊“网络”（如图中的 N1，N2 和 N3)。之所以叫做“网络”是因为它有IP地址。但为了节省IP地址资源，对于这种仅由一段连线构成的特殊“网络”，现在也常常不分配IP地址。通常把这样的特殊网络叫做无编号网络或无名网络。</li></ul><p><img src="/../img/post/computer-network/4-8.jpg"></p><h2 id="2-3-IP地址与硬件地址"><a href="#2-3-IP地址与硬件地址" class="headerlink" title="2.3 IP地址与硬件地址"></a><strong>2.3 IP地址与硬件地址</strong></h2><p><strong>物理地址：</strong>数据链路层和物理层使用的地址。</p><p><strong>IP 地址：</strong>网络层以及上层使用的地址，是一种<strong>逻辑地址</strong>。</p><p><img src="/../img/post/computer-network/4-9.jpg"></p><p><img src="/../img/post/computer-network/4-10.jpg"></p><p><strong>这里要强调指出以下几点：</strong></p><ol><li>在 IP 层抽象的互联网上只能看到 IP 数据报。数据报中间经过的两个路由器的 IP 地址并不出现在 IP 数据报的首部中。</li><li>虽然在 IP 数据报首部有源站 IP 地址，但路由器<strong>只根据目的站的IP地址的网络号</strong>进行路由选择。</li><li>在局域网的链路层，只能看见 MAC帧。IP数据报被封装在MAC 帧中。</li><li>尽管互连在一起的网络的硬件地址体系各不相同，但 IP 层抽象的互联网却屏蔽了下层这些很复杂的细节。</li></ol><h2 id="2-4-地址解析协议-ARP"><a href="#2-4-地址解析协议-ARP" class="headerlink" title="2.4 地址解析协议 ARP"></a><strong>2.4 地址解析协议 ARP</strong></h2><p>已经知道了一个机器（主机或路由器）的 IP 地址，需要找出其相应的硬件地址，用地址解析协议 ARP。</p><p><strong>ARP协议的要点：</strong></p><ol><li><p>每一台主机都设有一个 ARP高速缓存（ARP cache），里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。</p></li><li><p>当主机 A 要向本局域网上的某台主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有就在 ARP 高速缓存中查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网把该MAC帧发往此硬件地址。如果没有，主机 A 就自动运行 ARP。</p><ol><li><p>ARP 进程在本局域网上广播发送一个 ARP 请求分组。</p></li><li><p>在本局域网上的所有主机上运行的 ARP 进程都收到此 ARP 请求分组。</p></li><li><p>主机 B 的 IP 地址与 ARP 请求分组中要查询的 IP 地址一致，就收下这个 ARP 请求分组，并向主机A发送 ARP响应分组，同时在这个 ARP 响应分组中写入自己的硬件地址。</p><p><img src="/../img/post/computer-network/4-11.jpg"></p></li><li><p>主机 A 收到主机 B 的 ARP 响应分组后，就在其 ARP 高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。</p></li></ol></li></ol><p>可见 ARP 高速缓存非常有用。如果不使用 ARP 高速缓存，那么任何一台主机只要进行一次通信，就必须在网络上用广播方式发送ARP请求分组，这就使网络上的通信量大大增加。</p><h2 id="2-5-IP-数据报的格式"><a href="#2-5-IP-数据报的格式" class="headerlink" title="2.5 IP 数据报的格式"></a><strong>2.5 IP 数据报的格式</strong></h2><p>在 TCP&#x2F;IP 的标准中，各种数据格式常常以 32 位（即 4 字节）为单位来描述。</p><p><img src="/../img/post/computer-network/4-12.jpg"></p><p><strong>固定长度：</strong>共20字节</p><p><strong>可选字段：</strong>长度可变</p><h3 id="2-5-1-IP数据报首部的固定部分"><a href="#2-5-1-IP数据报首部的固定部分" class="headerlink" title="2.5.1 IP数据报首部的固定部分"></a>2.5.1 <strong>IP数据报首部的固定部分</strong></h3><ol><li><p><strong>版本：</strong>占 4 位，指 IP 协议的版本，通信双方使用的IP协议的版本必须一致。</p></li><li><p><strong>首部长度：</strong>占 4 位，可表示的最大十进制数值是 15（1111），最小值是 5（0101）.</p></li><li><p><strong>区分服务：</strong>占8位，用来获得更好的服务。</p></li><li><p><strong>总长度：</strong>首部和数据之和的长度，单位为字节。总长度字段为16 位，因此数据报的最大长度为 $2^{16}-1&#x3D;65535$ 字节。</p></li><li><p><strong>标识：</strong>占 16 位，IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。</p></li><li><p><strong>标志：</strong>占 3 位，但目前只有两位有意义。</p><ol><li>标志字段中的最低位记为 MF（More Fragment）。MF &#x3D; 1即表示后面“还有分片”的数据报。MF &#x3D; 0 表示这已是若干数据报片中的最后一个。</li><li>标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当 DF &#x3D; 0 时才允许分片。</li></ol></li><li><p><strong>片偏移：</strong>占 13 位，较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。</p></li><li><p><strong>生存时间：</strong>占 8 位，生存时间字段常用的英文缩写是 TTL 表明这是数据报在网络中的寿命。</p></li><li><p><strong>协议：</strong>占 8 位，&#x3D;此数据报携带的数据是使用何种协议。</p><p><img src="/../img/post/computer-network/4-13.jpg"></p></li><li><p><strong>首部检验和：</strong>占 16 位，这个字段只检验数据报的首部，但不包括数据部分。</p><p><img src="/../img/post/computer-network/4-14.jpg"></p></li><li><p><strong>源地址：</strong>占 32 位。</p></li><li><p><strong>目的地址：</strong>占 32 位。</p></li></ol><h3 id="2-5-2-IP数据报首部的可变部分"><a href="#2-5-2-IP数据报首部的可变部分" class="headerlink" title="2.5.2 IP数据报首部的可变部分"></a>2.5.<strong>2 IP数据报首部的可变部分</strong></h3><p>IP 数据报首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。</p><p>增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。</p><h2 id="2-6-IP-层转发分组的流程"><a href="#2-6-IP-层转发分组的流程" class="headerlink" title="2.6 IP 层转发分组的流程"></a><strong>2.6 IP 层转发分组的流程</strong></h2><p>在路由表中，对每一条路由最主要的是以下两个信息：</p><p>$$<br>(目的网络地址，下一跳地址)<br>$$</p><p><img src="/../img/post/computer-network/4-15.jpg"></p><p>于是，我们就根据目的网络地址来确定下一跳路由器，这样做可得出以下的结果。</p><ol><li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付)。</li><li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li></ol><p>虽然互联网所有的分组转发都是基于目的主机所在的网络，但在大多数情况下都允许有这样的特例：</p><ol><li>即对特定的目的主机指明一个路由。这种路由叫做特定主机路由。采用特定主机路由可使网络管理人员更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。在对网络的连接或路由表进行排错时，指明到某一台主机的特殊路由就十分有用。</li><li>路由器还可采用默认路由（default route）以减小路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。</li></ol><h1 id="3-划分子网和构造超网"><a href="#3-划分子网和构造超网" class="headerlink" title="3.划分子网和构造超网"></a>3.划分子网和构造超网</h1><h2 id="3-1-划分子网"><a href="#3-1-划分子网" class="headerlink" title="3.1 划分子网"></a>3.1 <strong>划分子网</strong></h2><h3 id="3-1-1-从两级-IP-地址到三级-IP-地址"><a href="#3-1-1-从两级-IP-地址到三级-IP-地址" class="headerlink" title="3.1.1 从两级 IP 地址到三级 IP 地址"></a>3.1.<strong>1 从两级 IP 地址到三级 IP 地址</strong></h3><p>在 ARPANET 的早期，IP地址的设计确实不够合理。</p><ol><li>IP 地址空间的利用率有时很低；</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏；</li><li>两级IP地址不够灵活。</li></ol><p>为解决上述问题，从1985年起在IP地址中又增加了一个“子网号字段”，使两级IP地址变成为三级IP地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法叫做划分子网（subnetting）[RFC 950]，或子网寻址或子网路由选择。划分子网已成为互联网的正式标准协议。</p><p>$$<br>IP地址 ::&#x3D; { &lt;网络号&gt;,&lt;网络号&gt;,&lt;主机号&gt; }<br>$$</p><p><img src="/../img/post/computer-network/4-16.jpg"></p><p>总之，当没有划分子网时，IP地址是两级结构。划分子网后IP地址变成了三级结构。划分子网只是把IP地址的主机号这部分进行再划分，而不改变IP地址原来的网络号。</p><h3 id="3-1-2-子网掩码"><a href="#3-1-2-子网掩码" class="headerlink" title="3.1.2 子网掩码"></a>3.1.2 <strong>子网掩码</strong></h3><p>我们知道，从 IP 数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网的划分。这是因为 32 位的 IP 地址本身以及数据报的首部都没有包含任何有关子网划分的信息。因此必须另外想办法，这就是使用子网掩码。</p><p><img src="/../img/post/computer-network/4-17.jpg"></p><p>逐位相“与”（AND）得出了所要找的子网的网络地址。</p><p><strong>使用子网掩码的好处就是：</strong>不管网络有没有划分子网，只要把子网掩码和 IP 地址进行逐位的“与”运算（AND），就立即得出网络地址来。这样在路由器处理到来的分组时就可采用同样的算法。</p><p><strong>在不划分子网时，仍然要使用子网掩码：</strong>为了更便于查找路由表，现在互联网的标准规定所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。</p><p>如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码：</p><ul><li>A类地址的默认子网掩码是255.0.0.0，或 0xFF000000</li><li>B类地址的默认子网掩码是255.255.0.0，或 0xFFFF0000</li><li>C类地址的默认子网掩码是255.255.255.0，或 0xFFFFFF00</li></ul><p><strong>子网掩码是一个网络或一个子网的重要属性。</strong></p><h2 id="3-2-使用子网时分组的转发"><a href="#3-2-使用子网时分组的转发" class="headerlink" title="3.2 使用子网时分组的转发"></a>3.2 <strong>使用子网时分组的转发</strong></h2><p>使用子网划分后，路由表必须包含：目的网络地址、子网掩码和下一跳地址。</p><p><strong>在划分子网的情况下，路由器转发分组的算法如下：</strong></p><ol><li>从收到的数据报的首部提取目的 IP 地址 D。</li><li>先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 D 逐位相“与”，看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付（当然还需要把 D 转换成物理地址，把数据报封装成帧发送出去)，转发任务结束。否则就是间接交付，执行(3)。</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。</li><li>对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和D逐位相“与”，其结果为 N。若 N 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行(5)。</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。</li><li>报告转发分组出错。</li></ol><h2 id="3-3-无分类编址-CIDR（构造超网）"><a href="#3-3-无分类编址-CIDR（构造超网）" class="headerlink" title="3.3 无分类编址 CIDR（构造超网）"></a>3.3 <strong>无分类编址 CIDR（构造超网）</strong></h2><h3 id="3-3-1-网络前缀"><a href="#3-3-1-网络前缀" class="headerlink" title="3.3.1 网络前缀"></a>3.3.<strong>1 网络前缀</strong></h3><p>由于 2011 年 IPV4 地址耗尽，要用无分类编址了。正式名称是无分类域间路由选择 CIDR。</p><p><strong>CIDR 最主要的特点有两个：</strong></p><ol><li>CIDR 消除了传统的A类、B类和C类地址以及划分子网的概念</li><li>CIDR 把网络前缀都相同的连续的IP地址组成一个 “CIDR地址块”。</li></ol><p>网络前缀越短，其地址块所包含的地址数就越多。</p><h3 id="3-1-2-最长前缀匹配"><a href="#3-1-2-最长前缀匹配" class="headerlink" title="3.1.2 最长前缀匹配"></a>3.1.<strong>2 最长前缀匹配</strong></h3><p>应当从匹配结果中选择具有“最长”网络前缀的路由，否则可能会得到不止一个的匹配结果。</p><h3 id="3-1-3-使用二叉线索查找路由表"><a href="#3-1-3-使用二叉线索查找路由表" class="headerlink" title="3.1.3 使用二叉线索查找路由表"></a>3.1.<strong>3 使用二叉线索查找路由表</strong></h3><p>由于要寻找最长前缀匹配，使路由表的查找过程变得更加复杂了。对无分类编址的路由表的最简单的查找算法就是对所有可能的前缀进行循环查找。为了进行更加有效的查找，通常是把无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是二叉线索（binary trie），它是一种特殊结构的树。</p><p><img src="/../img/post/computer-network/4-18.jpg"></p><p>为了提高二叉线索的查找速度，广泛使用了各种压缩技术。</p><h1 id="4-网际控制报文协议-ICMP"><a href="#4-网际控制报文协议-ICMP" class="headerlink" title="4.网际控制报文协议 ICMP"></a>4.网际控制报文协议 ICMP</h1><p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP（Internet Control Message Protocol）[RFC 792]。</p><p>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 是互联网的标准协议，但不是高层协议，而是 IP 层的协议。</p><p><strong>ICMP 报文格式：</strong></p><p><img src="/../img/post/computer-network/4-19.jpg"></p><h2 id="4-1-ICMP-报文的种类"><a href="#4-1-ICMP-报文的种类" class="headerlink" title="4.1 ICMP 报文的种类"></a>4.1 <strong>ICMP 报文的种类</strong></h2><p><strong>ICMP 报文的种类有两种：</strong></p><ol><li>ICMP 差错报告报文<ol><li>终点不可达</li><li>时间超过</li><li>参数问题</li><li>改变路由（重定向）</li></ol></li><li>ICMP 询问报文</li></ol><p><img src="/../img/post/computer-network/4-20.jpg"></p><p><strong>下面是不应发送 ICMP 差错报告报文的几种情况：</strong></p><ol><li>对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP 差错报告报文。</li><li>对具有多播地址的数据报，都不发送 ICMP 差错报告报文。</li><li>对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报，不发送 ICMP 差错报告报文。</li></ol><p><strong>常用的 ICMP 询问报文有两种：</strong></p><ol><li>回送请求和回答</li><li>时间戳请求和回答</li></ol><h2 id="4-2-ICMP-的应用举例"><a href="#4-2-ICMP-的应用举例" class="headerlink" title="4.2 ICMP 的应用举例"></a>4.2 <strong>ICMP 的应用举例</strong></h2><p>ICMP 的一个重要应用就是分组网间探测 PING（Packet InterNet Groper），用来测试两台主机之间的连通性。直接使用网络层，没有经过运输层的 TCP 或 UDP。</p><h1 id="5-互联网的路由选择协议"><a href="#5-互联网的路由选择协议" class="headerlink" title="5.互联网的路由选择协议"></a>5.互联网的路由选择协议</h1><h2 id="5-1-有关路由选择协议的几个基本概念"><a href="#5-1-有关路由选择协议的几个基本概念" class="headerlink" title="5.1 有关路由选择协议的几个基本概念"></a>5.1 <strong>有关路由选择协议的几个基本概念</strong></h2><p><strong>1.理想的路由算法</strong></p><ol><li>算法必须是正确的和完整的。</li><li>算法在计算上应简单。</li><li>算法应能适应通信量和网络拓扑的变化，这就是说，要有自适应性。</li><li>算法应具有稳定性。</li><li>算法应是公平的。</li><li>算法应是最佳的。路由选择算法应当能够找出最好的路由，使得分组平均时延最小而网络的吞吐量最大。</li></ol><p><strong>2.分层次的路由选择协议</strong></p><ol><li><strong>内部网关协议 IGP：</strong>如 RIP，OSPF</li><li><strong>外部网关协议 EGP：</strong>如 BGP-4</li></ol><h2 id="5-2-内部网关协议-RIP"><a href="#5-2-内部网关协议-RIP" class="headerlink" title="5.2 内部网关协议 RIP"></a>5.2 <strong>内部网关协议 RIP</strong></h2><h3 id="5-2-1-工作原理"><a href="#5-2-1-工作原理" class="headerlink" title="5.2.1 工作原理"></a>5.2.<strong>1 工作原理</strong></h3><p>RIP (Routing Information Protocol）是内部网关协议 IGP 中最先得到广泛使用的协议，中文名称叫做路由信息协议，但很少被使用。</p><p>RIP 是一种分布式的基于距离向量的路由选择协议，是互联网的标准协议，其最大优点就是简单，特点如下：</p><ol><li>仅和相邻路由器交换信息；</li><li>路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表；</li><li>按固定的时间间隔交换路由信息。</li></ol><h3 id="5-2-2-距离向量算法"><a href="#5-2-2-距离向量算法" class="headerlink" title="5.2.2 距离向量算法"></a>5.2.<strong>2 距离向量算法</strong></h3><p>对每一个相邻路由器发送过来的RIP报文，进行距离排序。</p><h3 id="5-2-3-RIP协议的报文格式"><a href="#5-2-3-RIP协议的报文格式" class="headerlink" title="5.2.3 RIP协议的报文格式"></a>5.2.<strong>3 RIP协议的报文格式</strong></h3><p>RIP 报文由首部和路由部分组成。首部占 4 个字节，路由部分最多 25 个路由，最长 $4+20×25&#x3D;504$ 字节。</p><p><img src="/../img/post/computer-network/4-21.jpg"></p><h2 id="5-3-内部网关协议-OSPF"><a href="#5-3-内部网关协议-OSPF" class="headerlink" title="5.3 内部网关协议 OSPF"></a>5.3 <strong>内部网关协议 OSPF</strong></h2><h3 id="5-3-1-OSPF-协议的基本特点"><a href="#5-3-1-OSPF-协议的基本特点" class="headerlink" title="5.3.1 OSPF 协议的基本特点"></a>5.3.<strong>1 OSPF 协议的基本特点</strong></h3><p>开放最短路径优先 OSPF（Open Shortest Path First）。它是为克服 RIP 的缺点在 1989 年开发出来的。OSPF 的原理很简单，但实现起来却较复杂。</p><p>OSPF 最主要的特征就是使用分布式的链路状态协议（link state protocol），而不是像 RIP 那样的距离向量协议。和 RIP 协议相比，OSPF 的三个要点和 RIP 的都不一样：</p><ol><li>向本自治系统中所有路由器发送信息。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但只是路由器知道的部分信息。</li><li>只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。而不像 RIP 那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。</li></ol><p>OSPF 不用 UDP 而是直接用 IP 数据报传送（其IP数据报首部的协议字段值为89）。OSPF构成的数据报很短。这样做可减少路由信息的通信量。数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</p><p>OSPF分组使用 24 字节的固定长度首部，分组的数据部分可以是五种类型分组中的一种：</p><ol><li><strong>版本</strong></li><li><strong>类型：</strong>可以是五种类型分组中的一种</li><li><strong>分组长度</strong></li><li><strong>路由器标识符：</strong>标志发送该分组的路由器的接口的IP地址</li><li><strong>区域标识符：</strong>分组属于的区域的标识符</li><li><strong>检验和：</strong>用来检测分组中的差错</li><li><strong>鉴别类型：</strong>目前只有两种，0(不用）和1（口令)</li><li><strong>鉴别：</strong>鉴别类型为 0 时就填入 0，鉴别类型为 1 则填入 8 个字符的口令</li></ol><p><img src="/../img/post/computer-network/4-22.jpg"></p><h3 id="5-3-2-OSPF-的五种分组类型"><a href="#5-3-2-OSPF-的五种分组类型" class="headerlink" title="5.3.2 OSPF 的五种分组类型"></a>5.3.<strong>2 OSPF 的五种分组类型</strong></h3><ol><li>问候（Hello）分组</li><li>数据库描述（Database Description）分组</li><li>链路状态请求（Link State Request）分组</li><li>链路状态更新（Link State Update）分组,</li><li>链路状态确认（Link State Acknowledgment）分组</li></ol><h2 id="5-4-外部网关协议-BGP"><a href="#5-4-外部网关协议-BGP" class="headerlink" title="5.4 外部网关协议 BGP"></a>5.4 <strong>外部网关协议 BGP</strong></h2><p>边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。BGP 采用了路径向量（path vector）路由选择协议，它与距离向量协议（如 RIP）和链路状态协议（如 OSPF）都有很大的区别。</p><p><img src="/../img/post/computer-network/4-23.jpg"></p><h3 id="5-4-1-BGP-4-四种报文"><a href="#5-4-1-BGP-4-四种报文" class="headerlink" title="5.4.1 BGP-4 四种报文"></a>5.4.1 <strong>BGP-4 四种报文</strong></h3><ol><li>OPEN（打开）报文，用来与相邻的另一个BGP发言人建立关系，使通信初始化。</li><li>UPDATE（更新）报文，用来通告某一路由的信息，以及列出要撤销的多条路由。</li><li>KEEPALIVE（保活）报文，用来周期性地证实邻站的连通性。</li><li>NOTIFICATION（通知）报文，用来发送检测到的差错。</li></ol><h3 id="5-4-2-BGP-报文首部"><a href="#5-4-2-BGP-报文首部" class="headerlink" title="5.4.2 BGP 报文首部"></a>5.4.2 <strong>BGP 报文首部</strong></h3><p><img src="/../img/post/computer-network/4-24.jpg"></p><h2 id="5-5-路由器的结构"><a href="#5-5-路由器的结构" class="headerlink" title="5.5 路由器的结构"></a>5.5 <strong>路由器的结构</strong></h2><h3 id="5-5-1-路由器的结构"><a href="#5-5-1-路由器的结构" class="headerlink" title="5.5.1 路由器的结构"></a>5.5.1 路由器的结构</h3><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。</p><p><img src="/../img/post/computer-network/4-25.jpg"></p><p><img src="/../img/post/computer-network/4-26.jpg"></p><h3 id="5-5-2-交换结构"><a href="#5-5-2-交换结构" class="headerlink" title="5.5.2 交换结构"></a>5.5.2 交换结构</h3><p>交换结构是路由器的关键构件 [KURO13]。正是这个交换结构把分组从一个输入端口转移到某个合适的输出端口。</p><p><strong>三种交换方法：</strong></p><ol><li>通过储存器交换</li><li>通过总线交换：同一时刻只能有一个分组，但无需处理机干预</li><li>通过纵横交换：互连网络，有 2N 条总线，N 个输入&#x2F;出端口</li></ol><p><img src="/../img/post/computer-network/4-27.jpg"></p><h1 id="6-IPv6"><a href="#6-IPv6" class="headerlink" title="6.IPv6"></a>6.IPv6</h1><h2 id="6-1-IPv6-发基本首部"><a href="#6-1-IPv6-发基本首部" class="headerlink" title="6.1 IPv6 发基本首部"></a>6.1 IPv6 发基本首部</h2><p><strong>IPv6 所引进的主要变化如下：</strong></p><ol><li>更大的地址空间。IPv6 把地址从 IPv4 的 32 位增大到 4 倍到 128 位，使地址空间增大了 $2^{96}$ 倍；</li><li>扩展的地址层次结构；</li><li>灵活的首部格式。IPv6 数据报的首部和 IPv4 的并不兼容；</li><li>改进的选项。IPv6 允许数据报包含有选项的控制信息；</li><li>允许协议继续扩充；</li><li>支持即插即用（即自动配置），因此 IPv6 不需要使用 DHCP；</li><li>支持资源的预分配；</li><li>IPv6 首部改为 8 字节对齐（即首部长度必须是8字节的整数倍）。</li></ol><p><img src="/../img/post/computer-network/4-28.jpg"></p><p><strong>与 IPv4 相比，IPv6 对首部中的某些字段进行了如下的更改：</strong></p><ol><li>取消了首部长度字段，因为它的首部长度是固定的（40字节）；</li><li>取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能；</li><li>取消了总长度字段，改用有效载荷长度字段；</li><li>取消了标识、标志和片偏移字段，因为这些功能已包含在分片扩展首部中。把TTL字段改称为跳数限制字段，但作用是一样的（名称与作用更加一致)。</li><li>取消了协议字段，改用下一个首部字段；</li><li>取消了检验和字段，这样就加快了路由器处理数据报的速度。我们知道，在数据链路层对检测出有差错的帧就丢弃；</li><li>取消了选项字段，而用扩展首部来实现选项功能。</li></ol><p>由于把首部中不必要的功能取消了，使得 IPv6 首部的字段数减少到只有 8 个（虽然首部长度增大了一倍）。下面解释 IPv6 基本首部中各字段的作用：</p><p><img src="/../img/post/computer-network/4-29.jpg"></p><ol><li><strong>版本：</strong>占4位，对 IPv6 该字段是 6。</li><li><strong>通信量类：</strong>占8位。这是为了区分不同的 IPv6 数据报的类别或优先级。</li><li><strong>流标号：</strong>占20 位。IPv6 的一个新的机制是支持资源预分配。</li><li><strong>有效载荷长度：</strong>占16位。它指明 IPv6 数据报除基本首部以外的字节数。这个字段的最大值是 64 KB（65535字节）。</li><li><strong>下一个首部：</strong>占8位。它相当于 IPv4 的协议字段或可选字段。</li><li><strong>跳数限制：</strong>占8位。用来防止数据报在网络中无限期地存在。</li><li><strong>源地址：</strong>占128位。是数据报的发送端的P地址。</li><li><strong>目的地址：</strong>占128位。是数据报的接收端的IP地址。</li></ol><h2 id="6-2-IPv6-的地址"><a href="#6-2-IPv6-的地址" class="headerlink" title="6.2 IPv6 的地址"></a>6.2 IPv6 的地址</h2><ol><li><strong>单播（unicast）：</strong>单播就是传统的点对点通信。</li><li><strong>多播（multicast）：</strong>多播是一点对多点的通信，数据报发送到一组计算机中的每一个。IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。</li><li><strong>任播（anycast）：</strong>这是 IPv6 增加的一种类型。任播的终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个。</li></ol><h3 id="6-2-1-IPv6-冒号十六进制记法"><a href="#6-2-1-IPv6-冒号十六进制记法" class="headerlink" title="6.2.1 IPv6 冒号十六进制记法"></a>6.2.1 IPv6 冒号十六进制记法</h3><p>在十六进制记法中，允许把数字前面的 0 省略：</p><p>$$<br>FF05:0:0:0:0 :0:0:B3<br>$$</p><p>可压缩为：</p><p>$$<br>FF05::B3<br>$$</p><p><img src="/../img/post/computer-network/4-30.jpg"></p><p><strong>未指明地址：</strong>这是 16 字节的全 0 地址，可缩写为两个冒号 “::”。这个地址不能用作目的地址，而只能为某台主机当作源地址使用，条件是这台主机还没有配置到一个标准的IP地址。这类地址仅此一个。</p><p><strong>环回地址：</strong>IPv6 的环回地址是 0:0:0:0:0:0:0:1，可缩写为 ::1。它的作用和 IPv4 的环回地址一样。这类地址也是仅此一个。</p><p><strong>多播地址：</strong>功能和 IPv4 的一样。这类地址占 IPv6 地址总数的 1&#x2F;256。</p><p><strong>本地链路单播地址：</strong>有些单位的网络使用 TCP&#x2F;IP 协议，但并没有连接到互联网上。连接在这样的网络上的主机都可以使用这种本地地址进行通信，但不能和互联网上的其他主机通信。这类地址占 IPv6 地址总数的 1&#x2F;1024。</p><p><strong>全球单播地址：</strong>IPv6 的这一类单播地址是使用得最多的一类。</p><h2 id="6-3-从-IPv4-向-IPv6-过渡"><a href="#6-3-从-IPv4-向-IPv6-过渡" class="headerlink" title="6.3 从 IPv4 向 IPv6 过渡"></a>6.3 从 IPv4 向 IPv6 过渡</h2><h3 id="6-3-1-双协议栈"><a href="#6-3-1-双协议栈" class="headerlink" title="6.3.1 双协议栈"></a>6.3.1 双协议栈</h3><p>双协议栈（dual stack）是指在完全过渡到 IPv6 之前，使一部分主机（或路由器）装有双协议栈：一个 IPv4 和一个 IPv6。因此双协议栈主机（或路由器）既能够和 IPv6 的系统通信，又能够和 IPv4 的系统通信。双协议栈的主机（或路由器）记为 IPv6&#x2F;IPv4，表明它同时具有两种IP地址：一个 IPv6 地址和一个 IPv4 地址。</p><p><img src="/../img/post/computer-network/4-31.jpg"></p><h3 id="6-3-2-隧道技术"><a href="#6-3-2-隧道技术" class="headerlink" title="6.3.2 隧道技术"></a>6.3.2 隧道技术</h3><p>在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4 数据报。</p><p><img src="/../img/post/computer-network/4-32.jpg"></p><h2 id="6-4-ICMPv6"><a href="#6-4-ICMPv6" class="headerlink" title="6.4 ICMPv6"></a>6.4 ICMPv6</h2><p><strong>ICMP：</strong>IPv4 反馈差错信息</p><p><strong>ICMPv6：</strong>IPv6 反馈差错信息</p><p>ICMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播通信。</p><p><img src="/../img/post/computer-network/4-33.jpg"></p><h1 id="7-IP多播"><a href="#7-IP多播" class="headerlink" title="7.IP多播"></a>7.IP多播</h1><h2 id="7-1-IP多播的基本概念"><a href="#7-1-IP多播的基本概念" class="headerlink" title="7.1 IP多播的基本概念"></a>7.1 IP多播的基本概念</h2><p>R1 转发分组同时复制三个副本，向 R2、R3、R4 转发。<strong>多播数据包不产生 ICMP 差错报文。</strong></p><p><img src="/../img/post/computer-network/4-34.jpg"></p><p>其实多播组的标识符就是 IP 地址中的 D 类地址。D 类 IP 地址的前四位是 1110，因此 D 类地址范围是 224.0.0.0 到 239.255.255.255。我们就用每一个D类地址标志一个多播组。这样，D 类地址共可标志 22 个多播组，也就是说，在同一时间可以允许有超过 2.6 亿的多播组在互联网上运行。</p><p>多播数据报也是“尽最大努力交付”，不保证一定能够交付多播组内的所有成员。因此，多播数据报和一般的 IP 数据报的区别就是它使用 D 类 IP 地址作为目的地址，并且首部中的协议字段值是 2，表明使用网际组管理协议 IGMP。<strong>多播地址只能用于目的地址，而不能用于源地址。</strong></p><h2 id="7-2-在局域网上进行硬件多播"><a href="#7-2-在局域网上进行硬件多播" class="headerlink" title="7.2 在局域网上进行硬件多播"></a>7.2 在局域网上进行硬件多播</h2><p>由于多播 IP 地址与以太网硬件地址的映射关系不是唯一的，因此收到多播数据报的主机，还要在 IP 层利用软件进行过滤。</p><h2 id="7-3-网际组管理协议IGMP和多播路由选择协议"><a href="#7-3-网际组管理协议IGMP和多播路由选择协议" class="headerlink" title="7.3 网际组管理协议IGMP和多播路由选择协议"></a>7.3 网际组管理协议IGMP和多播路由选择协议</h2><h3 id="7-3-1-IP-多播需要两种协议"><a href="#7-3-1-IP-多播需要两种协议" class="headerlink" title="7.3.1 IP 多播需要两种协议"></a>7.3.1 IP 多播需要两种协议</h3><ol><li>网际组管理协议 IGMP</li><li>多播路由选择协议</li></ol><h3 id="7-3-2-网际组管理协议-IGMP"><a href="#7-3-2-网际组管理协议-IGMP" class="headerlink" title="7.3.2 网际组管理协议 IGMP"></a>7.3.2 网际组管理协议 IGMP</h3><p>和网际控制报文协议 ICMP 相似，IGMP 使用 IP 数据报传递其报文（即 IGMР 报文加上 IP 首部构成 IP 数据报），但它也向 IP 提供服务。因此，我们不把 IGMP 看成是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。</p><p><strong>IGMP 的工作可分为两个阶段：</strong></p><ul><li><strong>第一阶段：</strong>当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器。</li><li><strong>第二阶段：</strong>组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。只要有一台主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一台主机响应，多播路由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。</li></ul><h3 id="7-3-3-多播路由选择协议（尚未标准化）"><a href="#7-3-3-多播路由选择协议（尚未标准化）" class="headerlink" title="7.3.3 多播路由选择协议（尚未标准化）"></a>7.3.3 多播路由选择协议（尚未标准化）</h3><p><strong>在转发多播数据报时使用了以下的三种方法：</strong></p><ol><li><strong>洪泛与剪除：</strong>这种方法适合于较小的多播组。</li><li><strong>隧道技术：</strong>适用于多播组的位置在地理上很分散的情况。</li><li><strong>基于核心的发现技术：</strong>这种方法对于多播组的大小在较大范围内变化时都适合。</li></ol><h1 id="8-虚拟专用网VPN和网络地址转换NAT"><a href="#8-虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="8.虚拟专用网VPN和网络地址转换NAT"></a>8.虚拟专用网VPN和网络地址转换NAT</h1><h2 id="8-1-虚拟专用网-VPN"><a href="#8-1-虚拟专用网-VPN" class="headerlink" title="8.1 虚拟专用网 VPN"></a>8.1 虚拟专用网 VPN</h2><p>专用地址只能用做本地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。</p><ul><li>10.0.0.0 到 10.255.255.255（或记为10.0.0.0&#x2F;8，它又称为24位块）</li><li>172.16.0.0 到 172.31.255.255（或记为172.16.0.0&#x2F;12，它又称为20位块）</li><li>192.168.0.0到192.168.255.255（或记为192.168.0.0&#x2F;16，它又称为16位块）</li></ul><p>采用这样的专用 IP 地址的互连网络称为专用互联网或本地互联网，或更简单些，就叫做专用网。</p><h2 id="8-2-网络地址转换-NAT"><a href="#8-2-网络地址转换-NAT" class="headerlink" title="8.2 网络地址转换 NAT"></a>8.2 网络地址转换 NAT</h2><p>专用网内主机想与互联网上主机通信（并不要加密），用 NAT，路由器要装 NAT 软件，并且至少还要有一个全球 IP。</p><p><img src="/../img/post/computer-network/4-35.jpg"></p><h1 id="9-多协议标记交换-MPLS"><a href="#9-多协议标记交换-MPLS" class="headerlink" title="9.多协议标记交换 MPLS"></a>9.多协议标记交换 MPLS</h1><p>MPLS 利用面向连接技术，使每个分组携带一个叫做标记（label）的小整数。当分组到达交换机（即标记交换路由器）时，交换机读取分组的标记，并用标记值来检索分组转发表。这样就比查找路由表来转发分组要快得多。</p><p><strong>MPLS 具有以下三个方面的特点：</strong></p><ol><li>支持面向连接的服务质量</li><li>支持流量工程，平衡网络负载</li><li>有效地支持虚拟专用网VPN</li></ol><h2 id="9-1-MPLS-的工作原理"><a href="#9-1-MPLS-的工作原理" class="headerlink" title="9.1 MPLS 的工作原理"></a>9.1 MPLS 的工作原理</h2><h3 id="9-1-1-基本工作过程"><a href="#9-1-1-基本工作过程" class="headerlink" title="9.1.1 基本工作过程"></a>9.1.1 基本工作过程</h3><ol><li>MPLS 域中的各 LSR 使用专门的标记分配协议 LDP 交换报文，并找出和特定标记相对应的路径，即标记交换路径 LSP。</li><li>当一个 IP 数据报进入到 MPLS 域时，MPLS入口结点就给它打上标记，并按照转发表把它转发给下一个 LSR。</li><li>由于在全网内统一分配全局标记数值是非常困难的，因此一个标记仅仅在两个标记交换路由器 LSR 之间才有意义。分组每经过一个 LSR， LSR 就要做两件：一是转发，二是更换新的标记，即把入标记更换成为出标记。</li><li>当 IP 数据报离开 MPLS 域时，MPLS出口结点就把 MPLS 的标记去除，把 IP 数据报交付非 MPLS 的主机或路由器，以后就按照普通的转发方法进行转发。</li></ol><h3 id="9-1-2-转发等价类-FEC"><a href="#9-1-2-转发等价类-FEC" class="headerlink" title="9.1.2 转发等价类 FEC"></a>9.1.2 转发等价类 FEC</h3><p>MPLS 有个很重要的概念就是转发等价类 FEC（Forwarding Equivalence Class）。所谓 “转发等价类” 就是路由器按照同样方式（表示从同样接口转发到同样的下一跳地址，并且具有同样服务类别和同样丢弃优先级等）对待的 IP 数据报的集合。</p><h2 id="9-2-MPLS首部的位置与格式"><a href="#9-2-MPLS首部的位置与格式" class="headerlink" title="9.2 MPLS首部的位置与格式"></a>9.2 MPLS首部的位置与格式</h2><p>从层次的角度看，MPLS 首部就处在第二层和第三层之间。在把加上  MPLS 首部的 IP 数据报封装成以太网帧时，以太网的类型字段在单播的情况下设置为$8847_{16}$，而在多播的情况下为 $8848_{16}$ 。这样，接收方可以用帧的类型来判决这个帧是携带了 MPLS 标记还是一个常规的 IP 数据报。</p><p><img src="/../img/post/computer-network/4-36.jpg"></p><p><strong>MPLS 首部共包括以下四个字段：</strong></p><ol><li><strong>标记值：</strong>占20位。理论上可使用标记的所有20位，因而可以同时容纳高达 $2^{20}$ 个流（即1048576个流)。但是，实际上几乎没有哪个MPLS实例会使用很大数目的流，因为通常需要管理员人工管理和设置每条交换路径。</li><li><strong>试验：</strong>占3位，目前保留用于试验。</li><li><strong>栈 S：</strong>占1位，在有“标记栈”时使用。</li><li><strong>生存时间 TTL：</strong>占8位，用来防止 MPLS分组在MPLS域中兜圈子。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络 第三章：数据链路层</title>
    <link href="/computer-network-3/"/>
    <url>/computer-network-3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-使用点对点信道的数据链路层"><a href="#1-使用点对点信道的数据链路层" class="headerlink" title="1.使用点对点信道的数据链路层"></a>1.使用点对点信道的数据链路层</h1><p><img src="/../img/post/computer-network/3-1.jpg"></p><h2 id="1-1-数据链路和帧"><a href="#1-1-数据链路和帧" class="headerlink" title="1.1 数据链路和帧"></a>1.1 数据链路和帧</h2><p><strong>链路：</strong>从一个结点到相邻结点的一段物理线路（有线或无线)，而中间没有任何其他的交换结点。</p><p><strong>数据链路：</strong>链路上必要的通信协议来控制这些数据的传输。（逻辑链路就是数据链路）</p><p><strong>帧：</strong>点对点信道的数据链路层的协议数据单元。</p><p><img src="/../img/post/computer-network/3-2.jpg"></p><p><strong>点对点信道的数据链路层在进行通信时的主要步骤如下：</strong></p><ol><li>结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。</li><li>结点A把封装好的帧发送给结点B的数据链路层。</li><li>若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报交给上面的网络层;否则丢弃这个帧。</li></ol><h2 id="1-2-三个基本问题"><a href="#1-2-三个基本问题" class="headerlink" title="1.2 三个基本问题"></a>1.2 三个基本问题</h2><h3 id="1-2-1-封装成帧"><a href="#1-2-1-封装成帧" class="headerlink" title="1.2.1 封装成帧"></a>1.2.<strong>1 封装成帧</strong></h3><p>封装成帧就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。分组交换的一个重要概念就是：<strong>所有在互联网上传送的数据都以分组（即IP数据报）为传送单位。</strong></p><p><img src="/../img/post/computer-network/3-3.jpg"></p><p>当数据是由可打印的 ASCII 码组成的文本文件时，其中可打印的有 95  个，而不可打印的控制字符有 33 个。</p><p>请注意，SOH 和 EOT 都是控制字符的名称，它们的十六进制编码分别是01（二进制是00000001）和 04（二进制是00000100）。</p><p><img src="/../img/post/computer-network/3-4.jpg"></p><h3 id="1-2-2-透明传输"><a href="#1-2-2-透明传输" class="headerlink" title="1.2.2 透明传输"></a>1.2.<strong>2 透明传输</strong></h3><p>当传送的帧是用文本文件组成的帧时（文本文件中的字符都是从键盘上输入的），其数据部分显然不会出现像 SOH 或 EOT 这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。</p><p>但当数据部分是非 ASCII 码的文本文件时（如二进制代码的计算机程序或图像等），情况就不同了。如果数据中的某个字节的二进制代码恰好和 SOH 致 EOT 一致，就会发生错误：</p><p><img src="/../img/post/computer-network/3-5.jpg"></p><h3 id="1-2-3-差错检测"><a href="#1-2-3-差错检测" class="headerlink" title="1.2.3 差错检测"></a>1.2.<strong>3 差错检测</strong></h3><p><strong>比特差错：</strong>比特在传输过程中可能会产生差错，1 成 0，0 成 1。</p><p><strong>循环冗余检验 CRC：</strong>一种模2运算后的检错方法。</p><p>在数据链路层若仅仅使用循环冗余检验 CRC 差错检测技术，则只能做到对帧的无差错接受，即：“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。</p><h1 id="2-点对点协议-PPP"><a href="#2-点对点协议-PPP" class="headerlink" title="2.点对点协议 PPP"></a>2.点对点协议 PPP</h1><h2 id="2-1-PPP-协议的特点"><a href="#2-1-PPP-协议的特点" class="headerlink" title="2.1 PPP 协议的特点"></a>2.1 PPP 协议的特点</h2><h3 id="2-1-1-PPP-协议应满足的需求"><a href="#2-1-1-PPP-协议应满足的需求" class="headerlink" title="2.1.1 PPP 协议应满足的需求"></a>2.1.1 <strong>PPP 协议应满足的需求</strong></h3><ol><li><strong>简单：</strong>对数据链路层的帧，不需要纠错，不需要序号，也不需要流量控制。</li><li><strong>封装成帧：</strong>必须规定特殊的字符作为帧定界符。</li><li><strong>透明性：</strong>透明传输。</li><li><strong>多种网络层协议：</strong>在同一条物理链路上同时支持多种网络层协议的运行。</li><li><strong>多种类型链路：</strong>除了要支持多种网络层的协议外，PPP 还必须能够在多种类型的链路上运行。</li><li><strong>差错检测：</strong>必须能够对接收端收到的帧进行检测</li><li><strong>检测链接状态：</strong>自动检测出链路是否处于正常工作状态。</li><li><strong>最大传送单元：</strong>设置 MTU 最大传送单元。</li><li><strong>网络层地址协商：</strong>PPP协议必须提供一种机制使通信的两个网络层的实体能够通过协商知道或能够配置彼此的网络层地址。</li><li><strong>数据压缩协商：</strong>必须提供一种方法来协商使用数据压缩算法。</li></ol><h3 id="2-1-2-PPP-协议的组成"><a href="#2-1-2-PPP-协议的组成" class="headerlink" title="2.1.2 PPP 协议的组成"></a>2.1.<strong>2 PPP 协议的组成</strong></h3><ol><li>一个将 IP 数据报封装到串行链路的方法。PPP 既支持异步链路（无奇偶检验的8比特数据），也支持面向比特的同步链路。</li><li>一个用来建立、配置和测试数据链路连接的链路控制协议 LCP（Link ControlProtocol）。</li><li>一套网络控制协议 NCP (Network Control Protocol），其中的每一个协议支持不同的网络层协议，如 IP、OSI 的网络层、DECnet，以及AppleTalk 等。</li></ol><h2 id="2-2-PPP-协议的帧格式"><a href="#2-2-PPP-协议的帧格式" class="headerlink" title="2.2 PPP 协议的帧格式"></a>2.2 PPP 协议的帧格式</h2><p><img src="/../img/post/computer-network/3-6.jpg"></p><table><thead><tr><th>F</th><th>标志字段</th></tr></thead><tbody><tr><td>A</td><td>地址字段</td></tr><tr><td>C</td><td>标志字段</td></tr></tbody></table><p>当信息字段中出现和标志字段一样的比特 (0x7E) 组合时，就必须采取一些措施：</p><p>见到 5 个 1，即 <code>11111</code>，要在后面添加一个 0。</p><p>见到 <code>0x7E</code>，要用转义字符 <code>0x7D</code>。<code>0x7E</code> 改为 <code>0x7D 0x5E</code>。</p><p>见到 <code>0x7D</code>，与转义字符相同。<code>0x7D</code> 改为 <code>0x7D 0x5D</code>。</p><p>见到 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前加入一个 0x7D 字节，同时该字符的编码也要改变。例如出现 <code>0x03</code>，要改为 <code>0x7D 0x23</code>。</p><h3 id="2-2-1-字节填充"><a href="#2-2-1-字节填充" class="headerlink" title="2.2.1 字节填充"></a>2.2.<strong>1 字节填充</strong></h3><p>当 PPP 使用异步传输时，把每一个 0x7DE 转变成 2 字节序列 0x7D, 0x5D。</p><p>若信息字段中出现 ASCII 码的控制字符（即数值小于0x20的字符），则在该字符前加 0x7D。</p><h3 id="2-2-2-零比特填充"><a href="#2-2-2-零比特填充" class="headerlink" title="2.2.2 零比特填充"></a>2.2.<strong>2 零比特填充</strong></h3><p>当 PPP 使用同步传输（在 SONET&#x2F;SDH 链路）时，只要发现有 5 个连续 1，则立即填入一个 0。</p><h2 id="2-3-PPP-协议的工作状态"><a href="#2-3-PPP-协议的工作状态" class="headerlink" title="2.3 PPP 协议的工作状态"></a>2.3 PPP 协议的工作状态</h2><p>PPP 链路的起始和终止状态永远是<strong>链路静止状态</strong>。</p><p><img src="/../img/post/computer-network/3-7.jpg"></p><h1 id="3-使用广播信道的数据链路层"><a href="#3-使用广播信道的数据链路层" class="headerlink" title="3.使用广播信道的数据链路层"></a>3.使用广播信道的数据链路层</h1><h2 id="3-1-局域网的数据链路层"><a href="#3-1-局域网的数据链路层" class="headerlink" title="3.1 局域网的数据链路层"></a>3.1 局域网的数据链路层</h2><h3 id="3-1-1-局域网最主要的特点"><a href="#3-1-1-局域网最主要的特点" class="headerlink" title="3.1.1 局域网最主要的特点"></a>3.1.<strong>1 局域网最主要的特点</strong></h3><p>网络为一个单位所拥有，且地理范围和站点数目均有限。</p><h3 id="3-1-2-局域网一些主要优点"><a href="#3-1-2-局域网一些主要优点" class="headerlink" title="3.1.2 局域网一些主要优点"></a>3.1.<strong>2 局域网一些主要优点</strong></h3><ol><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性（reliability）、可用性（availability）和生存性（survivability）。</li></ol><h3 id="3-1-3-局域网按网络拓扑进行分类"><a href="#3-1-3-局域网按网络拓扑进行分类" class="headerlink" title="3.1.3 局域网按网络拓扑进行分类"></a>3.1.<strong>3 局域网按网络拓扑进行分类</strong></h3><p><img src="/../img/post/computer-network/3-8.jpg"></p><h3 id="3-1-4-局域网的共享信道"><a href="#3-1-4-局域网的共享信道" class="headerlink" title="3.1.4 局域网的共享信道"></a>3.1.<strong>4 局域网的共享信道</strong></h3><p>局域网使用频分、时分、波分、码分复用等，代价较高不合适。所以使用动态媒体接入控制，即多点接入。</p><h3 id="3-1-5-动态媒体接入控制（多点接入）"><a href="#3-1-5-动态媒体接入控制（多点接入）" class="headerlink" title="3.1.5 动态媒体接入控制（多点接入）"></a>3.1.5 <strong>动态媒体接入控制（多点接入）</strong></h3><p>特点是信道并非在用户通信时固定分配给用户。</p><ol><li><strong>随机接入：</strong>特点是所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生碰撞（即发生了冲突)，使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议（CSMA&#x2F;CD）。</li><li><strong>受控接入：</strong>特点是用户不能随机地发送信息而必须服从一定的控制。这类的典型代表有分散控制的令牌环局域网和集中控制的多点线路探询（polling），或称为轮询。</li></ol><p>随机接入的以太网将被重点讨论。受控接入则由于目前在局域网中使用得较少。</p><h3 id="3-1-6-以太网的两个标准"><a href="#3-1-6-以太网的两个标准" class="headerlink" title="3.1.6 以太网的两个标准"></a>3.1.6 <strong>以太网的两个标准</strong></h3><table><thead><tr><th></th><th>DIX Ethernet V2</th><th>802.3</th></tr></thead><tbody><tr><td>推出</td><td>DEC、因特尔、施乐</td><td>IEEE</td></tr><tr><td>时间</td><td>1980年</td><td>1983年</td></tr></tbody></table><p>太网的两个标准 DIX Ethernet V2 与 IEEE 的 802.3 标准只有很小的差别，因此很多人也常把 802.3 局域网简称为“以太网”。</p><p>严格上：</p><ul><li><strong>以太网：</strong>DIX Ethernet V2 标准的局域网</li><li><strong>802.3：</strong>802.3 标准的局域网</li></ul><h3 id="3-1-7-适配器的作用"><a href="#3-1-7-适配器的作用" class="headerlink" title="3.1.7 适配器的作用"></a>3.1.7 <strong>适配器的作用</strong></h3><p>计算机与外界局域网的连接是通过通信适配器（adapter）进行的。适配器本来是在主机箱内插入的一块网络接口板，这种接口板又称为网络接口卡 NIC（Network Interface Card）或简称为“网卡”。</p><blockquote><p>💡 由于现在计算机主板上都已经嵌入了这种适配器，不再使用单独的网卡了，因此适配器这个术语更准确。</p></blockquote><p>适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的，而适配器和计算机之间的通信则是通过计算机主板上的IO总线以并行传输方式进行的。</p><p><img src="/../img/post/computer-network/3-9.jpg"></p><h2 id="3-2-CSMA-x2F-CD-协议"><a href="#3-2-CSMA-x2F-CD-协议" class="headerlink" title="3.2 CSMA&#x2F;CD 协议"></a>3.2 CSMA&#x2F;CD 协议</h2><ol><li>载波监听多点接入&#x2F;碰撞检测 CSMA&#x2F;CD</li><li>以太网发送的数据都使用曼彻斯特编码。</li></ol><p><strong>CSMA&#x2F;CD 要点：</strong></p><ul><li>多点接入：总线型网络</li><li>载波监听：不停的检测信道</li><li>碰撞检测：边发送边监听，也叫冲突检测</li></ul><p><img src="/../img/post/computer-network/3-10.jpg"></p><p>显然，CSMA&#x2F;CD 一个站不可能同时进行发送和接收（但必须边发送边监听信道)。因此使用CSMA&#x2F;CD协议的以太网不可能进行全双工通信而只能进行双向交替通信(半双工通信)。</p><p>以太网使用截断二进制指数退避（truncated binary exponential backoff）算法来确定碰撞后重传的时机。截断二进制指数退避算法并不复杂。这种算法让发生碰撞的站在停止发送数据后，不是等待信道变为空闲后就立即再发送数据，而是推迟（这叫做退避）一个随机的时间。这点很容易理解，因为如果几个发生碰撞的站都在监听信道，那么都会同时发现信道变成了空闲。如果大家都同时再重新发送，那么肯定又会发生碰撞。</p><blockquote><p>💡 凡长度小于64字节的帧都是由于冲突而异常中止的无效帧。</p></blockquote><h2 id="3-3-使用集线器的星型拓扑"><a href="#3-3-使用集线器的星型拓扑" class="headerlink" title="3.3 使用集线器的星型拓扑"></a>3.3 使用集线器的星型拓扑</h2><p><strong>集线器的特点：</strong></p><ol><li>逻辑上仍是一个总线网，用 CSMA&#x2F;CD 协议，同一时刻至多只允许一个站发送数据。</li><li>一个集线器有许多接口。</li><li>工作在物理层，每个接口仅仅简单的转发比特。</li><li>采用了专门的芯片，进行自适应串音回波抵消。</li></ol><p><img src="/../img/post/computer-network/3-11.jpg"></p><h2 id="3-4-以太网的信道利用率"><a href="#3-4-以太网的信道利用率" class="headerlink" title="3.4 以太网的信道利用率"></a>3.4 以太网的信道利用率</h2><p>一个站在发送帧时出现了碰撞。经过一个争用期 $2τ$ 后（$τ$是以太网单程端到端传播时延），可能又出现了碰撞。这样经过若干个争用期后，一个站发送成功了。</p><p><img src="/../img/post/computer-network/3-12.jpg"></p><p>要提高以太网的信道利用率，就必须减小 $τ$ 与 $T0$  之比。在以太网中定义了参数 $a$，它是以太网单程端到端时延 $τ$ 与帧的发送时间 $T0$ 之比：</p><p>$$<br>a&#x3D;\dfrac{τ}{T_0}<br>$$</p><p>当 $a→0$ 时，表示只要一发生碰撞，就立即可以检测出来，并立即停止发送，因而信道资源被浪费的时间非常非常少。反之，参数 $a$ 越大，表明争用期所占的比例越大，使得信道利用率明显降低。</p><h2 id="3-5-以太网的-MAC-层"><a href="#3-5-以太网的-MAC-层" class="headerlink" title="3.5 以太网的 MAC 层"></a>3.5 以太网的 MAC 层</h2><h3 id="3-5-1-MAC-层的硬件地址"><a href="#3-5-1-MAC-层的硬件地址" class="headerlink" title="3.5.1 MAC 层的硬件地址"></a>3.5.1 <strong>MAC 层的硬件地址</strong></h3><p>MAC地址，即硬件地址、物理地址。</p><h3 id="3-5-2-MAC-帧的格式"><a href="#3-5-2-MAC-帧的格式" class="headerlink" title="3.5.2 MAC 帧的格式"></a>3.5.<strong>2 MAC 帧的格式</strong></h3><p>DIX Ethernet V2 标准：</p><p><img src="/../img/post/computer-network/3-13.jpg"></p><blockquote><p>💡 首部没有帧长度（或数据长度）字段，但是可以通过曼彻斯特编码送完毕后接口上的电压也就不再变化了，这样就能确定数据字段的结束位置。</p></blockquote><h1 id="4-拓展的以太网"><a href="#4-拓展的以太网" class="headerlink" title="4.拓展的以太网"></a>4.拓展的以太网</h1><h2 id="4-1-在物理层拓展以太网"><a href="#4-1-在物理层拓展以太网" class="headerlink" title="4.1 在物理层拓展以太网"></a>4.1 在物理层拓展以太网</h2><p>扩展主机和集线器之间的距离的一种简单方法就是使用光纤（通常是一对光纤）和一对光纤调制解调器。</p><p><img src="/../img/post/computer-network/3-14.jpg"></p><p>如果使用多个集线器，就可以连接成覆盖更大范围的多级星形结构的以太网。</p><p><img src="/../img/post/computer-network/3-15.jpg"></p><p><strong>好处：</strong></p><ol><li>使这个学院不同系的以太网上的计算机能够进行跨系的通信。</li><li>扩大了以太网覆盖的地理范围。</li></ol><p><strong>缺点：</strong></p><ol><li>把多个碰撞域变成一个碰撞域。</li><li>不同系用不同以太网技术就不能用集线器连接。</li></ol><h2 id="4-2-在数据链路层拓展以太网"><a href="#4-2-在数据链路层拓展以太网" class="headerlink" title="4.2 在数据链路层拓展以太网"></a>4.2 在数据链路层拓展以太网</h2><h3 id="4-2-1-以太网交换机的特点"><a href="#4-2-1-以太网交换机的特点" class="headerlink" title="4.2.1 以太网交换机的特点"></a>4.2.<strong>1 以太网交换机的特点</strong></h3><ol><li>实质是一个多接口的网桥。</li><li>独占传输媒体，无碰撞地传输数据。</li><li>即插即用，交换表通过自学习算法自动逐渐建立。</li><li>速率超软件网桥，性能超集线器。</li></ol><h3 id="4-2-2-以太网交换机的自学习功能"><a href="#4-2-2-以太网交换机的自学习功能" class="headerlink" title="4.2.2 以太网交换机的自学习功能"></a>4.2.<strong>2 以太网交换机的自学习功能</strong></h3><p>查找交换表，如果有，就不再进行广播。</p><p><img src="/../img/post/computer-network/3-16.jpg"></p><p>但有时为了增加网络的可靠性，在使用以太网交换机组网时，往往会增加一些冗余的链路。</p><h3 id="4-2-3-从总线以太网到星型以太网"><a href="#4-2-3-从总线以太网到星型以太网" class="headerlink" title="4.2.3 从总线以太网到星型以太网"></a>4.2.<strong>3 从总线以太网到星型以太网</strong></h3><p>总线以太网使用 CSMA&#x2F;CD 协议，以半双工方式工作。</p><p>以太网交换机不使用共享总线，没有碰撞问题，因此不使用 CSMA&#x2F;CD 协议，而是以全双工方式工作，但是帧结构未改变，仍然采用以太网的帧结构。</p><h2 id="4-3-虚拟局域网"><a href="#4-3-虚拟局域网" class="headerlink" title="4.3 虚拟局域网"></a>4.3 虚拟局域网</h2><p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机属于哪一个 VLAN。</p><blockquote><p>💡 虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</p></blockquote><p>例如，计算机 $B_1$~$B_3$ 同属于虚拟局域网 VLAN2。当 $B_1$ 向工作组内成员发送数据时，$B_2$ 和 $B_3$ 将会收到广播的信息，$A_1$ 、$A_2$ 和 $C_1$ 都不会收到。</p><p><img src="/../img/post/computer-network/3-17.jpg"></p><p>VLAN 的以太网帧的首部增加了4个字节。最后的 12 位是该虚拟局域网 VLAN 标识符 VID，它唯一地标志了这个以太网帧属于哪一个 VLAN。</p><p><img src="/../img/post/computer-network/3-18.jpg"></p><h1 id="5-高速以太网"><a href="#5-高速以太网" class="headerlink" title="5.高速以太网"></a>5.高速以太网</h1><h2 id="5-1-100BASE-T-以太网"><a href="#5-1-100BASE-T-以太网" class="headerlink" title="5.1 100BASE-T 以太网"></a>5.1 100BASE-T 以太网</h2><p>100BASE-T 是在双绞线上传送 100 Mbit&#x2F;s 基带信号的星形拓扑以太网，仍使用 IEEE802.3 的 CSMA&#x2F;CD 协议。</p><h2 id="5-2-吉比特以太网"><a href="#5-2-吉比特以太网" class="headerlink" title="5.2 吉比特以太网"></a>5.2 吉比特以太网</h2><p>吉比特以太网的标准 IEEE 802.3z 有以下几个特点：</p><ol><li>允许在1 Gbit&#x2F;s 下以全双工和半双工两种方式工作。</li><li>使用 IEEE 802.3 协议规定的帧格式。</li><li>在半双工方式下使用 CSMA&#x2F;CD 协议，而在全双工方式不使用 CSMA&#x2F;CD 协议。</li><li>与 10BASE-T 和 100BASE-T 技术向后兼容。</li></ol><h2 id="5-3-10吉比特以太网和更快的以太网"><a href="#5-3-10吉比特以太网和更快的以太网" class="headerlink" title="5.3 10吉比特以太网和更快的以太网"></a>5.3 10吉比特以太网和更快的以太网</h2><p>10GE 的帧格式与 10 Mbit&#x2F;s，100 Mbit&#x2F;s 和 1Gbit&#x2F;s 以太网的帧格式完全相同，并保留了 802.3 标准规定的以太网最小帧长和最大帧长。这就使用户在将其已有的以太网进行升级时，仍能和较低速率的以太网很方便地通信。</p><p>10GE 只工作在全双工方式，因此不存在争用问题，当然也不使用 CSMA&#x2F;CD 协议。这就使得 10GE 的传输距离大大提高了（因为不再受必须进行碰撞检测的限制）。</p><h2 id="5-4-使用以太网进行宽带接入"><a href="#5-4-使用以太网进行宽带接入" class="headerlink" title="5.4 使用以太网进行宽带接入"></a>5.4 使用以太网进行宽带接入</h2><p>把 PPP 协议中的 PPP 帧再封装到以太网中来传输。这就是 1999 年公布的 PPPoE（PPP over Ethernet），意思是“在以太网上运行 PPP”。现在的光纤宽带接入 FTTx 都要使用PPPoE的方式进行接入。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络 第二章：物理层</title>
    <link href="/computer-network-2/"/>
    <url>/computer-network-2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-物理层的基本概念"><a href="#1-物理层的基本概念" class="headerlink" title="1.物理层的基本概念"></a>1.物理层的基本概念</h1><p>物理层协议称为物理层规程，实际上是物理层协议。</p><ol><li><strong>机械特性：</strong>接线器形状和尺寸、引脚数目和排列、固定和锁定装置等；</li><li><strong>电气特性：</strong>接口电缆的各条线上的电压范围；</li><li><strong>功能特性：</strong>某条线上的某一电平的电压的意义；</li><li><strong>过程特性：</strong>对于不同功能的各种可能事件的出现顺序；</li></ol><h1 id="2-数据通信的基础知识"><a href="#2-数据通信的基础知识" class="headerlink" title="2.数据通信的基础知识"></a>2.数据通信的基础知识</h1><h2 id="2-1-数据通信系统模型"><a href="#2-1-数据通信系统模型" class="headerlink" title="2.1 数据通信系统模型"></a>2.1 数据通信系统模型</h2><p><strong>一个数据通信系统可划分为三大部分：</strong></p><ol><li><strong>源系统</strong>（或发送端、发送方)</li><li><strong>传输系统</strong>（或传输网络）</li><li><strong>目的系统</strong>（或接收端、接收方)</li></ol><p><img src="/../img/post/computer-network/2-1.jpg"></p><p><strong>源系统一般包括以下两个部分：</strong></p><ul><li><strong>源点（source）：</strong>源点设备产生要传输的数据，例如，从计算机的键盘输入汉字，计算机产生输出的数字比特流。源点又称为源站，或信源。</li><li><strong>发送器：</strong>通常源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。典型的发送器就是调制器。</li></ul><p><strong>目的系统一般也包括以下两个部分：</strong></p><ul><li><strong>接收器：</strong>接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。典型的接收器就是解调器，它把来自传输线路上的模拟信号进行解调，提取出在发送端置入的消息，还原出发送端产生的数字比特流。</li><li><strong>终点（destination）：</strong>终点设备从接收器获取传送来的数字比特流，然后把信息输出（例如，把汉字在计算机屏幕上显示出来)。终点又称为目的站，或信宿。</li></ul><h2 id="2-2-有关信道的几个基本概念"><a href="#2-2-有关信道的几个基本概念" class="headerlink" title="2.2 有关信道的几个基本概念"></a>2.2 有关信道的几个基本概念</h2><p><strong>从通信的双方信息交互的方式来看，有以下三种基本方式：</strong></p><ul><li>单项通信（单工通信）</li><li>双向交替通信（半双工通信）</li><li>双向同时通信（全双工通信）</li></ul><h3 id="2-2-1-常用编码方式"><a href="#2-2-1-常用编码方式" class="headerlink" title="2.2.1 常用编码方式"></a>2.2.1 常用编码方式</h3><p><img src="/../img/post/computer-network/2-2.jpg"></p><ul><li><strong>不归零制：</strong>正电平代表1，负电平代表0。</li><li><strong>归零制：</strong>正脉冲代表1，负脉冲代表0。</li><li><strong>曼彻斯特编码：</strong>位周期中心的向上跳变代表0，位周期中心的向下跳变代表1。但也可反过来定义。</li><li><strong>差分曼彻斯特编码：</strong>在每一位的中心处始终都有跳变。位开始边界有跳变代表0，而位开始边界没有跳变代表1。</li></ul><h3 id="2-2-2-常用编码方式"><a href="#2-2-2-常用编码方式" class="headerlink" title="2.2.2 常用编码方式"></a>2.2.2 常用编码方式</h3><p><img src="/../img/post/computer-network/2-3.jpg"></p><ul><li>调幅（AM）即载波的振幅随基带数字信号而变化。</li><li>调频（FM）即载波的频率随基带数字信号而变化。</li><li>调相（PM）即载波的初始相位随基带数字信号而变化。</li></ul><h3 id="2-2-3-信道的极限容量"><a href="#2-2-3-信道的极限容量" class="headerlink" title="2.2.3 信道的极限容量"></a>2.2.3 信道的极限容量</h3><p>在1948年，信息论的创始人香农（Shannon）推导出了著名的香农公式。香农公式指出：信道的极限信息传输速率是</p><p>$$<br>信噪比&#x3D;\dfrac{S}{N}&#x3D;\dfrac{信号平均功率}{噪声平均功率}<br>$$</p><p>$$<br>C &#x3D; W×log_2(1+S&#x2F;N)（bit&#x2F;s）<br>$$</p><p>香农公式表明，信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。意义在于：<strong>只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。</strong></p><h1 id="3-物理层下面的传输媒体"><a href="#3-物理层下面的传输媒体" class="headerlink" title="3.物理层下面的传输媒体"></a>3.物理层下面的传输媒体</h1><p>传输媒体也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。</p><p>可分为两大类：</p><ul><li><strong>引型传输媒体：</strong>电磁波被引导沿着固体媒体传播</li><li><strong>非导引型传输媒体：</strong>指自由空间</li></ul><h2 id="3-1-引型传输媒体"><a href="#3-1-引型传输媒体" class="headerlink" title="3.1 引型传输媒体"></a>3.1 <strong>引型传输媒体</strong></h2><h3 id="3-1-1-双绞线"><a href="#3-1-1-双绞线" class="headerlink" title="3.1.1 双绞线"></a>3.1.1 双绞线</h3><p>双绞线也称为双扭线，是最古老但又是最常用的传输媒体。把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合起来就构成了双绞线。绞合可减少对相邻导线的电磁干扰。使用双绞线最多的地方就是到处都有的电话系统。</p><p><img src="/../img/post/computer-network/2-4.jpg"></p><h3 id="3-1-2-同轴电缆"><a href="#3-1-2-同轴电缆" class="headerlink" title="3.1.2 同轴电缆"></a>3.1.2 <strong>同轴电缆</strong></h3><p>同轴电缆由内导体铜质芯线（单股实心线或多股绞合线)、绝缘层、网状编织的外导体屏蔽层（也可以是单股的）以及保护塑料外层所组成。</p><p>由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。</p><p><img src="/../img/post/computer-network/2-5.jpg"></p><h3 id="3-1-3-光缆（光纤）"><a href="#3-1-3-光缆（光纤）" class="headerlink" title="3.1.3 光缆（光纤）"></a>3.1.3 <strong>光缆（光纤）</strong></h3><p>光纤通信就是利用光导纤维（以下简称为光纤）传递光脉冲来进行通信。有光脉冲相当于1，而没有光脉冲相当于0。由于可见光的频率非常高，约为 10^8 MHz 的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。</p><p><img src="/../img/post/computer-network/2-6.jpg"></p><p>光纤不仅具有通信容量非常大的优点，而且还具有其他的一些特点：</p><ol><li>传输损耗小，中继距离长，对远距离传输特别经济。</li><li>抗雷电和电磁干扰性能好。这在有大电流脉冲干扰的环境下尤为重要。</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。这在现有电缆管道已拥塞不堪的情况下特别有利。</li></ol><h2 id="3-2-非引型传输媒体"><a href="#3-2-非引型传输媒体" class="headerlink" title="3.2 非引型传输媒体"></a>3.2 <strong>非引型传输媒体</strong></h2><h3 id="3-2-1-短波通信（高频通信）"><a href="#3-2-1-短波通信（高频通信）" class="headerlink" title="3.2.1 短波通信（高频通信）"></a>3.2.1 <strong>短波通信（高频通信）</strong></h3><p>短波通信（即高频通信）主要是靠电离层的反射。但电离层的不稳定所产生的衰落现象和电离层反射所产生的多径效应，使得短波信道的通信质量较差，一般都是低速传输。</p><h3 id="3-2-2-无线电微波通信"><a href="#3-2-2-无线电微波通信" class="headerlink" title="3.2.2 无线电微波通信"></a>3.2.2 <strong>无线电微波通信</strong></h3><p>无线电微波通信在数据通信中占有重要地位。微波的频率范围为 300 MHz<del>300 GHz (波长 1m</del>1mm)，但主要使用2~40 GHz的频率范围。</p><p>微波在空间主要是直线传播。由于微波会穿透电离层而进入宇宙空间，因此它不像短波那样可以经电离层反射传播到地面上很远的地方。</p><p>传统的微波通信主要有两种方式，即<strong>地面微波接力通信</strong>和<strong>卫星通信</strong>。</p><h1 id="4-信道复用技术"><a href="#4-信道复用技术" class="headerlink" title="4.信道复用技术"></a>4.信道复用技术</h1><h2 id="4-1-常用的信道复用技术"><a href="#4-1-常用的信道复用技术" class="headerlink" title="4.1 常用的信道复用技术"></a>4.1 常用的信道复用技术</h2><h3 id="4-1-1-频分复用-FDM"><a href="#4-1-1-频分复用-FDM" class="headerlink" title="4.1.1 频分复用 FDM"></a>4.1.1 <strong>频分复用 FDM</strong></h3><p><img src="/../img/post/computer-network/2-7.jpg"></p><p>按频率分，通信过程中自始至终都占用这个频带，同时占用不同带宽资源。</p><h3 id="4-1-2-时分复用-TDM"><a href="#4-1-2-时分复用-TDM" class="headerlink" title="4.1.2 时分复用 TDM"></a>4.1.2 <strong>时分复用 TDM</strong></h3><p><img src="/../img/post/computer-network/2-8.jpg"></p><p>所有用户在不同时间占用同样的频率宽度。</p><h3 id="4-1-3-统计时分复用"><a href="#4-1-3-统计时分复用" class="headerlink" title="4.1.3 统计时分复用"></a>4.1.<strong>3 统计时分复用</strong></h3><p>统计时分复用是一种改进的时分复用，它能明显地提高信道的利用率。集中器常使用这种统计时分复用。</p><p><img src="/../img/post/computer-network/2-9.jpg"></p><p>当一个帧的数据放满了，就发送出去。因此，STDM 帧不是固定分配时隙，而是按需动念地分配时隙。</p><h3 id="4-1-4-波分复用"><a href="#4-1-4-波分复用" class="headerlink" title="4.1.4 波分复用"></a>4.1.4 <strong>波分复用</strong></h3><p>光的频分复用。</p><h3 id="4-1-5-码分复用"><a href="#4-1-5-码分复用" class="headerlink" title="4.1.5 码分复用"></a>4.1.5 <strong>码分复用</strong></h3><p>码分复用 CDM 是另一种共享信道的方法。实际上，人们更常用的名词是码分多址 CDMA（Code Division Multiple Access）。</p><p>每一个用户可以在同样的时间使用同样的频带进行通信。由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</p><p><img src="/../img/post/computer-network/2-10.jpg"></p><h1 id="5-数字传输系统"><a href="#5-数字传输系统" class="headerlink" title="5.数字传输系统"></a>5.数字传输系统</h1><p>为了解决<strong>速率标准不统一</strong>和<strong>不是同步传输</strong>的问题，美国在 1988 年首先推出了一个数字传输标准叫做同步光纤网 SONET（Synchronous Optical Network）。</p><p>SDH&#x2F;SONET 标准的制定，使北美、日本和欧洲这三个地区三种不同的数字传输体制在 STM-1 等级上获得了统一。这是第一次真正实现了数字传输体制上的世界性标准。现在 SDH&#x2F;SONET 标准已成为公认的新一代理想的传输网体制，因而对世界电信网络的发展具有重大的意义。SDH标准也适合于微波和卫星传输的技术体制。</p><h1 id="6-宽带接入技术"><a href="#6-宽带接入技术" class="headerlink" title="6.宽带接入技术"></a>6.宽带接入技术</h1><h2 id="6-1-ADSL技术"><a href="#6-1-ADSL技术" class="headerlink" title="6.1 ADSL技术"></a>6.1 <strong>ADSL技术</strong></h2><p>非对称数字用户线技术是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带数字业务。0~4kHZ 低端频谱给传统电话，原先未利用的高端频谱给用户上网。非对称指下行远远大于上行带宽。ADSL 传输距离取决于数据率和用户线的线径（线径约小衰减越大）。</p><h2 id="6-2-光纤同轴混合网"><a href="#6-2-光纤同轴混合网" class="headerlink" title="6.2 光纤同轴混合网"></a>6.2 <strong>光纤同轴混合网</strong></h2><p>光纤同轴混合网是在有线电视网的基础上开发的一种居民宽带接入网，除可传送电视节目外，还能提供电诂、数据和其他宽带交互型业务。</p><h2 id="6-3-FTTx技术"><a href="#6-3-FTTx技术" class="headerlink" title="6.3 FTTx技术"></a>6.3 <strong>FTTx技术</strong></h2><p>光纤到户 FTTH 是最好的选择，把光纤一直铺设到用户家庭。只有光纤在进入家门后，才把光信号转为电信号，以获得最高的上网速率。</p><p>为了有效地利用光纤资源，在光纤干线和广大用户之间，还需要铺设一段中间的转换装置即光配线网 ODN（Optical Distribution Network），使得数十个家庭用户能够共享一根光纤干线。</p><p><img src="/../img/post/computer-network/2-11.jpg"></p><p>光线路终端 OLT（Optical Line Terminal）是连接到光纤干线的终端设备。OLT 把收到的下行数据发往无源的 1:N 光分路器，然后用广播方式向所有用户端的光网络单元ONU（Optical Network Unit）发送。典型的光分路器使用分路比是 1:32。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络 第一章：概述</title>
    <link href="/computer-network-1/"/>
    <url>/computer-network-1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-计算机网络在信息时代中的作用"><a href="#1-计算机网络在信息时代中的作用" class="headerlink" title="1.计算机网络在信息时代中的作用"></a>1.计算机网络在信息时代中的作用</h1><p>21世纪的重要特征：数字化、网络化、信息化、以网络为核心的信息时代。</p><p>互联网有两个重要基本特点：连通性、共享</p><ul><li><strong>连通性：</strong>用户终端都彼此直接联通一样；</li><li><strong>资源共享：</strong>信息、软件和硬件共享；</li></ul><p>互联网+代表一种新的经济形态，有正面，也有负面影响，但负面影响毕竟还是次要的。</p><h1 id="2-互联网概述"><a href="#2-互联网概述" class="headerlink" title="2.互联网概述"></a>2.互联网概述</h1><h2 id="2-1-网络的网络"><a href="#2-1-网络的网络" class="headerlink" title="2.1 网络的网络"></a>2.1 网络的网络</h2><p>计算机网络（简称网络）由若干结点（node）和链接这些节点的链路（link）组成。网络中的结点可以是计算机、集线器、路由器等。</p><p><img src="/../img/post/computer-network/1-1.jpg"></p><p>网络把许多计算机连接在一起，而互联网则把许多网络通过路由器连接在一起。与网络相连的计算机常称为主机。</p><h2 id="2-2-互联网基础结构发展的三个阶段"><a href="#2-2-互联网基础结构发展的三个阶段" class="headerlink" title="2.2 互联网基础结构发展的三个阶段"></a>2.2 互联网基础结构发展的三个阶段</h2><p>互联网的基础结构大体上经历了三个阶段的演进。但这三个阶段在时间上的划分并非截然分开而是由部分重叠的，这是因为网络的演进是逐渐的。</p><ol><li>1983年 TCP&#x2F;IP 协议成立 ARPANET 上的标准协议，是所有使用 TCP&#x2F;IP 协议的计算机都能利用互联网通信，因而人们把 1983 年作为互联网的诞生时间。</li><li>建立了三级结构的互联网。分为主干网、地区网和校园网（或企业网）。</li><li>逐渐形成了多层次 ISP 结构的互联网。（ISP 指互联网服务提供商）</li></ol><p>ISP 根据服务覆盖面积大小及 IP 地址数目不同，也分为主干 ISP、地区 ISP、本地 ISP。</p><p><img src="/../img/post/computer-network/1-2.jpg"></p><p>为了更快的转发分组，出现了互联网交换点（IXP），作用是允许两个网络直接相连并交换分组，而不惜要通过第三个网络来转发分组。</p><h2 id="2-3-互联网的标准化工作"><a href="#2-3-互联网的标准化工作" class="headerlink" title="2.3 互联网的标准化工作"></a>2.3 互联网的标准化工作</h2><p>1992 年互联网不再归美国政府管辖，因此成立了一个国际性组织，叫互联网协会（Internet Society）。</p><ul><li>互联网协会 ISOC<ul><li>互联网体系结构委员会 IAB<ul><li>互联网工程部 IETF（协议开发和标准化）</li><li>互联网研究部 IRTF（研究一些需要长期考虑的问题）</li></ul></li></ul></li></ul><p>制定互联网的正式标准要经过以下三个阶段：</p><ol><li><strong>互联网草案（Internet Draft）：</strong>互联网草案的有效期只有六个月。在这个既然段还不能算是 RFC 文档。</li><li><strong>建议标准（Proposed Standard）：</strong>从这个阶段开始就成为 RFC 文档。</li><li><strong>互联网标准（Internet Standard）：</strong>达到正式标准后，每个标准就分配到一个编号 STD xx。</li></ol><h1 id="3-互联网的组成"><a href="#3-互联网的组成" class="headerlink" title="3.互联网的组成"></a>3.互联网的组成</h1><p>互联网的拓扑结构虽然非常复杂，但是从其工作方式上看，可以划分为：</p><ol><li><strong>边缘部分：</strong>由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</li><li><strong>核心部分：</strong>由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。</li></ol><p><img src="/../img/post/computer-network/1-3.jpg"></p><h2 id="3-1-互联网的边缘部分"><a href="#3-1-互联网的边缘部分" class="headerlink" title="3.1 互联网的边缘部分"></a>3.1 互联网的边缘部分</h2><p>这些主机称为端系统（end system），在网络边缘的端系统之间的通信通常可划分为两大类：</p><ol><li>客户-服务器方式（C&#x2F;S）</li><li>对等方式（P2P）</li></ol><h3 id="3-1-1-客户-服务器方式（C-x2F-S）"><a href="#3-1-1-客户-服务器方式（C-x2F-S）" class="headerlink" title="3.1.1 客户-服务器方式（C&#x2F;S）"></a>3.1.1 客户-服务器方式（C&#x2F;S）</h3><p>这种方式是互联网上最常用、传统的方式。</p><p><img src="/../img/post/computer-network/1-4.jpg"></p><p><strong>（1）客户程序：</strong></p><ol><li>被用户调用后运行，在通信时主动向远地服务器发起通信。因此，客户程序必须知道服务器程序的地址。</li><li>不需要特殊的硬件和分复杂的操作的操作系统。</li></ol><p><strong>（2）服务器程序：</strong></p><ol><li>一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</li><li>系统启动后自动调用并一直运行，被动地等待客户的通信请求。因此，服务器程序不需要知道客户程序的地址。</li><li>一般要强大的硬件和高校的操作系统支持。</li></ol><h3 id="3-1-2-对等方式（P2P）"><a href="#3-1-2-对等方式（P2P）" class="headerlink" title="3.1.2 对等方式（P2P）"></a>3.1.2 对等方式（P2P）</h3><p>是指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机都运行了对等连接的软件（P2P），他们就可以进行平等的、对等的连接通信。这时，双方都可以下载对方已存储在硬盘中的共享文档。</p><p><img src="/../img/post/computer-network/1-5.jpg"></p><h2 id="3-2-互联网的核心部分"><a href="#3-2-互联网的核心部分" class="headerlink" title="3.2 互联网的核心部分"></a>3.2 互联网的核心部分</h2><p>在网络核心部分起特殊作用的是路由器（router），它是一种专用计算机（不能叫主机）。路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网路核心最重要的功能。</p><p><strong>1.电路交换的主要特点：</strong></p><p>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源。</p><p><strong>2.分组交换的主要特点：</strong></p><p>分组交换采用存储转发技术，要发送的整块数据称为一个报文（message）。再发送前，先把较长的报文划分为一个个小数据段，每个小数据段前加上必要控制信息为首部（header），构成了一个分组（packet），分组也叫“包”，分组首部也叫“包头”。</p><p><img src="/../img/post/computer-network/1-6.jpg"></p><p>主机是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器则是用来转发分组的。路由器收到一个分组，先暂时存储以下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。</p><p><strong>3.分组交换的优点：</strong></p><ol><li><strong>高效：</strong>在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用。</li><li><strong>灵活：</strong>为每一个分组独立地选择最合适的转发路由</li><li><strong>迅速：</strong>以分组作为传送单位，可以不先建立连接就能向其他主机发送分组</li><li><strong>可靠：</strong>保证可靠性的网络协议;分布式多路由的分组交换网，使网络有很好的生存性</li></ol><p><strong>4.分组交换的问题：</strong></p><ol><li><strong>时延：</strong>分组在各路由器存储转发时需要排队，这就会造成一定的时延。</li><li><strong>开销：</strong>各分组必须携带的控制信息也造成了一定的开销（overhead）。整个分组交换网还需要专门的管理和控制机制。</li></ol><p><img src="/../img/post/computer-network/1-7.jpg"></p><p>若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输速率较快。</p><p>报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性。</p><h1 id="4-计算机网络在我国的发展"><a href="#4-计算机网络在我国的发展" class="headerlink" title="4.计算机网络在我国的发展"></a>4.计算机网络在我国的发展</h1><p>1994年4月20日，我国用 64 kbit&#x2F;s 专线正式连入互联网。从此，我国被国际上正式承认为接入互联网的国家。同年5月中国科学院高能物理研究所设立了我国的第一个万维网服务器。同年9月中国公用计算机互联网 CHINANET 正式启动。</p><p>到目前为止，我国陆续建造了基于互联网技术并能够和互联网互连的多个全国范围的公用计算机网络，其中规模最大的就是下面这五个：</p><ol><li>中国电信互联网 CHINANET（原中国公用计算机互联网）</li><li>中国联通互联网 UNINET</li><li>中国移动互联网 CMNET</li><li>中国教育和科研计算机网 CERNET</li><li>中国科学技术网 CSTNET</li></ol><h1 id="5-计算机网络的类别"><a href="#5-计算机网络的类别" class="headerlink" title="5.计算机网络的类别"></a>5.计算机网络的类别</h1><h2 id="5-1-计算机网络的定义"><a href="#5-1-计算机网络的定义" class="headerlink" title="5.1 计算机网络的定义"></a>5.1 计算机网络的定义</h2><p>计算机网络的精确定义并未统一，关于计算机网络的较好的定义是：计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号)。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><p>根据这个定义：</p><ol><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机。</li><li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</li></ol><h2 id="5-2-几种不同类别的计算机网络"><a href="#5-2-几种不同类别的计算机网络" class="headerlink" title="5.2 几种不同类别的计算机网络"></a>5.2 几种不同类别的计算机网络</h2><p><strong>1.按照网络的作用范围进行分类</strong></p><ol><li><strong>广域网 WAN（Wide Area Network）：</strong>广域网的作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离运送主机所发送的数据。</li><li><strong>城域网 MAN（Metropolitan Area Network）：</strong>城域网的作用范围一般是一个城市，可跨越几个街区甚至整个城市，其作用距离约为5 ~50 km。城域网可以为一个或几个单位所拥有，但也可以是一种公用设施，用来将多个局域网进行互连。目前很多城域网采用的是以太网技术，因此有时也常并入局域网的范围进行讨论。</li><li><strong>局域网 LAN（Local Area Network）：</strong>局域网一般用微型计算机或工作站通过高速通信线路相连（速率通常在10 Mbit&#x2F;s以上），但地理上则局限在较小的范围（如1 km左右）。在局域网发展的初期，一个学校或工厂往往只拥有一个局域网，但现在局域网已非常广泛地使用，学校或企业大都拥有许多个互连的局域网（这样的网络常称为校园网或企业网）。</li><li><strong>个人区域网 PAN（Personal Area Network）：</strong>个人区域网就是在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络，因此也常称为无线个人区域网 WPAN (Wireless PAN)，其范围很小。</li></ol><h1 id="6-计算机网络的性能"><a href="#6-计算机网络的性能" class="headerlink" title="6.计算机网络的性能"></a>6.计算机网络的性能</h1><h2 id="6-1-计算机网络的性能指标"><a href="#6-1-计算机网络的性能指标" class="headerlink" title="6.1 计算机网络的性能指标"></a>6.1 计算机网络的性能指标</h2><p><strong>1.速率</strong></p><p>速率的单位是 bit&#x2F;s（或 bps）。计算机发送出的信号都是数字形式的，1字节等于8比特，所以当我们将带宽换算成文件传输速度时需要除以8。</p><p><strong>2.带宽</strong></p><p>带宽用来表示网络中某通道传送数据的能力。网络带宽表示在单位时间内网络中的某信道所能通过的“最高数据率”，单位是数据率的单位 bit&#x2F;s，是“比特每秒”。</p><p><strong>3.吞吐量</strong></p><p>吞吐量表示在单位时间内通过某个网络（或信道、接口）的实际的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><p>显然，吞吐量受网络的带宽或网络的额定速率的限制。例如，对于一个1Gbit&#x2F;s的以太网，就是说其额定速率是1Gbit&#x2F;s，那么这个数值也是该以太网的吞吐量的绝对上限值。因此，对1Gbit&#x2F;s 的以太网，其实际的吞吐量可能也只有100 Mbit&#x2F;s，或甚至更低，并没有达到其额定速率。请注意，有时吞吐量还可用每秒传送的字节数或帧数来表示。</p><p><strong>4.时延</strong></p><p>时延（delay）是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。时延是个很重要的性能指标，它有时也称为延迟或迟延。由以下几个不同的部分组成的：</p><p><strong>（1）发送时延：</strong>是主机或路由器发送数据帧所需要的时。</p><p>$$<br>发送时延&#x3D;\dfrac{数据帧长度 bit}{发送速率 bit&#x2F;s}<br>$$</p><p><strong>（2）传播时延：</strong>传播时延是电磁波在信道中传播一定的距离需要花费的时间。</p><p>$$<br>传播时延&#x3D;\dfrac{信道长度 m}{电磁波在信道上的速率 m&#x2F;s}<br>$$</p><ul><li><strong>真空：</strong>3.0×10^8 m&#x2F;s</li><li><strong>铜：</strong>2.3×10^8 m&#x2F;s</li><li><strong>光纤：</strong>2.0×10^8 m&#x2F;s</li></ul><p><strong>（3）处理时延：</strong>主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等。</p><p><strong>（4）排队时延：</strong>分组在经过网络传输时，要经过许多路由器。但分组在进人路出奋后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待。</p><p>$$<br>总时延&#x3D;发送时延+传播时延+处理时延+排队时延<br>$$</p><p><img src="/../img/post/computer-network/1-8.jpg"></p><p>对于高速网络链路，<strong>我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率。</strong></p><p><strong>提高数据的发送速率只是减小了数据的发送时延。</strong></p><p><strong>5.时延带宽积</strong></p><p>$$<br>时延带宽积&#x3D;传播时延×带宽<br>$$</p><p>表示链路能够容纳多少个比特。</p><p><strong>6.往返时间 RTT</strong></p><p>$$<br>发送时间&#x3D;\dfrac{数据长度}{发送速率}<br>$$</p><p>$$<br>有效数据率&#x3D;\dfrac{数据长度}{发送时间+RTT}<br>$$</p><p>是一个重要的性能指标。</p><p><strong>7.利用率</strong></p><p><strong>（1）信道利用率：</strong>某信道有百分之几的时间是被利用的。</p><p><strong>（2）网络利用率：</strong>全网络的信道利用率的加权平均值。</p><p>信道利用率并非越高越好。这是因为，根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。</p><p>$$<br>D&#x3D;\dfrac{D_{0}}{1-U}<br>$$</p><p><img src="/../img/post/computer-network/1-9.jpg"></p><p>这里 U 是网络的利用率，数值在0到1之间。当网络的利用率达到其容量的1&#x2F;2时，时延就要加倍。特别值得注意的就是：当网络的利用率接近最大值1时，网络的时延就趋于无穷大。</p><p>因此一些拥有较大主干网的 ISP 通常控制信道利用率不超过50%。如果超过了就要准备扩容，增大线路的带宽。</p><h2 id="6-2-计算机网络的非性能特征"><a href="#6-2-计算机网络的非性能特征" class="headerlink" title="6.2 计算机网络的非性能特征"></a>6.2 计算机网络的非性能特征</h2><ol><li><strong>费用：</strong>网络的价格。</li><li><strong>质量：</strong>网络的质量取决于网络中所有构件的质量，以及这些构件是怎样组成网络的。</li><li><strong>标准化：</strong>网络的硬件和软件的设计既可以按照通用的国际标准，也可以遵循特定的专用网络标准。</li><li><strong>可靠性：</strong>可靠性与网络的质量和性能都有密切关系。</li><li><strong>可拓展性和可升级性：</strong>在构造网络时就应当考虑到今后可能会需要扩展（即规模扩大）和升级（即性能和版本的提高)。</li><li><strong>易于管理和维护：</strong>网络如果没有良好的管理和维护，就很难达到和保持所设计的性能。</li></ol><h1 id="7-计算机网络体系结构"><a href="#7-计算机网络体系结构" class="headerlink" title="7.计算机网络体系结构"></a>7.计算机网络体系结构</h1><h2 id="7-1-计算机网络体系结构的形成"><a href="#7-1-计算机网络体系结构的形成" class="headerlink" title="7.1 计算机网络体系结构的形成"></a>7.1 计算机网络体系结构的形成</h2><p>OSI 试图达到一种理想境界，即全球计算机网络都遵循这个统一标准，但由于基于 TCP&#x2F;IP 的互联网已抢先在全球相当大的范围成功地运行了。</p><h2 id="7-2-协议与划分层次"><a href="#7-2-协议与划分层次" class="headerlink" title="7.2 协议与划分层次"></a>7.2 协议与划分层次</h2><p>我们并不想让文件传送模块完成全部工作的细节，这样会使文件传送模块过于复杂，所以分层。</p><p><strong>分层的好处：</strong></p><ol><li>各层之间是独立的</li><li>灵活性好</li><li>结构上可分割开</li><li>易于实现和维护</li><li>能促进标准化工作</li></ol><h2 id="7-3-具有五层协议的体系结构"><a href="#7-3-具有五层协议的体系结构" class="headerlink" title="7.3 具有五层协议的体系结构"></a>7.3 具有五层协议的体系结构</h2><p><img src="/../img/post/computer-network/1-10.jpg"></p><table><thead><tr><th>应用层</th><th>体系结构中的最高层，通过应用进程间的交互来完成特定网络应用</th></tr></thead><tbody><tr><td>运输层</td><td>两台主机中进程之间的通信提供通用的数据传输服务</td></tr><tr><td>网络层</td><td>为分组交换网上的不同主机提供通信服务</td></tr><tr><td>数据链路层</td><td>把网络层下来的IP数据包组装成帧，在链路上发送</td></tr><tr><td>物理层</td><td>传送比特</td></tr></tbody></table><p><img src="/../img/post/computer-network/1-11.jpg"></p><h2 id="7-4-实体、协议、服务和服务访问点"><a href="#7-4-实体、协议、服务和服务访问点" class="headerlink" title="7.4 实体、协议、服务和服务访问点"></a>7.4 实体、协议、服务和服务访问点</h2><ol><li><strong>实体：</strong>任何可发送或接收信息的硬件或软件进程。</li><li><strong>协议：</strong>控制对等实体之间的通信规则，是水平的。</li><li><strong>服务：</strong>由下层通过层间接口向上层提供的功能，是垂直的。</li><li><strong>服务访问点：</strong>同一系统中相邻两层的实体进行交互的地方。</li></ol><p>协议必须把所有不利的条件事先都估计到，而不能假定一切都是正常的和非常理想的。想的。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课本</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
