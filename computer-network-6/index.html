

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/favicon.png">
  <link rel="icon" href="/img/icon/favicon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Haoning Wu">
  <meta name="keywords" content="BLOG,博客,笔记,计算机,网络,算法,数据,开发,C,C++,Python,Windows">
  
    <meta name="description" content="体系结构中的最高层，通过应用进程间的交互来完成特定网络应用。">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络 第六章：应用层">
<meta property="og:url" content="https://pudding.nousbuild.com/computer-network-6/">
<meta property="og:site_name" content="布丁笔记簿">
<meta property="og:description" content="体系结构中的最高层，通过应用进程间的交互来完成特定网络应用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pudding.nousbuild.com/img/post/computer-network/6-index.jpg">
<meta property="article:published_time" content="2022-06-30T14:00:00.000Z">
<meta property="article:modified_time" content="2024-10-14T07:38:25.552Z">
<meta property="article:author" content="Haoning Wu">
<meta property="article:tag" content="课本">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pudding.nousbuild.com/img/post/computer-network/6-index.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>计算机网络 第六章：应用层 - 布丁笔记簿</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"pudding.nousbuild.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>布丁笔记簿</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post/computer-network/banner.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机网络 第六章：应用层"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-06-30 22:00" pubdate>
          2022年6月30日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          88 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">计算机网络 第六章：应用层</h1>
            
            
              <div class="markdown-body">
                
                <p>不同的网络应用的应用进程之间，需要有不同的通信规则。因此在运输层协议之上，还需要有应用层协议（application layer protocol）。这是因为，每个应用层协议都是为了解决某一类应用问题，而问题的解决又必须通过位于不同主机中的多个应用进程之间的通信和协同工作来完成。应用进程之间的这种通信必须遵循严格的规则。应用层的具体内容就是精确定义这些通信规则。</p>
<h1 id="1-域名系统-DNS"><a href="#1-域名系统-DNS" class="headerlink" title="1.域名系统 DNS"></a>1.域名系统 DNS</h1><h2 id="1-1-域名系统概述"><a href="#1-1-域名系统概述" class="headerlink" title="1.1 域名系统概述"></a>1.1 域名系统概述</h2><p>域名系统 DNS（Domain Name System）是互联网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。</p>
<p>为了稳定，DNS 使用分布式的域名系统，并采用客户服务器方式。DNS 使大多数名字都在本地进行解析（resolve），仅少量解析需要在互联网上通信，因此 DNS 系统的效率很高。由于 DNS 是分布式系统，即使单个计算机出了故障，也不会妨碍整个 DNS 系统的正常运行。</p>
<p><strong>域名到 IP 地址的解析过程的要点如下：</strong></p>
<ul>
<li>当某一个应用进程需要把主机名解析为 IP 地址时，该应用进程就调用解析程序，并成为 DNS 的一个客户，把待解析的域名放在DNS 请求报文中，以 UDP 用户数据报方式发给本地域名服务器（使用 UDP 是为了减少开销)。</li>
<li>本地域名服务器在查找域名后，把对应的 IP 地址放在回答报文中返回。</li>
</ul>
<h2 id="1-2-互联网的域名结构"><a href="#1-2-互联网的域名结构" class="headerlink" title="1.2 互联网的域名结构"></a>1.2 互联网的域名结构</h2><p><img src="/../img/post/computer-network/6-1.jpg" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>每一个标号不超过 63 个字符；</li>
<li>不区分大小写字母；</li>
<li>由多个标号组成的完整域名总共不超过 255 个字符。</li>
</ol>
<h3 id="1-2-1-顶级域名分类"><a href="#1-2-1-顶级域名分类" class="headerlink" title="1.2.1 顶级域名分类"></a>1.2.1 顶级域名分类</h3><ol>
<li><strong>国家顶级域名 nTLD：</strong>cn、us、uk</li>
<li><strong>通用顶级域名 gTLD：</strong>com、net、org</li>
<li><strong>基础结构域名（infrastructure domain）：</strong>这种顶级域名只有一个，即 arpa，用于反向域名解析，因此又称为反向域名。</li>
</ol>
<p>我国把二级域名划分为<strong>“类别域名”</strong>和<strong>“行政区域名”</strong>两大类。</p>
<ul>
<li><strong>“类别域名”</strong>共 7 个，分别为：<ul>
<li>ac（科研机构）</li>
<li>com (工、商、金融等企业）</li>
<li>edu（中国的教育机构）</li>
<li>gov（中国的政府机构）</li>
<li>mil（中国的国防机构）</li>
<li>net（提供旦联网络服务的机构）</li>
<li>org（非营利性的组织）</li>
</ul>
</li>
<li><strong>“行政区域名”</strong>共 34 个，适用于我国的各省、自治区、直辖市。</li>
</ul>
<p><img src="/../img/post/computer-network/6-2.jpg" srcset="/img/loading.gif" lazyload></p>
<h2 id="1-3-域名服务器"><a href="#1-3-域名服务器" class="headerlink" title="1.3 域名服务器"></a>1.3 域名服务器</h2><p>一个服务器所负责管辖的（或有权限的）范围叫做区（zone）。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器（authoritative name server），用来保存该区中的所有主机的域名到 IP 地址的映射。总之，DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。区是 DNS 服务器实际管辖的范围。<strong>区可能等于或小于域，但一定不能大于域。</strong></p>
<p><img src="/../img/post/computer-network/6-3.jpg" srcset="/img/loading.gif" lazyload></p>
<p>这种 DNS 域名服务器树状结构图可以更准确地反映出 DNS 的分布式结构。</p>
<p><img src="/../img/post/computer-network/6-4.jpg" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-3-1-根域名服务器"><a href="#1-3-1-根域名服务器" class="headerlink" title="1.3.1 根域名服务器"></a>1.3.1 根域名服务器</h3><p>根域名服务器（root name server）：根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都<strong>知道所有的顶级域名服务器的域名和 IP 地址</strong>。根域名服务器是最重要的域名服务器，因为不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析（即转换为 IP 地址)，只要自己无法解析，就首先要求助于根域名服务器。</p>
<p>虽然互联网的根域名服务器总共只有 13 个域名，但这不表明根域名服务器是由 13 台机器所组成（如果仅仅依靠这 13 台机器，根本不可能为全世界的互联网用户提供令人满意的服务）。实际上，在互联网中是由 13 套装置构成这 13 组根域名服务器 [W-ROOT]。每一套装置在很多地点安装根域名服务器（也可称为镜像根服务器），<strong>但都使用同一个域名</strong>。</p>
<h3 id="1-3-2-顶级域名服务器"><a href="#1-3-2-顶级域名服务器" class="headerlink" title="1.3.2 顶级域名服务器"></a>1.3.2 顶级域名服务器</h3><p>这些域名服务器负责管理在<strong>该顶级域名服务器注册的所有二级域名</strong>。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的IP地址）。</p>
<h3 id="1-3-3-权限域名服务器"><a href="#1-3-3-权限域名服务器" class="headerlink" title="1.3.3 权限域名服务器"></a>1.3.3 权限域名服务器</h3><p><strong>负责一个区的域名服务器。</strong>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。</p>
<h3 id="1-3-4-本地域名服务器"><a href="#1-3-4-本地域名服务器" class="headerlink" title="1.3.4 本地域名服务器"></a>1.3.4 本地域名服务器</h3><p><strong>本地域名服务器并不属于域名服务器层次结构，但它对域名系统非常重要。</strong>当一台主机发出 DNS 查询请求时，<strong>这个查询请求报文就发送给本地域名服务器</strong>。</p>
<p>每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个<strong>本地域名服务器</strong>，这种域名服务器有时也称为<strong>默认域名服务器</strong>。</p>
<p>域名的解析过程，这里要注意两点：</p>
<ol>
<li><strong>主机</strong>向本地域名服务器的查询一般都是采用<strong>递归查询</strong>（recursive query）。所谓递归查询就是：<strong>如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文（即替该主机继续查询），而不是让该主机自己进行下一步的查询</strong>。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</li>
<li><strong>本地域名服务器</strong>向根域名服务器的查询通常是采用<strong>迭代查询</strong>（iterative query）。迭代查询的特点是这样的：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。</li>
</ol>
<p><img src="/../img/post/computer-network/6-5.jpg" srcset="/img/loading.gif" lazyload></p>
<p>假定域名为 m.xyz.com 的主机想知道另一台主机（域名为 y.abc.com）的 IP 地址。例如，主机 m.xyz.com 打算发送邮件给主机 y.abc.com。这时就必须知道主机 y.abc.com 的 IP 地址。下面是几个查询步骤:</p>
<ol>
<li>主机 m.xyz.com 先向其本地域名服务器 dns.xyz.com 进行递归查询。</li>
<li>本地域名服务器采用迭代查询。它先向一个根域名服务器查询。</li>
<li>根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器 dns.com 的 IP 地址。</li>
<li>本地域名服务器向顶级域名服务器 dns.com 进行查询。</li>
<li>顶级域名服务器 dns.com 告诉本地域名服务器，下一次应查询的权限域名服务器 dns.abc.com 的 IP 地址。</li>
<li>本地域名服务器向权限域名服务器 dns.abc.com 进行查询。</li>
<li>权限域名服务器 dns.abc.com 告诉本地域名服务器，所查询的主机的IP地址本地域名服务器最后把查询结果告诉主机 m.xyz.com。</li>
</ol>
<p>这 8 个步骤总共要使用 8 个 UDP 用户数据报的报文。本地域名服务器经过三次迭代查询后，从权限域名服务器 dns.abc.com 得到了主机 y.abc.com 的 IP 地址，最后把结果返回给发起查询的主机 m.xyz.com。</p>
<p>为了提高 DNS 查询效率，并减轻根域名服务器的负荷和减少互联网上的 DNS 查询报文数量，在域名服务器中广泛地使用了<strong>高速缓存</strong>（有时也称为<strong>高速缓存域名服务器</strong>）。<strong>高速缓存</strong>用来存放<strong>最近查询过的域名以及从何处获得域名映射</strong>信息的记录。</p>
<h1 id="2-文件传送协议"><a href="#2-文件传送协议" class="headerlink" title="2.文件传送协议"></a>2.文件传送协议</h1><h2 id="2-1-FTP-概述"><a href="#2-1-FTP-概述" class="headerlink" title="2.1 FTP 概述"></a>2.1 FTP 概述</h2><p>文件传送协议 FTP（File Transfer Protocol）[RFC 959] 是互联网上使用得最广泛的文件传送协议。有基于 TCP 的 FTP 和基于 UDP 的简单文件传送协议 TFTP，它们都是文件共享协议中的一大类，即<strong>复制整个文件</strong>，其特点是：</p>
<ol>
<li>若要存取一个文件，就必须先获得一个本地的文件副本。</li>
<li>如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件副本传回到原节点。</li>
</ol>
<h2 id="2-2-FTP-的基本工作原理"><a href="#2-2-FTP-的基本工作原理" class="headerlink" title="2.2 FTP 的基本工作原理"></a>2.2 FTP 的基本工作原理</h2><p>文件传送协议 FTP <strong>只提供文件传送的一些基本的服务</strong>，它使用 <strong>TCP 可靠的运输服务</strong>。</p>
<p>FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。<strong>FTP 的服务器进程由两大部分组成：</strong></p>
<ol>
<li>一个主进程，负责接受新的请求；</li>
<li>另外有若干个从属进程，负责处理单个请求。</li>
</ol>
<p><strong>主进程的工作步骤如下：</strong></p>
<ol>
<li>打开熟知端口<strong>（端口号为21）</strong>，使客户进程能够连接上。</li>
<li>等待客户进程发出连接请求。</li>
<li>启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。</li>
<li>回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发进行的。</li>
</ol>
<p><img src="/../img/post/computer-network/6-6.jpg" srcset="/img/loading.gif" lazyload></p>
<p>网络文件系统 NFS 则采用另一种思路。NFS 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。这样，NFS 可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</p>
<h2 id="2-3-简单文件传送协议-TFTP"><a href="#2-3-简单文件传送协议-TFTP" class="headerlink" title="2.3 简单文件传送协议 TFTP"></a>2.3 简单文件传送协议 TFTP</h2><p>TCP&#x2F;IP 协议族中还有一个简单文件传送协议 TFTP（Trivial File Transfer Protocol），它是一个很小且易于实现的文件传送协议。它使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。TFTP 只支持文件传输而不支持交互，没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</p>
<p><strong>TFTP 的主要优点有两个：</strong></p>
<ol>
<li>TFTP 可用于 UDP 环境；</li>
<li>TFTP 代码所占的内存较小。</li>
</ol>
<p><strong>TFTP 的主要特点是：</strong></p>
<ol>
<li>每次传送的数据报文中有 512 字节的数据，但最后一次可不足 512 字节。</li>
<li>数据报文按序编号，从 1 开始。</li>
<li>支持 ASCII 码或二进制传送。</li>
<li>可对文件进行读或写。</li>
<li>使用很简单的首部。</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li><strong>端口号码为 69</strong>。</li>
<li>若文件长度恰好为 512 字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据报文。</li>
<li>若文件长度不是 512 字节的整数倍，则最后传送数据报文中的数据字段一定不满 512 字节，这正好可作为文件结束的标志。</li>
</ol>
<h1 id="3-远程终端协议-TELNET"><a href="#3-远程终端协议-TELNET" class="headerlink" title="3.远程终端协议 TELNET"></a>3.远程终端协议 TELNET</h1><p>TELNET 是一个简单的远程终端协议，它也是互联网的正式标准。通过 TCP 连接，NVT 格式转换。与现在的“远程桌面连接”相似，现在很少使用了。</p>
<h1 id="4-万维网-www"><a href="#4-万维网-www" class="headerlink" title="4.万维网 www"></a>4.万维网 www</h1><h2 id="4-1-万维网概述"><a href="#4-1-万维网概述" class="headerlink" title="4.1 万维网概述"></a>4.1 万维网概述</h2><p>万维网 www（World Wide Web）并非某种特殊的计算机网络。</p>
<ol>
<li><p>万维网是一个大规模的、联机式的信息储藏所。</p>
</li>
<li><p>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点（也就是所谓的“链接到另一个站点”），从而主动地按需获取丰富的信息。</p>
</li>
<li><p>万维网提供分布式服务。</p>
<p><img src="/../img/post/computer-network/6-7.jpg" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>万维网使用统一资源定位符URL（Uniform Resource Locator）来标志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符 URL。</p>
</li>
<li><p>超文本传送协议 HTTP（HyperText Transfer Protocol），是一个应用层协议，它使用 TCP 连接进行可靠的传送。</p>
</li>
<li><p>万维网使用超文本标记语言 HTML（HyperText Markup Language）。</p>
</li>
</ol>
<h2 id="4-2-统一资源定位符-URL"><a href="#4-2-统一资源定位符-URL" class="headerlink" title="4.2 统一资源定位符 URL"></a>4.2 统一资源定位符 URL</h2><h3 id="4-2-1-URL-的格式"><a href="#4-2-1-URL-的格式" class="headerlink" title="4.2.1 URL 的格式"></a>4.2.1 URL 的格式</h3><p>URL 的一般形式由以下四个部分组成：</p>
<p>$$<br>&lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;<br>$$</p>
<h3 id="4-2-2-使用-HTTP-的-URL"><a href="#4-2-2-使用-HTTP-的-URL" class="headerlink" title="4.2.2 使用 HTTP 的 URL"></a>4.2.2 使用 HTTP 的 URL</h3><p>HTTP 的 URL 的一般形式是：</p>
<p>$$<br>http:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;<br>$$</p>
<p>URL 里面的 &lt;协议&gt;、&lt;主机&gt;，字母不区分大小写，但 &lt;路径&gt; 有时要区分大小写。</p>
<h2 id="4-3-超文本传送协议-HTTP"><a href="#4-3-超文本传送协议-HTTP" class="headerlink" title="4.3 超文本传送协议 HTTP"></a>4.3 超文本传送协议 HTTP</h2><h3 id="4-3-1-HTTP-的操作过程"><a href="#4-3-1-HTTP-的操作过程" class="headerlink" title="4.3.1 HTTP 的操作过程"></a>4.3.1 HTTP 的操作过程</h3><p>HTTP 是面向事务的（transaction-oriented）应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。请注意，HTTP 不仅传送完成超文本跳转所必需的信息，而且也传送任何可从互联网上得到的信息，如文本、超文本、声音和图像等。</p>
<p><img src="/../img/post/computer-network/6-8.jpg" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>建立 TCP 连接</li>
<li>浏览器（万维网客户）发出请求“HTTP 请求报文”</li>
<li>服务器返回响应“HTTP 响应报文”</li>
<li>释放 TCP 连接</li>
</ol>
<h3 id="4-3-2-HTTP-的特点"><a href="#4-3-2-HTTP-的特点" class="headerlink" title="4.3.2 HTTP 的特点"></a>4.3.2 HTTP 的特点</h3><ol>
<li>HTTP 规定在 HTTP 客户与 HTTP 服务器之间的每次交互，都由一个 ASCII 码串构成的请求和一个类似的通用互联网扩充，即“类 MIME（MIME-like）”的响应组成。</li>
<li>HTTP 使用了面向连接的 TCP 作为运输层协议，保证了数据的可靠传输。HTTP 不必考虑数据在传输过程中被丢弃后又怎样被重传。但是，HTTP 协议本身是无连接的。这就是说，虽然 HTTP 使用了 TCP 连接，但通信的双方在交换 HTTP 报文之前不需要先建立HTTP连接。</li>
<li>HTTP 协议是无状态的（stateless）。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同（假定现在服务器还没有把该页面更新)。HTTP 的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的 HTTP 请求。</li>
</ol>
<p><img src="/../img/post/computer-network/6-9.jpg" srcset="/img/loading.gif" lazyload></p>
<p>请求一个万维网文档所需的时间是该文档的传输时间（与文档大小成正比）加上<strong>两倍往返时间 RTT（一个 RTT 用于连接 TCP 连接，另一个 RTT 用于请求和接收万维网文档）</strong>。</p>
<ul>
<li><strong>HTTP&#x2F;1.0 的主要缺点，</strong>就是每请求一个文档就要有两倍RTT的开销。</li>
<li><strong>HTTP&#x2F;1.1 协议</strong>较好地解决了这个问题，它使用了<strong>持续连接</strong>（persistent connection）。所谓持续连接就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，有两种工作方式：<ul>
<li><strong>非流水线方式：</strong>是客户在收到前一个响应后才能发出下一个请求。客户每访问一次对象都要用去一个往返时间 RTT。</li>
<li>流水线方式：客户访问所有的对象只需花费一个 RTT 时间。</li>
</ul>
</li>
</ul>
<h3 id="4-3-3-代理服务器"><a href="#4-3-3-代理服务器" class="headerlink" title="4.3.3 代理服务器"></a>4.3.3 代理服务器</h3><p>代理服务器（proxy server）是一种网络实体，它又称为万维网高速缓存（Web cache）。把最近的一些请求和响应暂存在本地磁盘中，不需要按 URL 的地址再次去互联网访问该资源。</p>
<ul>
<li><strong>有缓存：</strong>就暂存相应返回</li>
<li><strong>无缓存：</strong>代理服务器就去请求</li>
</ul>
<p><img src="/../img/post/computer-network/6-10.jpg" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-3-4-HTTP-的报文结构"><a href="#4-3-4-HTTP-的报文结构" class="headerlink" title="4.3.4 HTTP 的报文结构"></a>4.3.4 HTTP 的报文结构</h3><p><strong>HTTP 有两类报文：</strong></p>
<ol>
<li><strong>请求报文：</strong>从客户向服务器发送请求报文。</li>
<li><strong>响应报文：</strong>从服务器到客户的回答。</li>
</ol>
<p><img src="/../img/post/computer-network/6-11.jpg" srcset="/img/loading.gif" lazyload></p>
<p>由于 HTTP 是面向文本的（text-oriented），因此在报文中的每一个字段都是一些 ASCII 码串，因而各个字段的长度都是不确定的。HTTP 请求报文和响应报文都是由三个部分组成的。可以看出，这两种报文格式的区别就是开始行不同。</p>
<ol>
<li><strong>开始行：</strong>用于区分是请求报文还是响应报文。在请求报文中的开始行叫做请求行（Request-Line），而在响应报文中的开始行叫做状态行（Status-Line）。在开始行的三个字段之间都以空格分隔开，最后的“CR”和“LF”分别代表“回车”和“换行”。</li>
<li><strong>首部行：</strong>用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。在每一个首部行中都有首部字段名和它的值，每一行在结束的地方都要有“回车”和“换行”。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。</li>
<li><strong>实体主体（entity body）：</strong>在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段。</li>
</ol>
<p>下面先介绍 HTTP 请求报文的一些主要特点。请求报文的第一行<strong>“请求行”</strong>只有三个内容，即<strong>方法</strong>，<strong>请求资源的 URL</strong>，以及 <strong>HTTP 的版本</strong>。</p>
<p><img src="/../img/post/computer-network/6-12.jpg" srcset="/img/loading.gif" lazyload></p>
<p>每一个请求报文发出后，都能收到一个响应报文。响应报文的第一行就是状态行。</p>
<ul>
<li>1xx 表示通知信息，如请求收到了或正在进行处理。</li>
<li>2xx 表示成功，如接受或知道了。</li>
<li>3xx 表示重定向，如要完成请求还必须采取进一步的行动。</li>
<li>4xx 表示客户的差错，如请求中有错误的语法或不能完成。</li>
<li>5xx 表示服务器的差错，如服务器失效无法完成请求。</li>
</ul>
<h3 id="4-3-5-在服务器上存放用户的信息"><a href="#4-3-5-在服务器上存放用户的信息" class="headerlink" title="4.3.5 在服务器上存放用户的信息"></a>4.3.5 在服务器上存放用户的信息</h3><p>HTTP 是无状态的，但可以用 cookie（小小的文本文件），给用户一个唯一的识别码，在HTTP 响应报文中添加一个 <strong>Set-cookies</strong> 的首部行。</p>
<h2 id="4-4-万维网的文档"><a href="#4-4-万维网的文档" class="headerlink" title="4.4 万维网的文档"></a>4.4 万维网的文档</h2><p>超文本标记语言 HTML（HyperText Markup Language）就是一种制作万维网页面的标准语言，它消除了不同计算机之间信息交流的障碍。但请注意，<strong>HTML 并不是应用层的协议，它只是万维网浏览器使用的一种语言</strong>。</p>
<ul>
<li>动态万维网文档：CGI 创建动态文档</li>
<li>活动万维网文档：如 Java 小应用嵌入 HTML</li>
</ul>
<h2 id="4-5-万维网的信息检索系统"><a href="#4-5-万维网的信息检索系统" class="headerlink" title="4.5 万维网的信息检索系统"></a>4.5 万维网的信息检索系统</h2><p><strong>全文检索搜索与分类目录搜索：</strong></p>
<ol>
<li><strong>全文检索搜索：</strong>利用 Spider（如 Google）</li>
<li><strong>分类目录搜索：</strong>不采集任何信息，人工审核编辑录入（如 SCI、图书馆）</li>
</ol>
<h1 id="5-电子邮件"><a href="#5-电子邮件" class="headerlink" title="5.电子邮件"></a>5.电子邮件</h1><h2 id="5-1-电子邮件概述"><a href="#5-1-电子邮件概述" class="headerlink" title="5.1 电子邮件概述"></a>5.1 电子邮件概述</h2><p><strong>一个电子邮件系统应具有三个主要组成构件：</strong></p>
<ol>
<li>用户代理</li>
<li>邮件服务器（邮件服务器必须同时充当客户和服务器）</li>
<li>邮件发送协议（如SMTP）和邮件读取协议（如 POP3）</li>
</ol>
<p><img src="/../img/post/computer-network/6-13.jpg" srcset="/img/loading.gif" lazyload></p>
<p><strong>用户代理 UA（User Agent)）</strong>就是用户与电子邮件系统的接口，在大多数情况下它就是运行在用户电脑中的一个程序。用户代理至少应当具有以下 4 个功能：</p>
<ol>
<li><strong>撰写：</strong>给用户提供编辑信件的环境。</li>
<li><strong>显示：</strong>能方便地在计算机屏幕上显示出来信（包括来信附上的声音和图像）。</li>
<li><strong>处理：</strong>处理包括发送邮件和接收邮件。</li>
<li><strong>通信：</strong>发信人在撰写完邮件后，要利用邮件发送协议发送到用户所使用的邮件服务器。收件人在接收邮件时，要使用邮件读取协议从本地邮件服务器接收邮件。</li>
</ol>
<h2 id="5-2-简单邮件传送协议-SMTP"><a href="#5-2-简单邮件传送协议-SMTP" class="headerlink" title="5.2 简单邮件传送协议 SMTP"></a>5.2 简单邮件传送协议 SMTP</h2><p>SMTP 规定了在两个相互通信的 SMTP 进程之间应如何交换信息。由于 SMTP 使用客户服务器方式，因此负责发送邮件的 SMTP 进程就是 SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。至于邮件内部的格式，邮件如何存储，以及邮件系统应以多快的速度来发送邮件，SMTP 也都未做出规定。</p>
<p>下面通过发送方和接收方的邮件服务器之间的 SMTP 通信的三个阶段介绍几个最主要的命令和响应信息:</p>
<ol>
<li><strong>连接建立：</strong>SMTP 的熟知端口号码 25 与接收方邮件服务器的 SMTP 服务器建立 TCP 连接。<strong>SMTP不使用中间的邮件服务器。</strong></li>
<li><strong>邮件传送：</strong><ol>
<li>邮件的传送从 <strong>MAIL 命令</strong>开始。</li>
<li><strong>SMTP：</strong>250 ok，已准备好接收。</li>
<li><strong>RCPT 命令：</strong>弄清接收方系统是否已做好接收邮件的准备，然后才发送邮。</li>
<li><strong>DATA 命令：</strong>表示要开始传送邮件的内容了。</li>
</ol>
</li>
<li><strong>连接释放：</strong>SMTP 客户应发送OUIT 命令，SMTP服务器返回的信息是 221。</li>
</ol>
<h2 id="5-3-电子邮件的信息格式"><a href="#5-3-电子邮件的信息格式" class="headerlink" title="5.3 电子邮件的信息格式"></a>5.3 电子邮件的信息格式</h2><p>一个电子邮件分为<strong>信封</strong>和<strong>内容</strong>两大部分，而对邮件的<strong>主体</strong>部分则让用户自由撰写。</p>
<ul>
<li><strong>To：</strong>后面填入一个或多个收件人的电子邮件地址。</li>
<li><strong>Subject：</strong>是邮件的主题。它反映了邮件的主要内容。</li>
<li><strong>抄送 Cc：</strong>留下一个复写副本。</li>
</ul>
<h2 id="5-4-邮件读取协议-POP3-和-IMAP"><a href="#5-4-邮件读取协议-POP3-和-IMAP" class="headerlink" title="5.4 邮件读取协议 POP3 和 IMAP"></a>5.4 邮件读取协议 POP3 和 IMAP</h2><ol>
<li><strong>POP3：</strong>简单但功能有限，读取就删除。</li>
<li><strong>IMAP：</strong>由附存与 IMAP 服务器上。</li>
</ol>
<p><img src="/../img/post/computer-network/6-14.jpg" srcset="/img/loading.gif" lazyload></p>
<p>最后再强调一下，不要把邮件读取协议 POP3 或 IMAP 与邮件传送协议 SMTP 弄混。<strong>发件人的用户代理向发送方邮件服务器发送邮件，以及发送方邮件服务器向接收方邮件服务器发送邮件，都是使用 SMTP 协议。</strong>而 <strong>POP3 或 IMAP 则是用户代理从接收方邮件服务器上读取邮件所使用的协议</strong>。</p>
<h2 id="5-5-基于万维网的电子邮件"><a href="#5-5-基于万维网的电子邮件" class="headerlink" title="5.5 基于万维网的电子邮件"></a>5.5 基于万维网的电子邮件</h2><p>用户无需安装代理软件 UA。微软 Hotmail 推出了基于万维网的电子邮件。</p>
<p>用户在浏览器中浏览各种信息时需要使用 HTTP 协议。因此，在浏览器和互联网上的邮件服务器之间传送邮件时，仍然使用 HTTP 协议。但是在各邮件服务器之间传送邮件时，则仍然使用 SMTP 协议。</p>
<h2 id="5-6-通用互联网邮件扩充-MIME"><a href="#5-6-通用互联网邮件扩充-MIME" class="headerlink" title="5.6 通用互联网邮件扩充 MIME"></a>5.6 通用互联网邮件扩充 MIME</h2><h3 id="5-6-1-MIME-概述"><a href="#5-6-1-MIME-概述" class="headerlink" title="5.6.1 MIME 概述"></a>5.6.1 MIME 概述</h3><p><strong>电子邮件协议 SMTP 有以下缺点：</strong></p>
<ol>
<li>不能传送可执行文件或其他的二进制对象。</li>
<li>SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字无法传送。</li>
<li>SMTP 服务器会拒绝超过一定长度的邮件。</li>
<li>某些 SMTP 的实现并没有完全按照 SMTP 的互联网标准。</li>
</ol>
<p>于是在这种情况下就提出了<strong>通用互联网邮件扩充 MIME</strong> [RFC 2045 ~2049]。</p>
<p>MIME 的意图是继续使用原来的邮件格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。也就是说，MIME 邮件可在现有的电子邮件程序和协议下传送。</p>
<p><img src="/../img/post/computer-network/6-15.jpg" srcset="/img/loading.gif" lazyload></p>
<p><strong>MIME 主要包括以下三部分内容：</strong></p>
<ol>
<li>5 个新的邮件首部字段，它们可包含在原来的邮件首部中。这些字段提供了有关邮件主体的信息。</li>
<li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li>
<li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li>
</ol>
<p><strong>MIME 增加的 5 个新的邮件首部的名称及其意义：</strong></p>
<ol>
<li><strong>MIME-Version：</strong>标志 MIME 的版本。若无此行，则为英文文本。</li>
<li><strong>Content-Description：</strong>这是可读字符串，说明此邮件主体是否是图像、音频或视频。</li>
<li><strong>Content-Id：</strong>邮件的唯一标识符。</li>
<li><strong>Content-Transfer-Encoding：</strong>在传送时邮件的主体是如何编码的。</li>
<li><strong>Content-Type：</strong>说明邮件主体的数据类型和子类型。</li>
</ol>
<h3 id="5-6-2-内容传送编码（Content-Transfer-Encoding）"><a href="#5-6-2-内容传送编码（Content-Transfer-Encoding）" class="headerlink" title="5.6.2 内容传送编码（Content-Transfer-Encoding）"></a>5.6.2 内容传送编码（<strong>Content-Transfer-Encoding）</strong></h3><p>最简单的编码就是 7 位 ASCII 码，而每行不能超过 1000 个字符。MIME 对这种由 ASCII 码构成的邮件主体不进行任何转换。</p>
<p>另一种编码称为 quoted-printable，这种编码方法适用于所传送的数据中只有少量的非 ASCII 码，例如汉字、特殊字符。</p>
<p>对于任意的二进制文件，可用 base64 编码。这种编码方法是先把二进制代码划分为一个个 24 位长的单元，然后把每一个 24 位单元划分为 4 个 6 位组。每一个 6 位组按以下方法转换成 ASCII 码。6 位的二进制代码共有 64 种不同的值，从 0 到 63。用 A 表示 0，用 B 表示1，等等。<strong>26 个大写字母</strong>排列完毕后，接下去再排 <strong>26 个小写字母</strong>，再后面是 <strong>10 个数字</strong>，最后用 <strong><code>+</code> 表示 62</strong>，而用 <strong><code>/</code> 表示63</strong>。再用两个连在一起的等号 <code>==</code> 和一个等号 <code>=</code> 分别表示最后一组的代码只有 8 位或 16 位。回车和换行都忽略，它们可在任何地方插入。</p>
<p><img src="/../img/post/computer-network/6-16.jpg" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-6-3-内容类型"><a href="#5-6-3-内容类型" class="headerlink" title="5.6.3 内容类型"></a>5.6.3 内容类型</h3><p>MIME 标准规定 Content-Type 说明必须含有两个标识符，即<strong>内容类型（type）</strong>和<strong>子类型（subtype）</strong>，中间用 <code>/</code> 分开。</p>
<p><strong>MIME 标准原先定义了 7 个基本内容类型和 15 种子类型：</strong></p>
<p><img src="/../img/post/computer-network/6-17.jpg" srcset="/img/loading.gif" lazyload></p>
<p>MIME 的内容类型中的 multipart 是很有用的，因为它使邮件增加了相当大的灵活性。<strong>MIME 标准为 multipart 定义了四种可能的子类型，每个子类型都提供重要功能：</strong></p>
<ol>
<li>mixed 子类型允许单个报文含有多个相互独立的子报文，每个子报文可有自己的类型和编码。mixed 子类型报文使用户能够在单个报文中附上文本、图形和声音，或者用额外数据段发送一个备忘录，类似商业信笺含有的附件。</li>
<li>alternative 子类型允许单个报文含有同一数据的多种表示。当给多个使用不同硬件和软件系统的收件人发送备忘录时，这种类型的 multipart 报文很有用。例如，用户可同时用普通的 ASCII 文本和格式化的形式发送文本，从而允许拥有图形功能的计算机用户在查看图形时选择格式化的形式。</li>
<li>parallel 子类型允许单个报文含有可同时显示的各个子部分（例如，图像和声音子部分必须一起播放）。</li>
<li>digest 子类型允许单个报文含有一组其他报文（如从讨论中收集电子邮件报文）。</li>
</ol>
<h1 id="6-动态主机配置协议-DHCP"><a href="#6-动态主机配置协议-DHCP" class="headerlink" title="6.动态主机配置协议 DHCP"></a>6.动态主机配置协议 DHCP</h1><p><strong>动态主机配置协议 DHCP</strong>（Dynamic Host Configuration Protocol），它提供了一种机制，称为即<strong>插即用连网</strong>（plug-and-play networking）。这种机制允许一台计算机加入新的网络和获取 IP 地址而不用手工参与。</p>
<p>DHCP 对运行客户软件和服务器软件的计算机都适用。当运行客户软件的计算机移至一个新的网络时，就可使用 DHCP 获取其配置信息而不需要手工干预。DHCP 给运行服务器软件而位置固定的计算机指派一个永久地址，而当这计算机重新启动时其地址不改变。</p>
<p>但是我们并不愿意在每一个网络上都设置一个 DHCP 服务器，因为这样会使 DHCP 服务器的数量太多。因此现在是使每一个网络至少有一个 <strong>DHCP 中继代理</strong>（relay agent），它配置了 DHCP 服务器的 IP 地址信息。当 DHCP 中继代理收到主机 A 以广播形式发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再把此提供报文发回给主机 A。</p>
<blockquote>
<aside>


</blockquote>
<p><img src="/../img/post/computer-network/6-18.jpg" srcset="/img/loading.gif" lazyload></p>
<p>DHCP 服务器分配给 DHCP 客户的 IP 地址是临时的，因此 DHCP 客户只能在段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为<strong>租用期</strong>（lease period），但并没有具体规定租用期应取为多长或至少为多长，这个数值应由 DHCP 服务器自己决定。</p>
<p><strong>DHCP 的详细工作过程如图：</strong></p>
<ul>
<li>DHCP 客户使用的 <strong>UDP 端口是 68</strong></li>
<li>DHCP 服务器使用的 <strong>UDP 端口是 67</strong></li>
</ul>
<p><img src="/../img/post/computer-network/6-19.jpg" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>DHCP <strong>服务器被动打开 UDP 端口 67</strong>，等待客户端发来的报文。</li>
<li>DHCP <strong>客户从 UDP 端口 68 发送 DHCP 发现报文</strong>。</li>
<li>凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文，因此 DHCP 客户可能收到多个 DHCP 提供报文。</li>
<li>DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文。</li>
<li>被选择的 DHCP 服务器发送<strong>确认报文 DHCPACK</strong>。<strong>从这时起，DHCP 客户就可以使用这个 IP 地址了</strong>。这种状态叫做<strong>已绑定状态</strong>，因为在 DHCP 客户端的 IP 地址和硬件地址已经完成绑定，并且可以开始使用得到的临时 IP 地址了。DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是0.5T 和 0.875T。<strong>当超时时间到了就要请求更新租用期。</strong></li>
<li>租用期过了一半（T1时间到），<strong>DHCP 发送请求报文 DHCPREQUEST 要求更新租用期</strong>。</li>
<li>DHCP 服务器若<strong>同意</strong>，则发回<strong>确认报文 DHCPACK</strong>。 DHCP 客户得到了新的租用期，重新设置计时器。</li>
<li>DHCP 服务器若<strong>不同意</strong>，则发回<strong>否认报文 DHCPNACK</strong>。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤2)。若 DHCP 服务器不响应步骤 6 的请求报文 DHCPREQUEST，则在租用期过了 87.5% 时（T2时间到），DHCP 客户必须重新发送请求报文 DHCPREQUEST （重复步骤6），然后又继续后面的步骤。</li>
<li>DHCP 客户可以随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送<strong>释放报文 DHCPRELEASE</strong> 即可。</li>
</ol>
<h1 id="7-简单网络管理协议-SNMP"><a href="#7-简单网络管理协议-SNMP" class="headerlink" title="7.简单网络管理协议 SNMP"></a>7.简单网络管理协议 SNMP</h1><h2 id="7-1-网络管理的基本概念"><a href="#7-1-网络管理的基本概念" class="headerlink" title="7.1 网络管理的基本概念"></a>7.1 网络管理的基本概念</h2><p>网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能、服务质量等。网络管理常简称为网管。</p>
<p>网络是一个非常复杂的分布式系统。这是因为网络上有很多不同家生产的、运行看多种协议的结点（主要是路由器），而这些结点还在相互通信和交换信息。网络的状态总是不断地变化着。可见，我们必须使用一种机制来读取这些结点上的状态信息，有时还要把一些新的状态信息写入到这些结点上。</p>
<h3 id="7-1-1-网络管理模型中的主要构件"><a href="#7-1-1-网络管理模型中的主要构件" class="headerlink" title="7.1.1 网络管理模型中的主要构件"></a>7.1.1 网络管理模型中的主要构件</h3><p>管理站又称为管理器，是整个网络管理系统的核心，它通常是个有着良好图形界面的高性能的工作站，并由网络管理员直接操作和控制。所有向被管设备发送的命令都是从管理站发出的。</p>
<p>管理站的所在部门也常称为<strong>网络运行中心 NOC</strong>（Network Operations Center）。<strong>管理站中的关键构件是管理程序，管理程序在运行时就成为管理进程。</strong>管理站（硬件）或管理程序（软件）都可称为管理者或管理器。网络管理员（administrator）才是指人。</p>
<p><img src="/../img/post/computer-network/6-20.jpg" srcset="/img/loading.gif" lazyload></p>
<p>在被管网络中有很多的被管设备（包括设备中的软件）。被管设备可以是主机、路由器、打印机、集线器、网桥或调制解调器等。在每一个被管设备中可能有许多被管对象（Managed Object）。被管对象可以是被管设备中的某个硬件（例如，一块网络接口卡），也可以是某些硬件或软件（例如，路由选择协议）的配置参数的集合。<strong>被管设备有时可称为网络元素或简称为网元。在被管设备中也会有一些不能被管的对象（所谓不能被管的对象就是不在对象命名树上的对象）。</strong></p>
<h3 id="7-1-2-简单网络管理协议-SNMP"><a href="#7-1-2-简单网络管理协议-SNMP" class="headerlink" title="7.1.2 简单网络管理协议 SNMP"></a>7.1.2 简单网络管理协议 SNMP</h3><p>简单网络管理协议 SNMP（Simple Network Management Protocol）中的<strong>管理程序和代理程序按客户服务器方式工作。管理程序运行 SNMP 客户程序，而代理程序运行 SNMP 服务器程序。</strong></p>
<blockquote>
<p>💡 若要管理某个对象，就必然会给该对象添加一些软件或硬件，但这种“添加”对原有对象的影响必须尽量小些。</p>
</blockquote>
<p><strong>SNMP 的网络管理由三个部分组成：</strong></p>
<ol>
<li>SNMP 本身</li>
<li>管理信息结构 SMI（Structure of Management Information）</li>
<li>管理信息库 MIB（Management Information Base）</li>
</ol>
<ul>
<li>SNMP 定义了管理站和代理之间所交换的分组格式。所交换的分组包含各代理中的对象（变量）名及其状态（值）。SNMP 负责读取和改变这些数值。</li>
<li>SMI 定义了命名对象和定义对象类型（包括范围和长度）的通用规则，以及把对象和寸象的值进行编码的规则。</li>
<li>MIB 在被管理的实体中创建了命名对象，并规定了其类型。</li>
</ul>
<p>总之，SMI 建立规则，MIB 对变量进行说明，而 SNMP 完成网管的动作。</p>
<h2 id="7-2-管理信息结构-SMI"><a href="#7-2-管理信息结构-SMI" class="headerlink" title="7.2 管理信息结构 SMI"></a>7.2 管理信息结构 SMI</h2><p>管理信息结构 SMI 是 SNMP 的重要组成部分。SMI的功能应当有三个：</p>
<ol>
<li>被管对象应怎样命名；</li>
<li>用来存储被管对象的数据类型有哪些；</li>
<li>在网络上传送的管理数据应如何编码。</li>
</ol>
<h3 id="7-2-1-被管对象的命名"><a href="#7-2-1-被管对象的命名" class="headerlink" title="7.2.1 被管对象的命名"></a>7.2.1 被管对象的命名</h3><p>SMI 规定，所有的被管对象都必须处在对象命名树（object naming tree）上。</p>
<p>对象命名树的根没有名字，它的下面有三个顶级对象，都是世界上著名的标准制定单位，即 ITU-T，ISO，以及这两个组织的联合体，它们的标号分别是 0 到 2。标号为 3 的节点是 ISO 认同的的组织成员 org。在其下面有一个美国国防部 dod 的子树（标号为 6），再下面就是 internet（标号为 1)。在只讨论 internet 中的对象时，可只画出 internet 以下的子树，并在 internet 节点旁边写上对象标识符 1.3.6.1 即可。</p>
<p><img src="/../img/post/computer-network/6-21.jpg" srcset="/img/loading.gif" lazyload></p>
<p>在 internet 节点下面的标号为 2 的节点是 mgmt（管理）。再下面只有一个节点，即管理信息库 mib-2，其对象标识符为 1.3.6.1.2.1。在 mib-2 下面包含了所有被 SNMP 管理的对象（见下面7.2.2）。</p>
<h3 id="7-2-2-被管对象的数据类型"><a href="#7-2-2-被管对象的数据类型" class="headerlink" title="7.2.2 被管对象的数据类型"></a>7.2.2 被管对象的数据类型</h3><p>SMI 使用基本的抽象语法记法 1（即 ISO 制定的 ASN.1R）来定义数据类型，但又增加了一些新的定义。因此 SMI 既是 ASN.1 的子集，又是 ASN.1 的超集。ASN.1 的记法很严格，它使得数据的含义不存在任何可能的二义性。</p>
<p><strong>SMI 把数据类型分为两大类：</strong></p>
<ol>
<li><strong>简单类型：</strong>简单类型是最基本的、直接使用ASN.1定义的类型。</li>
<li><strong>结构化类型</strong></li>
</ol>
<p><img src="/../img/post/computer-network/6-22.jpg" srcset="/img/loading.gif" lazyload></p>
<p>SMI 定义了两种结构化数据类型，即 sequence 和 sequence of。</p>
<h3 id="7-2-3-编码方法"><a href="#7-2-3-编码方法" class="headerlink" title="7.2.3 编码方法"></a>7.2.3 编码方法</h3><p>SMI 使用 ASN.1 制定的基本编码规则 BER（Basic Encoding Rule）进行数据的编码。BER 指明了每种数据的类型和值。在发送端用 BER 编码，可把用 ASN.1 所表述的报文转换成唯一的比特序列。在接收端用 BER 进行解码，就可得到该比特序列所表示的 ASN.1 报文。</p>
<p><strong>ASN.1 把所有的数据元素都表示为 T-L-V 三个字段组成的序列：</strong></p>
<ul>
<li><strong>T 字段（Tag）：</strong>定义数据的类型，又分为三个子字段：<ul>
<li><strong>类别（2位）：</strong>共四种：<ul>
<li><strong>通用类（00）：</strong>即 ASN.1 定义的类型；</li>
<li><strong>应用类（01）：</strong>即 SMI 定义的类型；</li>
<li><strong>上下文类（10）：</strong>即上下文所定义的类型；</li>
<li><strong>专用类（11）：</strong>保留为特定厂商定义的类型；</li>
</ul>
</li>
</ul>
</li>
<li><strong>L 字段（Length）：</strong>定义 V 字段的长度</li>
<li><strong>V 字段（Value）：</strong>用于定义数据元素的值。</li>
</ul>
<p><img src="/../img/post/computer-network/6-23.jpg" srcset="/img/loading.gif" lazyload></p>
<h2 id="7-3-管理信息库-MIB"><a href="#7-3-管理信息库-MIB" class="headerlink" title="7.3 管理信息库 MIB"></a>7.3 管理信息库 MIB</h2><p>所谓“管理信息”就是指在互联网的网管框架中被管对象的集合。被管对象必须维持可供管理程序读写的若干控制和状态信息。这些被管对象构成了一个虚拟的信息存储器，所以才称为管理信息库 MIB。</p>
<h2 id="7-4-SNMP-的协议数据单元和报文"><a href="#7-4-SNMP-的协议数据单元和报文" class="headerlink" title="7.4 SNMP 的协议数据单元和报文"></a>7.4 SNMP 的协议数据单元和报文</h2><p>实际上，SNMP 的操作只有两种基本的管理功能，即：</p>
<ul>
<li><strong>“读”操作：</strong>用 Get 报文来检测各被管对象的状况</li>
<li><strong>“写”操作：</strong>用 Set 报文来改变各被管对象的状况</li>
</ul>
<p>SNMP 的这些功能通过<strong>探询</strong>操作来实现，即 SNMP 管理进程定时向被管理设备周期性地发送探询信息。</p>
<p>SNMP 使用无连接的 UDP，因此在网络上传送 SNMP 报文的开销较小。但 UDP 是不保证可靠交付的。这里还要指出，SNMP使用UDP 的方法有些特殊。在运行代理程序的<strong>服务器端用熟知端口 161 来接收 Get 或 Set 报文和发送响应报文</strong>（与熟知端口通信的客户端使用临时端口），<strong>但运行管理程序的客户端则使用熟知端口 162 来接收来自各代理的 trap 报文</strong>。</p>
<p>和大多数 TCP&#x2F;IP 协议不一样，SNMP 报文没有固定的字段。相反，它们使用标准ASN.1 编码。</p>
<p><img src="/../img/post/computer-network/6-24.jpg" srcset="/img/loading.gif" lazyload></p>
<ol>
<li><strong>请求标识符（request ID）：</strong>由管理进程设置的4字节整数值。</li>
<li><strong>差错状态（error status）：</strong>在请求报文中，这个字段是 0。当代理进程响应时，就填入 0~18（例如 0表示 noError 一切正常，1 表示t ooBig 代理无法把回答装入一个 SNMP 报文中）</li>
<li><strong>差错索引（error index）：</strong>在请求报文中，这个字段是零。当代理进程响应时，代理进程就设置一个整数，指明有差错的变量在变量列表中的偏移。</li>
<li><strong>变量绑定（variable-bindings）：</strong>指明一个或多个变量的名和对应的值。在请求报文中，变量的值应忽略（类型是 NULL）。</li>
</ol>
<h1 id="8-应用进程跨越网络的通信"><a href="#8-应用进程跨越网络的通信" class="headerlink" title="8.应用进程跨越网络的通信"></a>8.应用进程跨越网络的通信</h1><h2 id="8-1-系统调用和应用编程接口"><a href="#8-1-系统调用和应用编程接口" class="headerlink" title="8.1 系统调用和应用编程接口"></a>8.1 系统调用和应用编程接口</h2><p>大多数操作系统使用<strong>系统调用（system call）</strong>的机制在应用程序和操作系统之间传递控制权。</p>
<p><img src="/../img/post/computer-network/6-25.jpg" srcset="/img/loading.gif" lazyload></p>
<p>当某个应用进程启动系统调用时，<strong>控制权就从应用进程传递给了系统调用接口</strong>。</p>
<p>系统调用接口又称为应用编程接口 API。</p>
<ul>
<li>Unix 定义了一种 API，称为套接字接口（socket interface）</li>
<li>Windows 采用了套接字接口 API，形成一个稍有不同的 Windows Socket</li>
</ul>
<p><img src="/../img/post/computer-network/6-26.jpg" srcset="/img/loading.gif" lazyload></p>
<h2 id="8-2-几种常用的系统调用"><a href="#8-2-几种常用的系统调用" class="headerlink" title="8.2 几种常用的系统调用"></a>8.2 几种常用的系统调用</h2><h3 id="8-2-1-连接建立阶段"><a href="#8-2-1-连接建立阶段" class="headerlink" title="8.2.1 连接建立阶段"></a>8.2.1 连接建立阶段</h3><p><img src="/../img/post/computer-network/6-27.jpg" srcset="/img/loading.gif" lazyload></p>
<p>在任一时刻，服务器中总是有一个主服务器进程和零个或多个从属服务器进程。主服务器进程用原来的套接字接受连接请求，而从属服务器进程用新创建的套接字和相应的客户建立连接并可进行双向传送数据。</p>
<h3 id="8-2-2-数据传送阶段"><a href="#8-2-2-数据传送阶段" class="headerlink" title="8.2.2 数据传送阶段"></a>8.2.2 数据传送阶段</h3><p><strong>调用 send 需要三个变量：</strong></p>
<ol>
<li>数据要发往的套接字的描述符</li>
<li>要发送的数据的地址</li>
<li>数据的长度</li>
</ol>
<p><strong>调用 recv 也需要三个变量：</strong></p>
<ol>
<li>要使用的套接字的描述符</li>
<li>缓存的地址</li>
<li>缓存空间的长度</li>
</ol>
<h3 id="8-2-3-连接释放阶段"><a href="#8-2-3-连接释放阶段" class="headerlink" title="8.2.3 连接释放阶段"></a>8.2.3 连接释放阶段</h3><p>一旦客户或服务器结束使用套接字，就把套接字撤销。这时就调用 close 释放连接和撤销套接字。</p>
<p><img src="/../img/post/computer-network/6-28.jpg" srcset="/img/loading.gif" lazyload></p>
<p>UDP 服务器由于只提供无连接服务，因此不使用 listen 和 accept 系统调用。</p>
<h1 id="9-P2P-应用"><a href="#9-P2P-应用" class="headerlink" title="9.P2P 应用"></a>9.P2P 应用</h1><p>P2P 应用就是指具有 P2P 体系结构的网络应用。所谓 P2P 体系结构就是在这样的网络应用中，没有（或只有极少数的）固定的服务器，而绝大多数的交互都是使用对等方式（P2P 方式）进行的。</p>
<p>P2P 应用的范围很广，例如，文件分发、实时音频或视频会议、数据库系统、网络服务支持（如 P2P 打车软件、P2P 理财等）。</p>
<h2 id="9-1-具有集中目录服务器的-P2P-工作方式"><a href="#9-1-具有集中目录服务器的-P2P-工作方式" class="headerlink" title="9.1 具有集中目录服务器的 P2P 工作方式"></a>9.1 具有集中目录服务器的 P2P 工作方式</h2><p>最早使用 P2P 工作方式的是 Napster，具有集中目录服务器的工作方式。</p>
<h2 id="9-2-具有全分布式结构的-P2P-文件共享程序"><a href="#9-2-具有全分布式结构的-P2P-文件共享程序" class="headerlink" title="9.2 具有全分布式结构的 P2P 文件共享程序"></a>9.2 具有全分布式结构的 P2P 文件共享程序</h2><p>在第一代 P2P 文件共享网站 Napster 关闭后，开始出现了以 Gnutella 为代表的第二代P2P 文件共享程序。最大的区别就是不使用集中式的目录服务器进行查询，而是使用洪泛法在大量 Gnutella 用户之间进行查询。</p>
<p>第三代 P2P，如 eMule, Bit Torrent 等。</p>
<h2 id="9-3-P2P-文件分发的分析"><a href="#9-3-P2P-文件分发的分析" class="headerlink" title="9.3 P2P 文件分发的分析"></a>9.3 P2P 文件分发的分析</h2><p>在 P2P 方式下所有主机都下载完文件 F 的最少时间的下限是：</p>
<p>$$<br>T_{P2P} &gt;&#x3D; max{\frac{F}{u_s},\frac{F}{d_{min}},\frac{NF}{u_T} }<br>$$</p>
<h2 id="9-4-在-P2P-对等方中搜索对象"><a href="#9-4-在-P2P-对等方中搜索对象" class="headerlink" title="9.4 在 P2P 对等方中搜索对象"></a>9.4 在 P2P 对等方中搜索对象</h2><p>在 P2P 文件系统中，对等方用户的数量非常多，并且处于一种无序的状态。任何一个对等方可以随时加入进来或随时退出。怎样有效地找到所需的文件？可以利用<strong>散列函数</strong>来定位对等方。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="category-chain-item">计算机网络</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AF%BE%E6%9C%AC/" class="print-no-link">#课本</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机网络 第六章：应用层</div>
      <div>https://pudding.nousbuild.com/computer-network-6/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Haoning Wu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年6月30日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年10月14日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-cc-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
                  <span class="hint--top hint--rounded" aria-label="ND - 禁止演绎">
                    <i class="iconfont icon-cc-nd"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/computer-network-7/" title="计算机网络 第七章：网络安全">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机网络 第七章：网络安全</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/computer-network-5/" title="计算机网络 第五章：运输层">
                        <span class="hidden-mobile">计算机网络 第五章：运输层</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"3d7d322afed4a293d6ac","clientSecret":"13a2463fec33044c22ddc5678f8a29086b20eb19","repo":"pudding0503.github.io","owner":"pudding0503","admin":["pudding0503"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '45a0c74c0e7a0afd26d6ac333fb462cf'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <p> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </p>
<p> © <a href="https://www.nousbuild.org" target="_blank" rel="nofollow noopener"><span>图筑风暻</span></a> 版权所有 </p> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      陕ICP备14012493号
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61010302000322"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>陕公网安备61010302000322号</span>
        </a>
      </span>
    
  
</div>

  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
